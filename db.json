{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source/images/jvm/ClassLoader.png","path":"images/jvm/ClassLoader.png","modified":1,"renderable":0},{"_id":"source/images/jvm/JVM_Structure.png","path":"images/jvm/JVM_Structure.png","modified":1,"renderable":0},{"_id":"source/images/jvm/JVMRuntime.png","path":"images/jvm/JVMRuntime.png","modified":1,"renderable":0},{"_id":"source/images/jvm/ParentsDelegationModel.png","path":"images/jvm/ParentsDelegationModel.png","modified":1,"renderable":0},{"_id":"source/images/jvm/StackFrame.png","path":"images/jvm/StackFrame.png","modified":1,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/js/algolia-search.js","path":"js/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/bookmark.js","path":"js/bookmark.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/local-search.js","path":"js/local-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/anime.min.js","path":"lib/anime.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/schemes/pisces.js","path":"js/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-regular-400.woff2","path":"lib/font-awesome/webfonts/fa-regular-400.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-brands-400.woff2","path":"lib/font-awesome/webfonts/fa-brands-400.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/all.min.css","path":"lib/font-awesome/css/all.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-solid-900.woff2","path":"lib/font-awesome/webfonts/fa-solid-900.woff2","modified":1,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"8369d92b3c68f76343e54bb1e86851407130ee49","modified":1603786095918},{"_id":"themes/next/.editorconfig","hash":"8570735a8d8d034a3a175afd1dd40b39140b3e6a","modified":1603786095991},{"_id":"themes/next/.gitattributes","hash":"a54f902957d49356376b59287b894b1a3d7a003f","modified":1603786095992},{"_id":"themes/next/.gitignore","hash":"56f3470755c20311ddd30d421b377697a6e5e68b","modified":1603786095999},{"_id":"themes/next/.eslintrc.json","hash":"cc5f297f0322672fe3f684f823bc4659e4a54c41","modified":1603786095991},{"_id":"themes/next/.travis.yml","hash":"ecca3b919a5b15886e3eca58aa84aafc395590da","modified":1603786095999},{"_id":"themes/next/.stylintrc","hash":"2cf4d637b56d8eb423f59656a11f6403aa90f550","modified":1603786095999},{"_id":"themes/next/LICENSE.md","hash":"18144d8ed58c75af66cb419d54f3f63374cd5c5b","modified":1603786096000},{"_id":"themes/next/README.md","hash":"9b4b7d66aca47f9c65d6321b14eef48d95c4dff1","modified":1603786096000},{"_id":"themes/next/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1603786096002},{"_id":"themes/next/_config zh-cn.yml","hash":"d04c31d87f346d18e62ac545e1a5936a03474211","modified":1603786096001},{"_id":"themes/next/_config.yml","hash":"e9a84b68e60e9fbedf4990eb7b3abccdfd6bc7cb","modified":1603786096001},{"_id":"themes/next/package.json","hash":"62fad6de02adbbba9fb096cbe2dcc15fe25f2435","modified":1603786096060},{"_id":"themes/next/gulpfile.js","hash":"1b4fc262b89948937b9e3794de812a7c1f2f3592","modified":1603786096013},{"_id":"source/categories/index.md","hash":"728cd29cd97177153bc7f2d80af9aea1bb1cacea","modified":1603786095943},{"_id":"source/about/index.md","hash":"0a58dc2fbc87bc10d88122ebad3dfd50b4b20d1a","modified":1603786095943},{"_id":"themes/next/.github/CODE_OF_CONDUCT.md","hash":"aa4cb7aff595ca628cb58160ee1eee117989ec4e","modified":1603786095992},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"e554931b98f251fd49ff1d2443006d9ea2c20461","modified":1603786095993},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"1a435c20ae8fa183d49bbf96ac956f7c6c25c8af","modified":1603786095995},{"_id":"themes/next/.github/config.yml","hash":"1d3f4e8794986817c0fead095c74f756d45f91ed","modified":1603786095996},{"_id":"themes/next/.github/issue_label_bot.yaml","hash":"fca600ddef6f80c5e61aeed21722d191e5606e5b","modified":1603786095996},{"_id":"themes/next/.github/issue-close-app.yml","hash":"7cba457eec47dbfcfd4086acd1c69eaafca2f0cd","modified":1603786095996},{"_id":"themes/next/.github/lock.yml","hash":"61173b9522ebac13db2c544e138808295624f7fd","modified":1603786095997},{"_id":"themes/next/.github/mergeable.yml","hash":"0ee56e23bbc71e1e76427d2bd255a9879bd36e22","modified":1603786095997},{"_id":"themes/next/.github/release-drafter.yml","hash":"3cc10ce75ecc03a5ce86b00363e2a17eb65d15ea","modified":1603786095998},{"_id":"themes/next/.github/stale.yml","hash":"fdf82de9284f8bc8e0b0712b4cc1cb081a94de59","modified":1603786095998},{"_id":"themes/next/.github/support.yml","hash":"d75db6ffa7b4ca3b865a925f9de9aef3fc51925c","modified":1603786095998},{"_id":"themes/next/docs/ALGOLIA-SEARCH.md","hash":"c7a994b9542040317d8f99affa1405c143a94a38","modified":1603786096003},{"_id":"themes/next/docs/DATA-FILES.md","hash":"cddbdc91ee9e65c37a50bec12194f93d36161616","modified":1603786096004},{"_id":"themes/next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1603786096003},{"_id":"themes/next/docs/INSTALLATION.md","hash":"af88bcce035780aaa061261ed9d0d6c697678618","modified":1603786096004},{"_id":"themes/next/docs/AUTHORS.md","hash":"10135a2f78ac40e9f46b3add3e360c025400752f","modified":1603786096004},{"_id":"themes/next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"94dc3404ccb0e5f663af2aa883c1af1d6eae553d","modified":1603786096005},{"_id":"themes/next/docs/LICENSE.txt","hash":"368bf2c29d70f27d8726dd914f1b3211cae4bbab","modified":1603786096005},{"_id":"themes/next/docs/UPDATE-FROM-5.1.X.md","hash":"8b6e4b2c9cfcb969833092bdeaed78534082e3e6","modified":1603786096006},{"_id":"themes/next/docs/MATH.md","hash":"d645b025ec7fb9fbf799b9bb76af33b9f5b9ed93","modified":1603786096006},{"_id":"themes/next/languages/de.yml","hash":"74c59f2744217003b717b59d96e275b54635abf5","modified":1603786096014},{"_id":"themes/next/languages/ar.yml","hash":"9815e84e53d750c8bcbd9193c2d44d8d910e3444","modified":1603786096013},{"_id":"themes/next/languages/es.yml","hash":"c64cf05f356096f1464b4b1439da3c6c9b941062","modified":1603786096016},{"_id":"themes/next/languages/en.yml","hash":"45bc5118828bdc72dcaa25282cd367c8622758cb","modified":1603786096015},{"_id":"themes/next/languages/default.yml","hash":"45bc5118828bdc72dcaa25282cd367c8622758cb","modified":1603786096015},{"_id":"themes/next/languages/fa.yml","hash":"3676b32fda37e122f3c1a655085a1868fb6ad66b","modified":1603786096016},{"_id":"themes/next/languages/hu.yml","hash":"b1ebb77a5fd101195b79f94de293bcf9001d996f","modified":1603786096017},{"_id":"themes/next/languages/fr.yml","hash":"752bf309f46a2cd43890b82300b342d7218d625f","modified":1603786096017},{"_id":"themes/next/languages/ja.yml","hash":"0cf0baa663d530f22ff380a051881216d6adcdd8","modified":1603786096019},{"_id":"themes/next/languages/it.yml","hash":"44759f779ce9c260b895532de1d209ad4bd144bf","modified":1603786096018},{"_id":"themes/next/languages/id.yml","hash":"572ed855d47aafe26f58c73b1394530754881ec2","modified":1603786096018},{"_id":"themes/next/languages/nl.yml","hash":"5af3473d9f22897204afabc08bb984b247493330","modified":1603786096020},{"_id":"themes/next/languages/ko.yml","hash":"0feea9e43cd399f3610b94d755a39fff1d371e97","modified":1603786096019},{"_id":"themes/next/languages/pt-BR.yml","hash":"67555b1ba31a0242b12fc6ce3add28531160e35b","modified":1603786096020},{"_id":"themes/next/languages/ru.yml","hash":"e993d5ca072f7f6887e30fc0c19b4da791ca7a88","modified":1603786096021},{"_id":"themes/next/languages/pt.yml","hash":"718d131f42f214842337776e1eaddd1e9a584054","modified":1603786096020},{"_id":"themes/next/languages/vi.yml","hash":"93393b01df148dcbf0863f6eee8e404e2d94ef9e","modified":1603786096022},{"_id":"themes/next/languages/uk.yml","hash":"3a6d635b1035423b22fc86d9455dba9003724de9","modified":1603786096022},{"_id":"themes/next/languages/tr.yml","hash":"fe793f4c2608e3f85f0b872fd0ac1fb93e6155e2","modified":1603786096021},{"_id":"themes/next/languages/zh-CN.yml","hash":"a1f15571ee7e1e84e3cc0985c3ec4ba1a113f6f8","modified":1603786096022},{"_id":"themes/next/languages/zh-HK.yml","hash":"3789f94010f948e9f23e21235ef422a191753c65","modified":1603786096023},{"_id":"themes/next/languages/zh-TW.yml","hash":"8c09da7c4ec3fca2c6ee897b2eea260596a2baa1","modified":1603786096023},{"_id":"themes/next/layout/index.swig","hash":"7f403a18a68e6d662ae3e154b2c1d3bbe0801a23","modified":1603786096059},{"_id":"themes/next/layout/_layout.swig","hash":"6a6e92a4664cdb981890a27ac11fd057f44de1d5","modified":1603786096024},{"_id":"themes/next/layout/post.swig","hash":"2f6d992ced7e067521fdce05ffe4fd75481f41c5","modified":1603786096060},{"_id":"themes/next/layout/archive.swig","hash":"e4e31317a8df68f23156cfc49e9b1aa9a12ad2ed","modified":1603786096058},{"_id":"themes/next/layout/category.swig","hash":"1bde61cf4d2d171647311a0ac2c5c7933f6a53b0","modified":1603786096059},{"_id":"themes/next/layout/page.swig","hash":"db581bdeac5c75fabb0f17d7c5e746e47f2a9168","modified":1603786096059},{"_id":"themes/next/layout/tag.swig","hash":"0dfb653bd5de980426d55a0606d1ab122bd8c017","modified":1603786096060},{"_id":"themes/next/scripts/renderer.js","hash":"49a65df2028a1bc24814dc72fa50d52231ca4f05","modified":1603786096071},{"_id":"source/_posts/algorithm/LeetCode 122. 买卖股票的最佳时机 ii.md","hash":"23804e75431ba86917fcfe71410ff09a613339c8","modified":1603786095919},{"_id":"source/_posts/algorithm/LeetCode 14. 最长公共前缀.md","hash":"15a6a013edc82be05ce7a21d3a530146c71ebc09","modified":1603786095920},{"_id":"source/_posts/algorithm/LeetCode 141. Linked List Cycle.md","hash":"44ab6915ecb4de39147541c10c6ad46b8337f6a9","modified":1603786095920},{"_id":"source/_posts/algorithm/LeetCode 15. 三数之和.md","hash":"60352735dafd66f9ab759569d1938e42c2249670","modified":1603786095921},{"_id":"source/_posts/algorithm/LeetCode 189. 翻转数组.md","hash":"7a173da2031c5c81f95bf656fb618d3285e8df6a","modified":1603786095921},{"_id":"source/_posts/algorithm/LeetCode 19. Remove Nth Node From End of List.md","hash":"da8332515c5583de4892b9213da2a49826faf8f2","modified":1603786095921},{"_id":"source/_posts/algorithm/LeetCode 21. Merge Two Sorted Lists.md","hash":"ffe97afa1e3255ef75fb3ae2188b07e2baeff5f6","modified":1603786095923},{"_id":"source/_posts/algorithm/LeetCode 2. 两数相加.md","hash":"098fd460468d316a7d46448c3bd087b0716ecb3b","modified":1603786095922},{"_id":"source/_posts/algorithm/LeetCode 206. Reverse Linked List.md","hash":"322d6c60cba2143aec165eb01c4bce5f077b195b","modified":1603786095922},{"_id":"source/_posts/algorithm/LeetCode 27. 移除数组元素.md","hash":"7f1afdf14991534e2d8c1f7d9ee802148e86eca1","modified":1603786095923},{"_id":"source/_posts/algorithm/LeetCode 350. 两个数组的交集.md","hash":"ff0cca87e05b8df9fa150a916a06033af76fa796","modified":1603786095923},{"_id":"source/_posts/algorithm/LeetCode 66. 加一.md","hash":"4f6d0a04c03726530c7c488d6be16fffa4cc4566","modified":1603786095924},{"_id":"source/_posts/algorithm/LeetCode 6. Z字形变换.md","hash":"b3de4bd69f1e60dd379b33659317659986dcb4d7","modified":1603786095924},{"_id":"source/_posts/algorithm/LeetCode 876. Middle of the Linked List.md","hash":"38b0e2717a3d7e9b635c67db0270788631819581","modified":1603786095925},{"_id":"source/_posts/algorithm/LeetCode-101-对称二叉树.md","hash":"bfc3ee8f7e8cb0548e4093365f13cbb45c2e9971","modified":1603786095925},{"_id":"source/_posts/algorithm/LeetCode-104-二叉树的最大深度.md","hash":"88c9ac05a9aa8f92ce22d4a6c59a60727110350a","modified":1603786095926},{"_id":"source/_posts/algorithm/LeetCode-102-二叉树的层序遍历.md","hash":"8753a636661efb4627861105f281af86fe6e7460","modified":1603786095925},{"_id":"source/_posts/algorithm/LeetCode-112-路径总和.md","hash":"5eced44254addcf3c73e52f52cd94cf53f44a2db","modified":1603786095926},{"_id":"source/_posts/algorithm/LeetCode-144-二叉树的前序遍历.md","hash":"f0068c3ce2b26c3225a6965718e3272e4a8235dc","modified":1603786095927},{"_id":"source/_posts/algorithm/LeetCode-53-最大子序和.md","hash":"33a8c1599e4c2a2886471e94b7bcc80b7e55782e","modified":1603786095928},{"_id":"source/_posts/algorithm/LeetCode-94-二叉树的中序遍历.md","hash":"bc9dd356273b89f78a2a7110f444543aa13efc3b","modified":1603786095928},{"_id":"source/_posts/algorithm/LeetCode-145-二叉树的后序遍历.md","hash":"43f080b94626dd60ab65db0e6ac650d1ef5cab41","modified":1603786095927},{"_id":"source/_posts/algorithm/LeetCode-977-有序数组的平方.md","hash":"8a9501390240324b6ff9d83c832c09f0730a35fd","modified":1603786095929},{"_id":"source/_posts/algorithm/打印两个有序链表的公共部分.md","hash":"62e6bc994322ff8239b03f0625eff6c3765c501a","modified":1603786095930},{"_id":"source/_posts/algorithm/仅用递归函数和栈操作逆序一个栈.md","hash":"169a0d5d7f17b8d1ef9f7dfcf1c7cd5f39ce96a0","modified":1603786095929},{"_id":"source/_posts/algorithm/单链表删除倒数第K个节点.md","hash":"6e2b31b678cc9aea47ed8355cf578ca6e21a29dd","modified":1603786095929},{"_id":"source/_posts/algorithm/汉诺塔问题.md","hash":"b1c967fbe39e04e7cdadeb2c149f15c995b8046d","modified":1603786095930},{"_id":"source/_posts/algorithm/猫狗队列.md","hash":"1c34a0ad0e4efc72467f701f18a597425e878a1d","modified":1603786095931},{"_id":"source/_posts/algorithm/爬楼梯.md","hash":"201d7fd090f08621bbfd0c82382b0666cb2cdaaa","modified":1603786095931},{"_id":"source/_posts/algorithm/用一个栈实现另一个栈的排序.md","hash":"c2853970c14f71fa2590676db4a194f3ff1ac291","modified":1603786095932},{"_id":"source/_posts/algorithm/由两个栈组成的队列.md","hash":"c2a146169ba8a81c86613832acf23d09091587b8","modified":1603786095932},{"_id":"source/_posts/algorithm/移动零.md","hash":"505198c17361460c029a3d061c60a9758b228bd0","modified":1603786095933},{"_id":"source/_posts/designpattern/设计模式0-开篇.md","hash":"3ce8a0bde5094d2097887fe7a06eda33847f8eed","modified":1603786095936},{"_id":"source/_posts/algorithm/设计一个有getMin功能的栈.md","hash":"ccd51a704d75532bc0a54ffaf149da0468b398bc","modified":1603786095933},{"_id":"source/_posts/designpattern/设计模式1-软件设计原则.md","hash":"a3bc4104f2796320d1e0018d446455b4cbb3e3b7","modified":1603786095937},{"_id":"source/_posts/bigdata/Designing-Data-Intensive-Applications-7-事务.md","hash":"dbc5c29a4da1510b2d4e8e41cea05e0fd4266286","modified":1603786095934},{"_id":"source/_posts/bigdata/数仓2-数仓分层，实时vs离线.md","hash":"d9982111b01d74c4a6d4380a548f6c6b44ae61d1","modified":1606467633882},{"_id":"source/_posts/bigdata/HDFS原理.md","hash":"34175d93c7b239c968023de784d2d6faf1a3b4c7","modified":1603786095934},{"_id":"source/_posts/bigdata/数仓1.聊聊数据采集.md","hash":"8d41dcd8c9eaeb440069d498b59c11c5552f7fd9","modified":1603786095935},{"_id":"source/_posts/flink/Flink-2-流计算API.md","hash":"ca76c5666dc0cacd1002fc51dceafa0a5b3b1459","modified":1603786095939},{"_id":"source/_posts/bigdata/数据收集-1-Flume.md","hash":"0b029ddc46416eb00e0414caecb6823403280f7c","modified":1603786095936},{"_id":"source/_posts/flink/Flink-4-Connectors.md","hash":"7f763707f46d93257392710db12ab88600c560de","modified":1607932302222},{"_id":"source/_posts/flink/Flink-3-窗口.md","hash":"77fb3c315b43eca9001843a43a5710d555a06e7e","modified":1603786095939},{"_id":"source/_posts/flink/Flink-0-流处理基本概念.md","hash":"d2491b169c123d6570172ae43ebfb6a0ce5212f8","modified":1603786095938},{"_id":"source/_posts/distribute/读DDIA-4-数据编码与演化.md","hash":"100f08d088406814ed77b61c7e5e4f2114d407fd","modified":1603786095937},{"_id":"source/_posts/flink/Flink-5-State.md","hash":"8d9772cad70ac0e0fe21aace873b649e87f50ef1","modified":1607504727628},{"_id":"source/_posts/microservice/Kong路由配置策略及JWT校验.md","hash":"63f2526ee245b71dfbe1039c7721401fa1e0431f","modified":1603786095941},{"_id":"source/_posts/flink/Flink-1-Flink基本架构.md","hash":"96388860e167137ce8a9f5cede228b02a50e379c","modified":1603786095938},{"_id":"source/_posts/flink/Flink-CDC踩坑集合.md","hash":"6c73ebf203a4e24e9afd49c81c0be5e107bb3b8c","modified":1607924698864},{"_id":"source/_posts/microservice/微服务改造-2-网关.md","hash":"f13f33298ec0f86613482ed366255100755d8edb","modified":1603786095942},{"_id":"source/_posts/microservice/微服务改造-1-配置中心.md","hash":"68dd3b6348fb64d8a38a5b8c9e5c00cc8151393c","modified":1603786095941},{"_id":"source/_posts/java/JVM常用知识点.md","hash":"984b875036d469eac379f2c129553eb2ceb6f3e7","modified":1603786095940},{"_id":"source/_posts/microservice/微服务改造-3-Kong路由配置实战及JWT校验.md","hash":"09f6eb83bc0280549b650e17726a3691710f9421","modified":1603786095942},{"_id":"source/images/jvm/ClassLoader.png","hash":"1de0e95128b2d5cdfc96d0e7e61df70247d1f572","modified":1603786095944},{"_id":"source/images/jvm/JVM_Structure.png","hash":"bb1666f5e738139547cf9e1a71ba5e145c7c622e","modified":1603786095946},{"_id":"source/images/jvm/JVMRuntime.png","hash":"5d57ec013f5c5ea4107406c40b04838128e73a13","modified":1603786095945},{"_id":"themes/next/.github/ISSUE_TEMPLATE/bug-report.md","hash":"c3e6b8196c983c40fd140bdeca012d03e6e86967","modified":1603786095994},{"_id":"themes/next/.github/ISSUE_TEMPLATE/feature-request.md","hash":"12d99fb8b62bd9e34d9672f306c9ae4ace7e053e","modified":1603786095994},{"_id":"themes/next/.github/ISSUE_TEMPLATE/other.md","hash":"d3efc0df0275c98440e69476f733097916a2d579","modified":1603786095994},{"_id":"source/images/jvm/ParentsDelegationModel.png","hash":"002674ceab918d46ecede15ba5b0d3ac15a22422","modified":1603786095946},{"_id":"source/images/jvm/StackFrame.png","hash":"e51a3a21b9a5e3ebed473ed7a085d1e9f933437a","modified":1603786095947},{"_id":"themes/next/.github/ISSUE_TEMPLATE/question.md","hash":"53df7d537e26aaf062d70d86835c5fd8f81412f3","modified":1603786095995},{"_id":"themes/next/docs/ru/DATA-FILES.md","hash":"0bd2d696f62a997a11a7d84fec0130122234174e","modified":1603786096007},{"_id":"themes/next/docs/ru/INSTALLATION.md","hash":"9c4fe2873123bf9ceacab5c50d17d8a0f1baef27","modified":1603786096007},{"_id":"themes/next/docs/ru/README.md","hash":"85dd68ed1250897a8e4a444a53a68c1d49eb7e11","modified":1603786096007},{"_id":"themes/next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"5237a368ab99123749d724b6c379415f2c142a96","modified":1603786096008},{"_id":"themes/next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"34b88784ec120dfdc20fa82aadeb5f64ef614d14","modified":1603786096009},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"d3f03be036b75dc71cf3c366cd75aee7c127c874","modified":1603786096010},{"_id":"themes/next/docs/zh-CN/DATA-FILES.md","hash":"ca1030efdfca5e20f9db2e7a428998e66a24c0d0","modified":1603786096010},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"fb23b85db6f7d8279d73ae1f41631f92f64fc864","modified":1603786096009},{"_id":"themes/next/docs/zh-CN/INSTALLATION.md","hash":"579c7bd8341873fb8be4732476d412814f1a3df7","modified":1603786096011},{"_id":"themes/next/docs/zh-CN/README.md","hash":"c038629ff8f3f24e8593c4c8ecf0bef3a35c750d","modified":1603786096012},{"_id":"themes/next/docs/zh-CN/MATH.md","hash":"b92585d251f1f9ebe401abb5d932cb920f9b8b10","modified":1603786096011},{"_id":"themes/next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"8b18f84503a361fc712b0fe4d4568e2f086ca97d","modified":1603786096011},{"_id":"themes/next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"d9ce7331c1236bbe0a551d56cef2405e47e65325","modified":1603786096012},{"_id":"themes/next/layout/_partials/comments.swig","hash":"db6ab5421b5f4b7cb32ac73ad0e053fdf065f83e","modified":1603786096026},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"71655ca21907e9061b6e8ac52d0d8fbf54d0062b","modified":1603786096026},{"_id":"themes/next/layout/_macro/post.swig","hash":"090b5a9b6fca8e968178004cbd6cff205b7eba57","modified":1603786096025},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"9c8dc0b8170679cdc1ee9ee8dbcbaebf3f42897b","modified":1603786096025},{"_id":"themes/next/layout/_partials/languages.swig","hash":"ba9e272f1065b8f0e8848648caa7dea3f02c6be1","modified":1603786096031},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9876dbfc15713c7a47d4bcaa301f4757bd978269","modified":1603786096033},{"_id":"themes/next/layout/_partials/footer.swig","hash":"700c3e7bd449bce51f6faee42c052e13ed5f8b3e","modified":1603786096027},{"_id":"themes/next/layout/_scripts/index.swig","hash":"cea942b450bcb0f352da78d76dc6d6f1d23d5029","modified":1603786096039},{"_id":"themes/next/layout/_scripts/noscript.swig","hash":"d1f2bfde6f1da51a2b35a7ab9e7e8eb6eefd1c6b","modified":1603786096039},{"_id":"themes/next/layout/_partials/widgets.swig","hash":"83a40ce83dfd5cada417444fb2d6f5470aae6bb0","modified":1603786096038},{"_id":"themes/next/layout/_scripts/pjax.swig","hash":"4d2c93c66e069852bb0e3ea2e268d213d07bfa3f","modified":1603786096040},{"_id":"themes/next/layout/_scripts/three.swig","hash":"a4f42f2301866bd25a784a2281069d8b66836d0b","modified":1603786096042},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"ef38c213679e7b6d2a4116f56c9e55d678446069","modified":1603786096043},{"_id":"themes/next/layout/_third-party/baidu-push.swig","hash":"b782eb2e34c0c15440837040b5d65b093ab6ec04","modified":1603786096045},{"_id":"themes/next/layout/_third-party/index.swig","hash":"70c3c01dd181de81270c57f3d99b6d8f4c723404","modified":1603786096050},{"_id":"themes/next/layout/_third-party/quicklink.swig","hash":"311e5eceec9e949f1ea8d623b083cec0b8700ff2","modified":1603786096052},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"2731e262a6b88eaee2a3ca61e6a3583a7f594702","modified":1603786096052},{"_id":"themes/next/scripts/events/index.js","hash":"5743cde07f3d2aa11532a168a652e52ec28514fd","modified":1603786096061},{"_id":"themes/next/scripts/filters/default-injects.js","hash":"aec50ed57b9d5d3faf2db3c88374f107203617e0","modified":1603786096067},{"_id":"themes/next/scripts/filters/front-matter.js","hash":"703bdd142a671b4b67d3d9dfb4a19d1dd7e7e8f7","modified":1603786096068},{"_id":"themes/next/scripts/filters/locals.js","hash":"b193a936ee63451f09f8886343dcfdca577c0141","modified":1603786096068},{"_id":"themes/next/scripts/filters/minify.js","hash":"19985723b9f677ff775f3b17dcebf314819a76ac","modified":1603786096068},{"_id":"themes/next/scripts/filters/post.js","hash":"44ba9b1c0bdda57590b53141306bb90adf0678db","modified":1603786096069},{"_id":"themes/next/scripts/helpers/engine.js","hash":"bdb424c3cc0d145bd0c6015bb1d2443c8a9c6cda","modified":1603786096070},{"_id":"themes/next/scripts/helpers/font.js","hash":"40cf00e9f2b7aa6e5f33d412e03ed10304b15fd7","modified":1603786096070},{"_id":"themes/next/scripts/helpers/next-config.js","hash":"5e11f30ddb5093a88a687446617a46b048fa02e5","modified":1603786096070},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"958e86b2bd24e4fdfcbf9ce73e998efe3491a71f","modified":1603786096071},{"_id":"themes/next/scripts/tags/button.js","hash":"8c6b45f36e324820c919a822674703769e6da32c","modified":1603786096072},{"_id":"themes/next/scripts/tags/caniuse.js","hash":"94e0bbc7999b359baa42fa3731bdcf89c79ae2b3","modified":1603786096072},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"f1826ade2d135e2f60e2d95cb035383685b3370c","modified":1603786096073},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"d902fd313e8d35c3cc36f237607c2a0536c9edf1","modified":1603786096073},{"_id":"themes/next/scripts/tags/label.js","hash":"fc5b267d903facb7a35001792db28b801cccb1f8","modified":1603786096074},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"983c6c4adea86160ecc0ba2204bc312aa338121d","modified":1603786096074},{"_id":"themes/next/scripts/tags/note.js","hash":"0a02bb4c15aec41f6d5f1271cdb5c65889e265d9","modified":1603786096075},{"_id":"themes/next/scripts/tags/pdf.js","hash":"8c613b39e7bff735473e35244b5629d02ee20618","modified":1603786096075},{"_id":"themes/next/scripts/tags/tabs.js","hash":"93d8a734a3035c1d3f04933167b500517557ba3e","modified":1603786096075},{"_id":"themes/next/scripts/tags/video.js","hash":"e5ff4c44faee604dd3ea9db6b222828c4750c227","modified":1603786096076},{"_id":"themes/next/source/css/_colors.styl","hash":"a8442520f719d3d7a19811cb3b85bcfd4a596e1f","modified":1603786096077},{"_id":"themes/next/source/css/_mixins.styl","hash":"e31a557f8879c2f4d8d5567ee1800b3e03f91f6e","modified":1603786096109},{"_id":"themes/next/source/css/main.styl","hash":"a3a3bbb5a973052f0186b3523911cb2539ff7b88","modified":1603786096122},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1603786096123},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1603786096123},{"_id":"themes/next/source/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1603786096123},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1603786096124},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1603786096124},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1603786096125},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1603786096125},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1603786096127},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1603786096126},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1603786096127},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1603786096127},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1603786096126},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1603786096128},{"_id":"themes/next/source/js/algolia-search.js","hash":"498d233eb5c7af6940baf94c1a1c36fdf1dd2636","modified":1603786096128},{"_id":"themes/next/source/js/bookmark.js","hash":"9734ebcb9b83489686f5c2da67dc9e6157e988ad","modified":1603786096129},{"_id":"themes/next/source/js/local-search.js","hash":"35ccf100d8f9c0fd6bfbb7fa88c2a76c42a69110","modified":1603786096129},{"_id":"themes/next/source/js/motion.js","hash":"72df86f6dfa29cce22abeff9d814c9dddfcf13a9","modified":1603786096130},{"_id":"themes/next/source/js/next-boot.js","hash":"a1b0636423009d4a4e4cea97bcbf1842bfab582c","modified":1603786096130},{"_id":"themes/next/source/js/utils.js","hash":"2c6e6b4d9a592fbb4bf04689524db2cdfcd94ca7","modified":1603786096131},{"_id":"themes/next/source/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1603786096132},{"_id":"themes/next/layout/_partials/header/index.swig","hash":"7dbe93b8297b746afb89700b4d29289556e85267","modified":1603786096029},{"_id":"themes/next/layout/_partials/header/menu-item.swig","hash":"9440d8a3a181698b80e1fa47f5104f4565d8cdf3","modified":1603786096030},{"_id":"themes/next/layout/_partials/head/head-unique.swig","hash":"000bad572d76ee95d9c0a78f9ccdc8d97cc7d4b4","modified":1603786096027},{"_id":"themes/next/layout/_partials/header/brand.swig","hash":"c70f8e71e026e878a4e9d5ab3bbbf9b0b23c240c","modified":1603786096029},{"_id":"themes/next/layout/_partials/header/sub-menu.swig","hash":"ae2261bea836581918a1c2b0d1028a78718434e0","modified":1603786096031},{"_id":"themes/next/layout/_partials/post/post-footer.swig","hash":"8f14f3f8a1b2998d5114cc56b680fb5c419a6b07","modified":1603786096035},{"_id":"themes/next/layout/_partials/header/menu.swig","hash":"d31f896680a6c2f2c3f5128b4d4dd46c87ce2130","modified":1603786096030},{"_id":"themes/next/layout/_partials/head/head.swig","hash":"810d544019e4a8651b756dd23e5592ee851eda71","modified":1603786096028},{"_id":"themes/next/layout/_partials/post/post-copyright.swig","hash":"954ad71536b6eb08bd1f30ac6e2f5493b69d1c04","modified":1603786096034},{"_id":"themes/next/layout/_partials/search/algolia-search.swig","hash":"48430bd03b8f19c9b8cdb2642005ed67d56c6e0b","modified":1603786096036},{"_id":"themes/next/layout/_partials/search/index.swig","hash":"2be50f9bfb1c56b85b3b6910a7df27f51143632c","modified":1603786096037},{"_id":"themes/next/layout/_partials/post/post-reward.swig","hash":"2b1a73556595c37951e39574df5a3f20b2edeaef","modified":1603786096036},{"_id":"themes/next/layout/_partials/post/post-followme.swig","hash":"ceba16b9bd3a0c5c8811af7e7e49d0f9dcb2f41e","modified":1603786096034},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"f48a6a8eba04eb962470ce76dd731e13074d4c45","modified":1603786096037},{"_id":"themes/next/layout/_partials/post/post-related.swig","hash":"f79c44692451db26efce704813f7a8872b7e63a0","modified":1603786096035},{"_id":"themes/next/layout/_partials/page/breadcrumb.swig","hash":"c851717497ca64789f2176c9ecd1dedab237b752","modified":1603786096032},{"_id":"themes/next/layout/_partials/page/page-header.swig","hash":"9b7a66791d7822c52117fe167612265356512477","modified":1603786096033},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"1c910fc066c06d5fbbe9f2b0c47447539e029af7","modified":1603786096041},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"7f14ef43d9e82bc1efc204c5adf0b1dbfc919a9f","modified":1603786096042},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"7f14ef43d9e82bc1efc204c5adf0b1dbfc919a9f","modified":1603786096041},{"_id":"themes/next/layout/_partials/sidebar/site-overview.swig","hash":"c46849e0af8f8fb78baccd40d2af14df04a074af","modified":1603786096038},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"1c910fc066c06d5fbbe9f2b0c47447539e029af7","modified":1603786096042},{"_id":"themes/next/layout/_scripts/pages/schedule.swig","hash":"077b5d66f6309f2e7dcf08645058ff2e03143e6c","modified":1603786096040},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"4790058691b7d36cf6d2d6b4e93795a7b8d608ad","modified":1603786096044},{"_id":"themes/next/layout/_third-party/analytics/growingio.swig","hash":"5adea065641e8c55994dd2328ddae53215604928","modified":1603786096045},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"2fa2b51d56bfac6a1ea76d651c93b9c20b01c09b","modified":1603786096044},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"1472cabb0181f60a6a0b7fec8899a4d03dfb2040","modified":1603786096045},{"_id":"themes/next/layout/_third-party/chat/chatra.swig","hash":"f910618292c63871ca2e6c6e66c491f344fa7b1f","modified":1603786096046},{"_id":"themes/next/layout/_third-party/chat/tidio.swig","hash":"cba0e6e0fad08568a9e74ba9a5bee5341cfc04c1","modified":1603786096047},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"b14908644225d78c864cd0a9b60c52407de56183","modified":1603786096048},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"f7a9eca599a682479e8ca863db59be7c9c7508c8","modified":1603786096049},{"_id":"themes/next/layout/_third-party/comments/gitalk.swig","hash":"d6ceb70648555338a80ae5724b778c8c58d7060d","modified":1603786096049},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"f39a5bf3ce9ee9adad282501235e0c588e4356ec","modified":1603786096047},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"be0a8eccf1f6dc21154af297fc79555343031277","modified":1603786096050},{"_id":"themes/next/layout/_third-party/comments/disqusjs.swig","hash":"82f5b6822aa5ec958aa987b101ef860494c6cf1f","modified":1603786096048},{"_id":"themes/next/layout/_third-party/math/katex.swig","hash":"4791c977a730f29c846efcf6c9c15131b9400ead","modified":1603786096051},{"_id":"themes/next/layout/_third-party/math/index.swig","hash":"6c5976621efd5db5f7c4c6b4f11bc79d6554885f","modified":1603786096051},{"_id":"themes/next/layout/_third-party/search/algolia-search.swig","hash":"d35a999d67f4c302f76fdf13744ceef3c6506481","modified":1603786096053},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"767b6c714c22588bcd26ba70b0fc19b6810cbacd","modified":1603786096053},{"_id":"themes/next/layout/_third-party/math/mathjax.swig","hash":"ecf751321e799f0fb3bf94d049e535130e2547aa","modified":1603786096051},{"_id":"themes/next/layout/_third-party/search/swiftype.swig","hash":"ba0dbc06b9d244073a1c681ff7a722dcbf920b51","modified":1603786096054},{"_id":"themes/next/layout/_third-party/statistics/cnzz-analytics.swig","hash":"a17ace37876822327a2f9306a472974442c9005d","modified":1603786096055},{"_id":"themes/next/layout/_third-party/statistics/index.swig","hash":"5f6a966c509680dbfa70433f9d658cee59c304d7","modified":1603786096056},{"_id":"themes/next/layout/_third-party/statistics/busuanzi-counter.swig","hash":"4b1986e43d6abce13450d2b41a736dd6a5620a10","modified":1603786096055},{"_id":"themes/next/layout/_third-party/tags/mermaid.swig","hash":"f3c43664a071ff3c0b28bd7e59b5523446829576","modified":1603786096057},{"_id":"themes/next/layout/_third-party/statistics/firestore.swig","hash":"b26ac2bfbe91dd88267f8b96aee6bb222b265b7a","modified":1603786096056},{"_id":"themes/next/layout/_third-party/statistics/lean-analytics.swig","hash":"d56d5af427cdfecc33a0f62ee62c056b4e33d095","modified":1603786096057},{"_id":"themes/next/scripts/events/lib/config.js","hash":"d34c6040b13649714939f59be5175e137de65ede","modified":1603786096062},{"_id":"themes/next/layout/_third-party/tags/pdf.swig","hash":"d30b0e255a8092043bac46441243f943ed6fb09b","modified":1603786096058},{"_id":"themes/next/scripts/events/lib/injects-point.js","hash":"6661c1c91c7cbdefc6a5e6a034b443b8811235a1","modified":1603786096062},{"_id":"themes/next/scripts/events/lib/injects.js","hash":"f233d8d0103ae7f9b861344aa65c1a3c1de8a845","modified":1603786096063},{"_id":"themes/next/scripts/filters/comment/changyan.js","hash":"a54708fd9309b4357c423a3730eb67f395344a5e","modified":1603786096064},{"_id":"themes/next/scripts/filters/comment/common.js","hash":"2486f3e0150c753e5f3af1a3665d074704b8ee2c","modified":1603786096064},{"_id":"themes/next/scripts/filters/comment/default-config.js","hash":"7f2d93af012c1e14b8596fecbfc7febb43d9b7f5","modified":1603786096065},{"_id":"themes/next/scripts/filters/comment/disqus.js","hash":"4c0c99c7e0f00849003dfce02a131104fb671137","modified":1603786096065},{"_id":"themes/next/scripts/filters/comment/disqusjs.js","hash":"7f8b92913d21070b489457fa5ed996d2a55f2c32","modified":1603786096066},{"_id":"themes/next/scripts/filters/comment/gitalk.js","hash":"e51dc3072c1ba0ea3008f09ecae8b46242ec6021","modified":1603786096066},{"_id":"themes/next/scripts/filters/comment/livere.js","hash":"d5fefc31fba4ab0188305b1af1feb61da49fdeb0","modified":1603786096066},{"_id":"themes/next/scripts/filters/comment/valine.js","hash":"6cbd85f9433c06bae22225ccf75ac55e04f2d106","modified":1603786096067},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"62df49459d552bbf73841753da8011a1f5e875c8","modified":1603786096121},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"f4e694e5db81e57442c7e34505a416d818b3044a","modified":1603786096120},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"612ec843372dae709acb17112c1145a53450cc59","modified":1603786096121},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"f70be8e229da7e1715c11dd0e975a2e71e453ac8","modified":1603786096120},{"_id":"themes/next/source/css/_variables/base.styl","hash":"818508748b7a62e02035e87fe58e75b603ed56dc","modified":1603786096122},{"_id":"themes/next/source/js/schemes/muse.js","hash":"1eb9b88103ddcf8827b1a7cbc56471a9c5592d53","modified":1603786096131},{"_id":"themes/next/source/js/schemes/pisces.js","hash":"0ac5ce155bc58c972fe21c4c447f85e6f8755c62","modified":1603786096131},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1603786096137},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1603786096136},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"ca5e70662dcfb261c25191cc5db5084dcf661c76","modified":1603786096078},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"a47725574e1bee3bc3b63b0ff2039cc982b17eff","modified":1603786096078},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"8e7b57a72e757cf95278239641726bb2d5b869d1","modified":1603786096079},{"_id":"themes/next/source/css/_common/components/reading-progress.styl","hash":"2e3bf7baf383c9073ec5e67f157d3cb3823c0957","modified":1603786096089},{"_id":"themes/next/source/css/_common/outline/mobile.styl","hash":"681d33e3bc85bdca407d93b134c089264837378c","modified":1603786096095},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"a1690e035b505d28bdef2b4424c13fc6312ab049","modified":1603786096096},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"0b2c4b78eead410020d7c4ded59c75592a648df8","modified":1603786096101},{"_id":"themes/next/source/css/_common/scaffolding/buttons.styl","hash":"a2e9e00962e43e98ec2614d6d248ef1773bb9b78","modified":1603786096101},{"_id":"themes/next/source/css/_common/scaffolding/comments.styl","hash":"b1f0fab7344a20ed6748b04065b141ad423cf4d9","modified":1603786096101},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"b56367ea676ea8e8783ea89cd4ab150c7da7a060","modified":1603786096104},{"_id":"themes/next/source/css/_common/scaffolding/pagination.styl","hash":"8f58570a1bbc34c4989a47a1b7d42a8030f38b06","modified":1603786096105},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"523fb7b653b87ae37fc91fc8813e4ffad87b0d7e","modified":1603786096105},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"18ce72d90459c9aa66910ac64eae115f2dde3767","modified":1603786096105},{"_id":"themes/next/source/css/_common/scaffolding/toggles.styl","hash":"179e33b8ac7f4d8a8e76736a7e4f965fe9ab8b42","modified":1603786096109},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"7785bd756e0c4acede3a47fec1ed7b55988385a5","modified":1603786096110},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"f6516d0f7d89dc7b6c6e143a5af54b926f585d82","modified":1603786096111},{"_id":"themes/next/source/css/_schemes/Mist/_layout.styl","hash":"bb7ace23345364eb14983e860a7172e1683a4c94","modified":1603786096111},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"7104b9cef90ca3b140d7a7afcf15540a250218fc","modified":1603786096112},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"a717969829fa6ef88225095737df3f8ee86c286b","modified":1603786096113},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"4d1c17345d2d39ef7698f7acf82dfc0f59308c34","modified":1603786096114},{"_id":"themes/next/source/css/_schemes/Muse/_header.styl","hash":"f0131db6275ceaecae7e1a6a3798b8f89f6c850d","modified":1603786096113},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expand.styl","hash":"6136da4bbb7e70cec99f5c7ae8c7e74f5e7c261a","modified":1603786096112},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"93db5dafe9294542a6b5f647643cb9deaced8e06","modified":1603786096114},{"_id":"themes/next/source/css/_schemes/Muse/_sub-menu.styl","hash":"c48ccd8d6651fe1a01faff8f01179456d39ba9b1","modified":1603786096115},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1603786096116},{"_id":"themes/next/source/css/_schemes/Muse/_sidebar.styl","hash":"2b2e7b5cea7783c9c8bb92655e26a67c266886f0","modified":1603786096115},{"_id":"themes/next/source/css/_schemes/Pisces/_header.styl","hash":"e282df938bd029f391c466168d0e68389978f120","modified":1603786096116},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"70a4324b70501132855b5e59029acfc5d3da1ebd","modified":1603786096117},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"85da2f3006f4bef9a2199416ecfab4d288f848c4","modified":1603786096117},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"44f47c88c06d89d06f220f102649057118715828","modified":1603786096117},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"e740deadcfc4f29c5cb01e40f9df6277262ba4e3","modified":1603786096118},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1603786096118},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"260bb01acd44d88dcb7f501a238ab968f86bef9e","modified":1603786096135},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"509988477da79c146cb93fb728405f18e923c2de","modified":1603786096134},{"_id":"themes/next/source/lib/font-awesome/css/all.min.css","hash":"0038dc97c79451578b7bd48af60ba62282b4082b","modified":1603786096133},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"fafc96c86926b22afba8bb9418c05e6afbc05a57","modified":1603786096080},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"2bd0eb1512415325653b26d62a4463e6de83c5ac","modified":1603786096081},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"7504dbc5c70262b048143b2c37d2b5aa2809afa2","modified":1603786096081},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"d21d4ac1982c13d02f125a67c065412085a92ff2","modified":1603786096082},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f49ca072b5a800f735e8f01fc3518f885951dd8e","modified":1603786096083},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"902569a9dea90548bec21a823dd3efd94ff7c133","modified":1603786096084},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"e771dcb0b4673e063c0f3e2d73e7336ac05bcd57","modified":1603786096082},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"72d495a88f7d6515af425c12cbc67308a57d88ea","modified":1603786096085},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"e75693f33dbc92afc55489438267869ae2f3db54","modified":1603786096083},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"6a97bcfa635d637dc59005be3b931109e0d1ead5","modified":1603786096086},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"f5c2788a78790aca1a2f37f7149d6058afb539e0","modified":1603786096087},{"_id":"themes/next/source/css/_common/components/post/post-followme.styl","hash":"1e4190c10c9e0c9ce92653b0dbcec21754b0b69d","modified":1603786096085},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"99e12c9ce3d14d4837e3d3f12fc867ba9c565317","modified":1603786096087},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"5b5649b9749e3fd8b63aef22ceeece0a6e1df605","modified":1603786096088},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"ded41fd9d20a5e8db66aaff7cc50f105f5ef2952","modified":1603786096084},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"8a7fc03a568b95be8d3337195e38bc7ec5ba2b23","modified":1603786096090},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"d114b2a531129e739a27ba6271cfe6857aa9a865","modified":1603786096087},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"e2992846b39bf3857b5104675af02ba73e72eed5","modified":1603786096090},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"b49e9fbd3c182b8fc066b8c2caf248e3eb748619","modified":1603786096090},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"9a878d0119785a2316f42aebcceaa05a120b9a7a","modified":1603786096091},{"_id":"themes/next/source/css/_common/components/post/post-header.styl","hash":"65cb6edb69e94e70e3291e9132408361148d41d5","modified":1603786096086},{"_id":"themes/next/source/css/_common/outline/header/bookmark.styl","hash":"e2d606f1ac343e9be4f15dbbaf3464bc4df8bf81","modified":1603786096093},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"a760ee83ba6216871a9f14c5e56dc9bd0d9e2103","modified":1603786096088},{"_id":"themes/next/source/css/_common/outline/header/header.styl","hash":"a793cfff86ad4af818faef04c18013077873f8f0","modified":1603786096093},{"_id":"themes/next/source/css/_common/outline/header/headerband.styl","hash":"0caf32492692ba8e854da43697a2ec8a41612194","modified":1603786096094},{"_id":"themes/next/source/css/_common/components/third-party/search.styl","hash":"9f0b93d109c9aec79450c8a0cf4a4eab717d674d","modified":1603786096091},{"_id":"themes/next/source/css/_common/outline/footer/footer.styl","hash":"454a4aebfabb4469b92a8cbb49f46c49ac9bf165","modified":1603786096092},{"_id":"themes/next/source/css/_common/outline/header/site-nav.styl","hash":"b2fc519828fe89a1f8f03ff7b809ad68cd46f3d7","modified":1603786096095},{"_id":"themes/next/source/css/_common/outline/header/github-banner.styl","hash":"e7a9fdb6478b8674b1cdf94de4f8052843fb71d9","modified":1603786096093},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"44487d9ab290dc97871fa8dd4487016deb56e123","modified":1603786096097},{"_id":"themes/next/source/css/_common/outline/header/menu.styl","hash":"5f432a6ed9ca80a413c68b00e93d4a411abf280a","modified":1603786096094},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"9b479c2f9a9bfed77885e5093b8245cc5d768ec7","modified":1603786096098},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"1f0e7fbe80956f47087c2458ea880acf7a83078b","modified":1603786096098},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"2cb1876e9e0c9ac32160888af27b1178dbcb0616","modified":1603786096096},{"_id":"themes/next/source/css/_common/outline/header/site-meta.styl","hash":"45a239edca44acecf971d99b04f30a1aafbf6906","modified":1603786096095},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"b3220db827e1adbca7880c2bb23e78fa7cbe95cb","modified":1603786096099},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"fa0222197b5eee47e18ac864cdc6eac75678b8fe","modified":1603786096097},{"_id":"themes/next/source/css/_common/outline/sidebar/site-state.styl","hash":"2a47f8a6bb589c2fb635e6c1e4a2563c7f63c407","modified":1603786096100},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"a960a2dd587b15d3b3fe1b59525d6fa971c6a6ec","modified":1603786096098},{"_id":"themes/next/source/css/_common/scaffolding/highlight/diff.styl","hash":"d3f73688bb7423e3ab0de1efdf6db46db5e34f80","modified":1603786096102},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"a05a4031e799bc864a4536f9ef61fe643cd421af","modified":1603786096099},{"_id":"themes/next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"f71a3e86c05ea668b008cf05a81f67d92b6d65e4","modified":1603786096102},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar.styl","hash":"a9cd93c36bae5af9223e7804963096274e8a4f03","modified":1603786096100},{"_id":"themes/next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"1d2778ca5aeeeafaa690dc2766b01b352ab76a02","modified":1603786096106},{"_id":"themes/next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"709d10f763e357e1472d6471f8be384ec9e2d983","modified":1603786096106},{"_id":"themes/next/source/css/_common/scaffolding/highlight/highlight.styl","hash":"35c871a809afa8306c8cde13651010e282548bc6","modified":1603786096103},{"_id":"themes/next/source/css/_common/scaffolding/tags/label.styl","hash":"d7fce4b51b5f4b7c31d93a9edb6c6ce740aa0d6b","modified":1603786096107},{"_id":"themes/next/source/css/_common/scaffolding/tags/pdf.styl","hash":"b49c64f8e9a6ca1c45c0ba98febf1974fdd03616","modified":1603786096108},{"_id":"themes/next/source/css/_common/scaffolding/tags/tags.styl","hash":"9e4c0653cfd3cc6908fa0d97581bcf80861fb1e7","modified":1603786096108},{"_id":"themes/next/source/css/_common/scaffolding/tags/note.styl","hash":"e4d9a77ffe98e851c1202676940097ba28253313","modified":1603786096107},{"_id":"themes/next/source/css/_common/scaffolding/highlight/theme.styl","hash":"3b3acc5caa0b95a2598bef4eeacb21bab21bea56","modified":1603786096104},{"_id":"themes/next/source/css/_common/scaffolding/tags/tabs.styl","hash":"f23670f1d8e749f3e83766d446790d8fd9620278","modified":1603786096108},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"75a88815c47a249eadb5f0edc1675957f860cca7","modified":1603786096135}],"Category":[{"name":"算法日常练习","_id":"ckio9dwcr0004k8nekikdk64e"},{"name":"设计模式","_id":"ckio9dwej0031k8neai0ashr5"},{"name":"读书笔记","_id":"ckio9dwer003jk8nezo1c0l2o"},{"name":"流计算","_id":"ckio9dwey003yk8nerfpo5iye"},{"name":"微服务改造","_id":"ckio9dwff004sk8ney8iy7lww"},{"name":"Java基础","_id":"ckio9dwfn005ak8nelw6z1gj9"}],"Data":[],"Page":[{"title":"分类","date":"2019-06-25T13:30:46.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2019-06-25 21:30:46\ntype: \"categories\"\ncomments: false\n---\n","updated":"2020-10-27T08:08:15.943Z","path":"categories/index.html","layout":"page","_id":"ckio9dwbe0000k8nelnf69fdh","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"关于我","date":"2020-06-07T14:01:00.000Z","_content":"\n##### Title\n\n软件工程师\n\n##### Email\n\nlxmheida@gmail.com\n","source":"about/index.md","raw":"---\ntitle: 关于我\ndate: 2020-06-07 22:01:00\n---\n\n##### Title\n\n软件工程师\n\n##### Email\n\nlxmheida@gmail.com\n","updated":"2020-10-27T08:08:15.943Z","path":"about/index.html","comments":1,"layout":"page","_id":"ckio9dwbh0001k8newv92pxbt","content":"<h5 id=\"Title\"><a href=\"#Title\" class=\"headerlink\" title=\"Title\"></a>Title</h5><p>软件工程师</p>\n<h5 id=\"Email\"><a href=\"#Email\" class=\"headerlink\" title=\"Email\"></a>Email</h5><p><a href=\"mailto:lxmheida@gmail.com\" target=\"_blank\" rel=\"noopener\">lxmheida@gmail.com</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h5 id=\"Title\"><a href=\"#Title\" class=\"headerlink\" title=\"Title\"></a>Title</h5><p>软件工程师</p>\n<h5 id=\"Email\"><a href=\"#Email\" class=\"headerlink\" title=\"Email\"></a>Email</h5><p><a href=\"mailto:lxmheida@gmail.com\" target=\"_blank\" rel=\"noopener\">lxmheida@gmail.com</a></p>\n"}],"Post":[{"title":"LeetCode 122. 买卖股票的最佳时机 ii","date":"2020-06-25T07:43:54.000Z","_content":"\n### 题目\n\n[LeetCode 122. Best Time to Buy and Sell Stock II](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/)\n\n### 思路\n\n1.  要求尽可能多的完成交易\n2. 要求不能同时多笔交易\n3. 所以判断每笔交易能不能赚钱(即 arr[i + 1] - arr[i] > 0), 满足条件则发生交易即可\n\n<!--more-->\n\n### 代码实现\n\n```java\nclass Solution {\n    public int maxProfit(int[] prices) {\n        //validate param\n        if(prices == null || prices.length <= 1) {\n            return 0;\n        }\n        \n        int totalProfit = 0;\n        int profit = 0;\n        //calculate profit between every day, if profit > 0, means you can complete one transaction.\n        for (int i = 0; i < prices.length - 1; i++) {\n            profit = prices[i + 1] - prices[i];\n            if (profit > 0) {\n                totalProfit += profit;\n            }\n        }\n        return totalProfit;\n    }\n}\n```\n","source":"_posts/algorithm/LeetCode 122. 买卖股票的最佳时机 ii.md","raw":"---\ntitle: LeetCode 122. 买卖股票的最佳时机 ii\ndate: 2020-06-25 15:43:54\ncategories: 算法日常练习\ntags:\n- 数据结构与算法\n- 数组\n---\n\n### 题目\n\n[LeetCode 122. Best Time to Buy and Sell Stock II](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/)\n\n### 思路\n\n1.  要求尽可能多的完成交易\n2. 要求不能同时多笔交易\n3. 所以判断每笔交易能不能赚钱(即 arr[i + 1] - arr[i] > 0), 满足条件则发生交易即可\n\n<!--more-->\n\n### 代码实现\n\n```java\nclass Solution {\n    public int maxProfit(int[] prices) {\n        //validate param\n        if(prices == null || prices.length <= 1) {\n            return 0;\n        }\n        \n        int totalProfit = 0;\n        int profit = 0;\n        //calculate profit between every day, if profit > 0, means you can complete one transaction.\n        for (int i = 0; i < prices.length - 1; i++) {\n            profit = prices[i + 1] - prices[i];\n            if (profit > 0) {\n                totalProfit += profit;\n            }\n        }\n        return totalProfit;\n    }\n}\n```\n","slug":"algorithm/LeetCode 122. 买卖股票的最佳时机 ii","published":1,"updated":"2020-10-27T08:08:15.919Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckio9dwcl0002k8neclr42h7o","content":"<h3 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h3><p><a href=\"https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/\" target=\"_blank\" rel=\"noopener\">LeetCode 122. Best Time to Buy and Sell Stock II</a></p>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><ol>\n<li>要求尽可能多的完成交易</li>\n<li>要求不能同时多笔交易</li>\n<li>所以判断每笔交易能不能赚钱(即 arr[i + 1] - arr[i] &gt; 0), 满足条件则发生交易即可</li>\n</ol>\n<a id=\"more\"></a>\n\n<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">maxProfit</span><span class=\"params\">(<span class=\"keyword\">int</span>[] prices)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//validate param</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(prices == <span class=\"keyword\">null</span> || prices.length &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> totalProfit = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> profit = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">//calculate profit between every day, if profit &gt; 0, means you can complete one transaction.</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; prices.length - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">            profit = prices[i + <span class=\"number\">1</span>] - prices[i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (profit &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                totalProfit += profit;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> totalProfit;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<h3 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h3><p><a href=\"https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/\" target=\"_blank\" rel=\"noopener\">LeetCode 122. Best Time to Buy and Sell Stock II</a></p>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><ol>\n<li>要求尽可能多的完成交易</li>\n<li>要求不能同时多笔交易</li>\n<li>所以判断每笔交易能不能赚钱(即 arr[i + 1] - arr[i] &gt; 0), 满足条件则发生交易即可</li>\n</ol>","more":"<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">maxProfit</span><span class=\"params\">(<span class=\"keyword\">int</span>[] prices)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//validate param</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(prices == <span class=\"keyword\">null</span> || prices.length &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> totalProfit = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> profit = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">//calculate profit between every day, if profit &gt; 0, means you can complete one transaction.</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; prices.length - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">            profit = prices[i + <span class=\"number\">1</span>] - prices[i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (profit &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                totalProfit += profit;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> totalProfit;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode 14. 最长公共前缀","date":"2020-06-24T13:34:28.000Z","_content":"\n### 题目\n\n[LeetCode 14. Longest Common Prefix](https://leetcode.com/problems/longest-common-prefix/)\n\n### 思路\n\n1. index从0开始, 每个字符串取第index个元素, 判断是否相等, 相等则index递增继续计算, 直到不相等为止\n2. 个人觉得问题比较简单, 但是各种边界条件必须考虑到位\n   * 数组为空, 数组只有一个字符串, 数组包含\"\"\n   * 因为是求前缀, 当index == 0 的元素不相等, 代表不存在最长公共前缀, 可以直接返回 \"\"\n   * 注意 str.charAt(index) 越界问题\n<!--more-->\n### 代码实现\n\n```java\nclass Solution {\n    public String longestCommonPrefix(String[] strs) {\n        // validate array is null\n        if (strs == null || strs.length == 0) {\n            return \"\";\n        }\n        // if array.length = 1, return array itself\n        if (strs.length == 1) {\n            return strs[0];\n        }\n        int minLen = getStrsMinlength(strs);\n        // if array.contains(\"\"), return \"\"\n        if(minLen == 0) {\n            return \"\";\n        }\n        int index = 0;\n        StringBuilder sb = new StringBuilder();\n        // foreach char in array[0]\n        for (char c : strs[0].toCharArray()) {\n            boolean flag = true;\n            for(String str : strs) {\n                if (c != str.charAt(index)) {\n                    flag = false;\n                }\n            }\n            // if first is not equal, direct return \"\"\n            if(index == 0 && !flag) {\n                return \"\";\n            }\n            if(flag) {\n                sb.append(c);\n            }\n            if (++index == minLen) {\n                break;\n            }\n        }\n        return sb.toString();\n    }\n    \n    //return the min length of string array\n    public int getStrsMinlength(String[] strs) {\n        int min = strs[0].length();\n        for(String str : strs) {\n            min = Math.min(str.length(), min);\n        }\n        return min;\n    }\n}\n```\n","source":"_posts/algorithm/LeetCode 14. 最长公共前缀.md","raw":"---\ntitle: LeetCode 14. 最长公共前缀\ndate: 2020-06-24 21:34:28\ncategories: 算法日常练习\ntags:\n- 数据结构与算法\n---\n\n### 题目\n\n[LeetCode 14. Longest Common Prefix](https://leetcode.com/problems/longest-common-prefix/)\n\n### 思路\n\n1. index从0开始, 每个字符串取第index个元素, 判断是否相等, 相等则index递增继续计算, 直到不相等为止\n2. 个人觉得问题比较简单, 但是各种边界条件必须考虑到位\n   * 数组为空, 数组只有一个字符串, 数组包含\"\"\n   * 因为是求前缀, 当index == 0 的元素不相等, 代表不存在最长公共前缀, 可以直接返回 \"\"\n   * 注意 str.charAt(index) 越界问题\n<!--more-->\n### 代码实现\n\n```java\nclass Solution {\n    public String longestCommonPrefix(String[] strs) {\n        // validate array is null\n        if (strs == null || strs.length == 0) {\n            return \"\";\n        }\n        // if array.length = 1, return array itself\n        if (strs.length == 1) {\n            return strs[0];\n        }\n        int minLen = getStrsMinlength(strs);\n        // if array.contains(\"\"), return \"\"\n        if(minLen == 0) {\n            return \"\";\n        }\n        int index = 0;\n        StringBuilder sb = new StringBuilder();\n        // foreach char in array[0]\n        for (char c : strs[0].toCharArray()) {\n            boolean flag = true;\n            for(String str : strs) {\n                if (c != str.charAt(index)) {\n                    flag = false;\n                }\n            }\n            // if first is not equal, direct return \"\"\n            if(index == 0 && !flag) {\n                return \"\";\n            }\n            if(flag) {\n                sb.append(c);\n            }\n            if (++index == minLen) {\n                break;\n            }\n        }\n        return sb.toString();\n    }\n    \n    //return the min length of string array\n    public int getStrsMinlength(String[] strs) {\n        int min = strs[0].length();\n        for(String str : strs) {\n            min = Math.min(str.length(), min);\n        }\n        return min;\n    }\n}\n```\n","slug":"algorithm/LeetCode 14. 最长公共前缀","published":1,"updated":"2020-10-27T08:08:15.920Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckio9dwcp0003k8nem7m68ud8","content":"<h3 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h3><p><a href=\"https://leetcode.com/problems/longest-common-prefix/\" target=\"_blank\" rel=\"noopener\">LeetCode 14. Longest Common Prefix</a></p>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><ol>\n<li>index从0开始, 每个字符串取第index个元素, 判断是否相等, 相等则index递增继续计算, 直到不相等为止</li>\n<li>个人觉得问题比较简单, 但是各种边界条件必须考虑到位<ul>\n<li>数组为空, 数组只有一个字符串, 数组包含””</li>\n<li>因为是求前缀, 当index == 0 的元素不相等, 代表不存在最长公共前缀, 可以直接返回 “”</li>\n<li>注意 str.charAt(index) 越界问题<a id=\"more\"></a>\n<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3></li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">longestCommonPrefix</span><span class=\"params\">(String[] strs)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// validate array is null</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (strs == <span class=\"keyword\">null</span> || strs.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// if array.length = 1, return array itself</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (strs.length == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> strs[<span class=\"number\">0</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> minLen = getStrsMinlength(strs);</span><br><span class=\"line\">        <span class=\"comment\">// if array.contains(\"\"), return \"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(minLen == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> index = <span class=\"number\">0</span>;</span><br><span class=\"line\">        StringBuilder sb = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">        <span class=\"comment\">// foreach char in array[0]</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">char</span> c : strs[<span class=\"number\">0</span>].toCharArray()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> flag = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(String str : strs) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (c != str.charAt(index)) &#123;</span><br><span class=\"line\">                    flag = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// if first is not equal, direct return \"\"</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(index == <span class=\"number\">0</span> &amp;&amp; !flag) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(flag) &#123;</span><br><span class=\"line\">                sb.append(c);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (++index == minLen) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sb.toString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//return the min length of string array</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getStrsMinlength</span><span class=\"params\">(String[] strs)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> min = strs[<span class=\"number\">0</span>].length();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(String str : strs) &#123;</span><br><span class=\"line\">            min = Math.min(str.length(), min);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> min;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<h3 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h3><p><a href=\"https://leetcode.com/problems/longest-common-prefix/\" target=\"_blank\" rel=\"noopener\">LeetCode 14. Longest Common Prefix</a></p>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><ol>\n<li>index从0开始, 每个字符串取第index个元素, 判断是否相等, 相等则index递增继续计算, 直到不相等为止</li>\n<li>个人觉得问题比较简单, 但是各种边界条件必须考虑到位<ul>\n<li>数组为空, 数组只有一个字符串, 数组包含””</li>\n<li>因为是求前缀, 当index == 0 的元素不相等, 代表不存在最长公共前缀, 可以直接返回 “”</li>\n<li>注意 str.charAt(index) 越界问题","more":"<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3></li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">longestCommonPrefix</span><span class=\"params\">(String[] strs)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// validate array is null</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (strs == <span class=\"keyword\">null</span> || strs.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// if array.length = 1, return array itself</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (strs.length == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> strs[<span class=\"number\">0</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> minLen = getStrsMinlength(strs);</span><br><span class=\"line\">        <span class=\"comment\">// if array.contains(\"\"), return \"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(minLen == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> index = <span class=\"number\">0</span>;</span><br><span class=\"line\">        StringBuilder sb = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">        <span class=\"comment\">// foreach char in array[0]</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">char</span> c : strs[<span class=\"number\">0</span>].toCharArray()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> flag = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(String str : strs) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (c != str.charAt(index)) &#123;</span><br><span class=\"line\">                    flag = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// if first is not equal, direct return \"\"</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(index == <span class=\"number\">0</span> &amp;&amp; !flag) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(flag) &#123;</span><br><span class=\"line\">                sb.append(c);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (++index == minLen) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sb.toString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//return the min length of string array</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getStrsMinlength</span><span class=\"params\">(String[] strs)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> min = strs[<span class=\"number\">0</span>].length();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(String str : strs) &#123;</span><br><span class=\"line\">            min = Math.min(str.length(), min);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> min;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode 15. 三数之和","date":"2020-07-01T07:31:59.000Z","_content":"\n### 题目\n\n[LeetCode 15. 3Sum](https://leetcode.com/problems/3sum/submissions/)\n\n### 思路\n\n1. 采用固定一个数, 双指针寻找另外两个数\n2. 排序后开始处理, 注意几个情况:\n   1. nums[i] > 0, 代表后面的数都会大于0, 没必要计算了\n   2. 跳过固定数值重复的情况\n   3. 跳过left指针、right指针重复的情况\n<!--more-->\n### 代码实现\n\n```java\nclass Solution {\n    public List<List<Integer>> threeSum(int[] nums) {\n        List<List<Integer>> list = new ArrayList<>();\n        if(nums == null || nums.length < 3) {\n            return list;\n        }\n\n        Arrays.sort(nums);\n        int sum = 0;\n        for (int i = 0; i < nums.length - 2; i++) {\n            int l = i + 1;\n            int r = nums.length - 1;\n            if (nums[i] > 0) {\n                break;\n            }\n            \n            if (i == 0 || nums[i] != nums[i - 1]){\n                while (l < r) {\n                    sum = nums[i] + nums[l] + nums[r];\n                    if (sum == 0) {\n                        list.add(Arrays.asList(nums[i], nums[l], nums[r]));\n                        while (l < r && nums[l] == nums[l + 1]) {\n                            l++;\n                        }\n                        while (l < r && nums[r] == nums[r - 1]) {\n                            r--;\n                        }\n                        l++;\n                        r--;\n                    }else if (sum < 0) {\n                        l++;\n                    }else{\n                        r--;\n                    }\n                }\n            }\n        }        \n        return list;\n    }\n}\n```","source":"_posts/algorithm/LeetCode 15. 三数之和.md","raw":"---\ntitle: LeetCode 15. 三数之和\ndate: 2020-07-01 15:31:59\ncategories: 算法日常练习\ntags:\n- 数据结构与算法\n---\n\n### 题目\n\n[LeetCode 15. 3Sum](https://leetcode.com/problems/3sum/submissions/)\n\n### 思路\n\n1. 采用固定一个数, 双指针寻找另外两个数\n2. 排序后开始处理, 注意几个情况:\n   1. nums[i] > 0, 代表后面的数都会大于0, 没必要计算了\n   2. 跳过固定数值重复的情况\n   3. 跳过left指针、right指针重复的情况\n<!--more-->\n### 代码实现\n\n```java\nclass Solution {\n    public List<List<Integer>> threeSum(int[] nums) {\n        List<List<Integer>> list = new ArrayList<>();\n        if(nums == null || nums.length < 3) {\n            return list;\n        }\n\n        Arrays.sort(nums);\n        int sum = 0;\n        for (int i = 0; i < nums.length - 2; i++) {\n            int l = i + 1;\n            int r = nums.length - 1;\n            if (nums[i] > 0) {\n                break;\n            }\n            \n            if (i == 0 || nums[i] != nums[i - 1]){\n                while (l < r) {\n                    sum = nums[i] + nums[l] + nums[r];\n                    if (sum == 0) {\n                        list.add(Arrays.asList(nums[i], nums[l], nums[r]));\n                        while (l < r && nums[l] == nums[l + 1]) {\n                            l++;\n                        }\n                        while (l < r && nums[r] == nums[r - 1]) {\n                            r--;\n                        }\n                        l++;\n                        r--;\n                    }else if (sum < 0) {\n                        l++;\n                    }else{\n                        r--;\n                    }\n                }\n            }\n        }        \n        return list;\n    }\n}\n```","slug":"algorithm/LeetCode 15. 三数之和","published":1,"updated":"2020-10-27T08:08:15.921Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckio9dwct0006k8ne6dk4mu55","content":"<h3 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h3><p><a href=\"https://leetcode.com/problems/3sum/submissions/\" target=\"_blank\" rel=\"noopener\">LeetCode 15. 3Sum</a></p>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><ol>\n<li>采用固定一个数, 双指针寻找另外两个数</li>\n<li>排序后开始处理, 注意几个情况:<ol>\n<li>nums[i] &gt; 0, 代表后面的数都会大于0, 没必要计算了</li>\n<li>跳过固定数值重复的情况</li>\n<li>跳过left指针、right指针重复的情况<a id=\"more\"></a>\n<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3></li>\n</ol>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class=\"keyword\">int</span>[] nums) &#123;</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums == <span class=\"keyword\">null</span> || nums.length &lt; <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Arrays.sort(nums);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length - <span class=\"number\">2</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> l = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> r = nums.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[i] &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i == <span class=\"number\">0</span> || nums[i] != nums[i - <span class=\"number\">1</span>])&#123;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (l &lt; r) &#123;</span><br><span class=\"line\">                    sum = nums[i] + nums[l] + nums[r];</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (sum == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        list.add(Arrays.asList(nums[i], nums[l], nums[r]));</span><br><span class=\"line\">                        <span class=\"keyword\">while</span> (l &lt; r &amp;&amp; nums[l] == nums[l + <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                            l++;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">while</span> (l &lt; r &amp;&amp; nums[r] == nums[r - <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                            r--;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        l++;</span><br><span class=\"line\">                        r--;</span><br><span class=\"line\">                    &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (sum &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        l++;</span><br><span class=\"line\">                    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                        r--;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h3 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h3><p><a href=\"https://leetcode.com/problems/3sum/submissions/\" target=\"_blank\" rel=\"noopener\">LeetCode 15. 3Sum</a></p>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><ol>\n<li>采用固定一个数, 双指针寻找另外两个数</li>\n<li>排序后开始处理, 注意几个情况:<ol>\n<li>nums[i] &gt; 0, 代表后面的数都会大于0, 没必要计算了</li>\n<li>跳过固定数值重复的情况</li>\n<li>跳过left指针、right指针重复的情况","more":"<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3></li>\n</ol>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class=\"keyword\">int</span>[] nums) &#123;</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums == <span class=\"keyword\">null</span> || nums.length &lt; <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Arrays.sort(nums);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length - <span class=\"number\">2</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> l = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> r = nums.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[i] &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i == <span class=\"number\">0</span> || nums[i] != nums[i - <span class=\"number\">1</span>])&#123;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (l &lt; r) &#123;</span><br><span class=\"line\">                    sum = nums[i] + nums[l] + nums[r];</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (sum == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        list.add(Arrays.asList(nums[i], nums[l], nums[r]));</span><br><span class=\"line\">                        <span class=\"keyword\">while</span> (l &lt; r &amp;&amp; nums[l] == nums[l + <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                            l++;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">while</span> (l &lt; r &amp;&amp; nums[r] == nums[r - <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                            r--;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        l++;</span><br><span class=\"line\">                        r--;</span><br><span class=\"line\">                    &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (sum &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        l++;</span><br><span class=\"line\">                    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                        r--;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode 19. Remove Nth Node From End of List","date":"2020-07-03T14:30:42.000Z","_content":"### 题目\n\n[LeetCode 19. Remove Nth Node From End of List](https://leetcode.com/problems/remove-nth-node-from-end-of-list/)\n\n### 思路\n\n思路一:\n\n1. 单链表, 无法从尾结点往前遍历. 那么可以将倒数第N个结点转为第`L-N+1`个正数节点\n2. 长度L可以提前遍历一次来求值\n3. 移除第`L - N + 1`个节点\n\n思路二:\n\n1. 利用双指针\n2. 先让两个指针相隔`N - 1`的位置\n3. 然后双指针同步后移\n4. 当第二个指针到了尾部, 第一个指针恰好在倒数第N个节点的前驱位置.\n<!--more-->\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        // return removeByTwoPass(head, n);\n        return removeByTwoPointer(head, n);\n    }\n    \n    //Method2: two pointer solution\n    private ListNode removeByTwoPointer(ListNode head, int n) {\n        ListNode support = new ListNode(0);\n        support.next = head;\n        \n        //防止first.next.next删除节点时空指针错误\n        ListNode first = support;\n        ListNode second = support;\n        int i = 0;\n        while (i < n) {\n            second = second.next;\n            i++;\n        }\n        while (second != null && second.next != null) {\n            second = second.next;\n            first = first.next;\n        }\n        first.next = first.next.next;\n        return support.next;\n    }\n    \n    //Method1: get length, and remove (length -n + 1)th node\n    private ListNode removeByTwoPass(ListNode head, int n) {\n        ListNode support = new ListNode(0);\n        support.next = head;\n        int length = 1;\n        ListNode iter = head;\n        while(iter.next != null) {\n            iter = iter.next;\n            length++;\n        }\n        length -= n;\n        //在头节点前加了一个哨兵节点\n        iter = support;\n        while(length > 0) {\n            length--;\n            iter = iter.next;\n        }\n        iter.next = iter.next.next;\n        return support.next;\n    }\n}\n```\n","source":"_posts/algorithm/LeetCode 19. Remove Nth Node From End of List.md","raw":"---\ntitle: LeetCode 19. Remove Nth Node From End of List\ndate: 2020-07-03 22:30:42\ncategories: 算法日常练习\ntags:\n- 数据结构与算法\n- 链表\n---\n### 题目\n\n[LeetCode 19. Remove Nth Node From End of List](https://leetcode.com/problems/remove-nth-node-from-end-of-list/)\n\n### 思路\n\n思路一:\n\n1. 单链表, 无法从尾结点往前遍历. 那么可以将倒数第N个结点转为第`L-N+1`个正数节点\n2. 长度L可以提前遍历一次来求值\n3. 移除第`L - N + 1`个节点\n\n思路二:\n\n1. 利用双指针\n2. 先让两个指针相隔`N - 1`的位置\n3. 然后双指针同步后移\n4. 当第二个指针到了尾部, 第一个指针恰好在倒数第N个节点的前驱位置.\n<!--more-->\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        // return removeByTwoPass(head, n);\n        return removeByTwoPointer(head, n);\n    }\n    \n    //Method2: two pointer solution\n    private ListNode removeByTwoPointer(ListNode head, int n) {\n        ListNode support = new ListNode(0);\n        support.next = head;\n        \n        //防止first.next.next删除节点时空指针错误\n        ListNode first = support;\n        ListNode second = support;\n        int i = 0;\n        while (i < n) {\n            second = second.next;\n            i++;\n        }\n        while (second != null && second.next != null) {\n            second = second.next;\n            first = first.next;\n        }\n        first.next = first.next.next;\n        return support.next;\n    }\n    \n    //Method1: get length, and remove (length -n + 1)th node\n    private ListNode removeByTwoPass(ListNode head, int n) {\n        ListNode support = new ListNode(0);\n        support.next = head;\n        int length = 1;\n        ListNode iter = head;\n        while(iter.next != null) {\n            iter = iter.next;\n            length++;\n        }\n        length -= n;\n        //在头节点前加了一个哨兵节点\n        iter = support;\n        while(length > 0) {\n            length--;\n            iter = iter.next;\n        }\n        iter.next = iter.next.next;\n        return support.next;\n    }\n}\n```\n","slug":"algorithm/LeetCode 19. Remove Nth Node From End of List","published":1,"updated":"2020-10-27T08:08:15.921Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckio9dwcv0007k8nexoc1pw12","content":"<h3 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h3><p><a href=\"https://leetcode.com/problems/remove-nth-node-from-end-of-list/\" target=\"_blank\" rel=\"noopener\">LeetCode 19. Remove Nth Node From End of List</a></p>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>思路一:</p>\n<ol>\n<li>单链表, 无法从尾结点往前遍历. 那么可以将倒数第N个结点转为第<code>L-N+1</code>个正数节点</li>\n<li>长度L可以提前遍历一次来求值</li>\n<li>移除第<code>L - N + 1</code>个节点</li>\n</ol>\n<p>思路二:</p>\n<ol>\n<li>利用双指针</li>\n<li>先让两个指针相隔<code>N - 1</code>的位置</li>\n<li>然后双指针同步后移</li>\n<li>当第二个指针到了尾部, 第一个指针恰好在倒数第N个节点的前驱位置.<a id=\"more\"></a>\n\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode() &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">removeNthFromEnd</span><span class=\"params\">(ListNode head, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// return removeByTwoPass(head, n);</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> removeByTwoPointer(head, n);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//Method2: two pointer solution</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> ListNode <span class=\"title\">removeByTwoPointer</span><span class=\"params\">(ListNode head, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        ListNode support = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">0</span>);</span><br><span class=\"line\">        support.next = head;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//防止first.next.next删除节点时空指针错误</span></span><br><span class=\"line\">        ListNode first = support;</span><br><span class=\"line\">        ListNode second = support;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i &lt; n) &#123;</span><br><span class=\"line\">            second = second.next;</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (second != <span class=\"keyword\">null</span> &amp;&amp; second.next != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            second = second.next;</span><br><span class=\"line\">            first = first.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        first.next = first.next.next;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> support.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//Method1: get length, and remove (length -n + 1)th node</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> ListNode <span class=\"title\">removeByTwoPass</span><span class=\"params\">(ListNode head, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        ListNode support = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">0</span>);</span><br><span class=\"line\">        support.next = head;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> length = <span class=\"number\">1</span>;</span><br><span class=\"line\">        ListNode iter = head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(iter.next != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            iter = iter.next;</span><br><span class=\"line\">            length++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        length -= n;</span><br><span class=\"line\">        <span class=\"comment\">//在头节点前加了一个哨兵节点</span></span><br><span class=\"line\">        iter = support;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            length--;</span><br><span class=\"line\">            iter = iter.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        iter.next = iter.next.next;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> support.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<h3 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h3><p><a href=\"https://leetcode.com/problems/remove-nth-node-from-end-of-list/\" target=\"_blank\" rel=\"noopener\">LeetCode 19. Remove Nth Node From End of List</a></p>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>思路一:</p>\n<ol>\n<li>单链表, 无法从尾结点往前遍历. 那么可以将倒数第N个结点转为第<code>L-N+1</code>个正数节点</li>\n<li>长度L可以提前遍历一次来求值</li>\n<li>移除第<code>L - N + 1</code>个节点</li>\n</ol>\n<p>思路二:</p>\n<ol>\n<li>利用双指针</li>\n<li>先让两个指针相隔<code>N - 1</code>的位置</li>\n<li>然后双指针同步后移</li>\n<li>当第二个指针到了尾部, 第一个指针恰好在倒数第N个节点的前驱位置.","more":"</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode() &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">removeNthFromEnd</span><span class=\"params\">(ListNode head, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// return removeByTwoPass(head, n);</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> removeByTwoPointer(head, n);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//Method2: two pointer solution</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> ListNode <span class=\"title\">removeByTwoPointer</span><span class=\"params\">(ListNode head, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        ListNode support = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">0</span>);</span><br><span class=\"line\">        support.next = head;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//防止first.next.next删除节点时空指针错误</span></span><br><span class=\"line\">        ListNode first = support;</span><br><span class=\"line\">        ListNode second = support;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i &lt; n) &#123;</span><br><span class=\"line\">            second = second.next;</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (second != <span class=\"keyword\">null</span> &amp;&amp; second.next != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            second = second.next;</span><br><span class=\"line\">            first = first.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        first.next = first.next.next;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> support.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//Method1: get length, and remove (length -n + 1)th node</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> ListNode <span class=\"title\">removeByTwoPass</span><span class=\"params\">(ListNode head, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        ListNode support = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">0</span>);</span><br><span class=\"line\">        support.next = head;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> length = <span class=\"number\">1</span>;</span><br><span class=\"line\">        ListNode iter = head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(iter.next != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            iter = iter.next;</span><br><span class=\"line\">            length++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        length -= n;</span><br><span class=\"line\">        <span class=\"comment\">//在头节点前加了一个哨兵节点</span></span><br><span class=\"line\">        iter = support;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            length--;</span><br><span class=\"line\">            iter = iter.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        iter.next = iter.next.next;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> support.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode 189. 翻转数组","date":"2020-06-26T09:42:54.000Z","_content":"\n### 题目\n\n[LeetCode 189. Rotate Array](https://leetcode.com/problems/rotate-array/)\n\n### 思路\n\n#### 实现1: 利用一个额外的数组\n\n1. 目标: 将数组1中每一个元素, 移动到额外数组目标索引位置\n2. 目标索引 = (现在位置 + 步数) % 长度\n3. 最终将额外数组元素再复制回原数组\nPS: 这里要注意 java中 `Arrays.copyOf()`, `System.arraycopy()`, `clone() (对象是深拷贝, 对数组是浅拷贝)` 几种浅拷贝\n\n#### 实现2: 分析数组翻转后的元素排列, 使用位置互换\n<!--more-->\n1. 翻转所有元素\n2. K要先取模, 因为翻转 n(数组长度)的倍数是跟原数组一样\n3. 前K个翻转, 再将剩余翻转\n\n### 代码实现\n\n```java\nclass Solution {\n    public void rotate(int[] nums, int k) {\n        if(nums.length == 1 || k == 0) {\n            return;\n        }\n        //rotateByExtraArray(nums, k);\n        rotateByReplace(nums, k);\n    }\n    \n    /**\n    * rotate by extra array\n    */\n    private void rotateByExtraArray(int[] nums, int k) {\n        int[] result = new int[nums.length];\n        for (int i = 0; i < nums.length; i++) {\n            result[(i + k) % nums.length] = nums[i];\n        }\n        \n        for (int i = 0; i < nums.length; i++) {\n            nums[i] = result[i];\n        }\n    }\n    \n    /**\n    * rotate by replace\n    */\n    public void rotateByReplace(int[] nums, int k) {\n        \n        k = k % nums.length;\n\n        reverse(nums, 0, nums.length - 1);\n        reverse(nums, 0, k-1);\n        reverse(nums, k, nums.length - 1);\n    }\n    \n    //reverse items in [i,j]\n    private void reverse(int[] nums, int i, int j){\n        for(; i < j; i++,j--){\n            int temp = nums[i];\n            nums[i] = nums[j];\n            nums[j] = temp;\n        }     \n    }\n}\n```","source":"_posts/algorithm/LeetCode 189. 翻转数组.md","raw":"---\ntitle: LeetCode 189. 翻转数组\ndate: 2020-06-26 17:42:54\ncategories: 算法日常练习\ntags:\n- 数据结构与算法\n- 数组\n---\n\n### 题目\n\n[LeetCode 189. Rotate Array](https://leetcode.com/problems/rotate-array/)\n\n### 思路\n\n#### 实现1: 利用一个额外的数组\n\n1. 目标: 将数组1中每一个元素, 移动到额外数组目标索引位置\n2. 目标索引 = (现在位置 + 步数) % 长度\n3. 最终将额外数组元素再复制回原数组\nPS: 这里要注意 java中 `Arrays.copyOf()`, `System.arraycopy()`, `clone() (对象是深拷贝, 对数组是浅拷贝)` 几种浅拷贝\n\n#### 实现2: 分析数组翻转后的元素排列, 使用位置互换\n<!--more-->\n1. 翻转所有元素\n2. K要先取模, 因为翻转 n(数组长度)的倍数是跟原数组一样\n3. 前K个翻转, 再将剩余翻转\n\n### 代码实现\n\n```java\nclass Solution {\n    public void rotate(int[] nums, int k) {\n        if(nums.length == 1 || k == 0) {\n            return;\n        }\n        //rotateByExtraArray(nums, k);\n        rotateByReplace(nums, k);\n    }\n    \n    /**\n    * rotate by extra array\n    */\n    private void rotateByExtraArray(int[] nums, int k) {\n        int[] result = new int[nums.length];\n        for (int i = 0; i < nums.length; i++) {\n            result[(i + k) % nums.length] = nums[i];\n        }\n        \n        for (int i = 0; i < nums.length; i++) {\n            nums[i] = result[i];\n        }\n    }\n    \n    /**\n    * rotate by replace\n    */\n    public void rotateByReplace(int[] nums, int k) {\n        \n        k = k % nums.length;\n\n        reverse(nums, 0, nums.length - 1);\n        reverse(nums, 0, k-1);\n        reverse(nums, k, nums.length - 1);\n    }\n    \n    //reverse items in [i,j]\n    private void reverse(int[] nums, int i, int j){\n        for(; i < j; i++,j--){\n            int temp = nums[i];\n            nums[i] = nums[j];\n            nums[j] = temp;\n        }     \n    }\n}\n```","slug":"algorithm/LeetCode 189. 翻转数组","published":1,"updated":"2020-10-27T08:08:15.921Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckio9dwcw0008k8neq3v861vp","content":"<h3 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h3><p><a href=\"https://leetcode.com/problems/rotate-array/\" target=\"_blank\" rel=\"noopener\">LeetCode 189. Rotate Array</a></p>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><h4 id=\"实现1-利用一个额外的数组\"><a href=\"#实现1-利用一个额外的数组\" class=\"headerlink\" title=\"实现1: 利用一个额外的数组\"></a>实现1: 利用一个额外的数组</h4><ol>\n<li>目标: 将数组1中每一个元素, 移动到额外数组目标索引位置</li>\n<li>目标索引 = (现在位置 + 步数) % 长度</li>\n<li>最终将额外数组元素再复制回原数组<br>PS: 这里要注意 java中 <code>Arrays.copyOf()</code>, <code>System.arraycopy()</code>, <code>clone() (对象是深拷贝, 对数组是浅拷贝)</code> 几种浅拷贝</li>\n</ol>\n<h4 id=\"实现2-分析数组翻转后的元素排列-使用位置互换\"><a href=\"#实现2-分析数组翻转后的元素排列-使用位置互换\" class=\"headerlink\" title=\"实现2: 分析数组翻转后的元素排列, 使用位置互换\"></a>实现2: 分析数组翻转后的元素排列, 使用位置互换</h4><a id=\"more\"></a>\n<ol>\n<li>翻转所有元素</li>\n<li>K要先取模, 因为翻转 n(数组长度)的倍数是跟原数组一样</li>\n<li>前K个翻转, 再将剩余翻转</li>\n</ol>\n<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">rotate</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums.length == <span class=\"number\">1</span> || k == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//rotateByExtraArray(nums, k);</span></span><br><span class=\"line\">        rotateByReplace(nums, k);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * rotate by extra array</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">rotateByExtraArray</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] result = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[nums.length];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            result[(i + k) % nums.length] = nums[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            nums[i] = result[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * rotate by replace</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">rotateByReplace</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        k = k % nums.length;</span><br><span class=\"line\"></span><br><span class=\"line\">        reverse(nums, <span class=\"number\">0</span>, nums.length - <span class=\"number\">1</span>);</span><br><span class=\"line\">        reverse(nums, <span class=\"number\">0</span>, k-<span class=\"number\">1</span>);</span><br><span class=\"line\">        reverse(nums, k, nums.length - <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//reverse items in [i,j]</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">reverse</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(; i &lt; j; i++,j--)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> temp = nums[i];</span><br><span class=\"line\">            nums[i] = nums[j];</span><br><span class=\"line\">            nums[j] = temp;</span><br><span class=\"line\">        &#125;     </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h3 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h3><p><a href=\"https://leetcode.com/problems/rotate-array/\" target=\"_blank\" rel=\"noopener\">LeetCode 189. Rotate Array</a></p>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><h4 id=\"实现1-利用一个额外的数组\"><a href=\"#实现1-利用一个额外的数组\" class=\"headerlink\" title=\"实现1: 利用一个额外的数组\"></a>实现1: 利用一个额外的数组</h4><ol>\n<li>目标: 将数组1中每一个元素, 移动到额外数组目标索引位置</li>\n<li>目标索引 = (现在位置 + 步数) % 长度</li>\n<li>最终将额外数组元素再复制回原数组<br>PS: 这里要注意 java中 <code>Arrays.copyOf()</code>, <code>System.arraycopy()</code>, <code>clone() (对象是深拷贝, 对数组是浅拷贝)</code> 几种浅拷贝</li>\n</ol>\n<h4 id=\"实现2-分析数组翻转后的元素排列-使用位置互换\"><a href=\"#实现2-分析数组翻转后的元素排列-使用位置互换\" class=\"headerlink\" title=\"实现2: 分析数组翻转后的元素排列, 使用位置互换\"></a>实现2: 分析数组翻转后的元素排列, 使用位置互换</h4>","more":"<ol>\n<li>翻转所有元素</li>\n<li>K要先取模, 因为翻转 n(数组长度)的倍数是跟原数组一样</li>\n<li>前K个翻转, 再将剩余翻转</li>\n</ol>\n<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">rotate</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums.length == <span class=\"number\">1</span> || k == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//rotateByExtraArray(nums, k);</span></span><br><span class=\"line\">        rotateByReplace(nums, k);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * rotate by extra array</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">rotateByExtraArray</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] result = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[nums.length];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            result[(i + k) % nums.length] = nums[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            nums[i] = result[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * rotate by replace</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">rotateByReplace</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        k = k % nums.length;</span><br><span class=\"line\"></span><br><span class=\"line\">        reverse(nums, <span class=\"number\">0</span>, nums.length - <span class=\"number\">1</span>);</span><br><span class=\"line\">        reverse(nums, <span class=\"number\">0</span>, k-<span class=\"number\">1</span>);</span><br><span class=\"line\">        reverse(nums, k, nums.length - <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//reverse items in [i,j]</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">reverse</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(; i &lt; j; i++,j--)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> temp = nums[i];</span><br><span class=\"line\">            nums[i] = nums[j];</span><br><span class=\"line\">            nums[j] = temp;</span><br><span class=\"line\">        &#125;     </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode 21. Merge Two Sorted Lists","date":"2020-07-04T12:42:36.000Z","_content":"\n### 题目:\n\n[LeetCode 21. Merge Two Sorted Lists](https://leetcode.com/problems/merge-two-sorted-lists/)\n\n### 思路:\n\n基本思想就是新建一个链表, 然后从两个列表的头结点分别依次比较大小, 并将较小的插入新链表中.\n实现1: 递归实现\n实现2: 两个链表依次遍历插入新链表\n<!--more-->\n\n### 代码实现:\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        if (l1 == null) return l2;\n        \n        if (l2 == null) return l1;\n        \n        ListNode temp = null;\n        if(l1.val > l2.val){\n            temp = l2;\n            temp.next = mergeTwoLists(l1, l2.next);\n        }else{\n            temp = l1;\n            temp.next = mergeTwoLists(l1.next, l2);\n        }\n        return temp;\n    }\n}\n```\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        if (l1 == null || l2 == null) {\n            return l1 == null ? l2 : l1;\n        }\n        ListNode support = new ListNode(0);\n        ListNode temp = support;\n        ListNode temp1 = l1;\n        ListNode temp2 = l2;\n        while (temp1 != null && temp2 != null) {\n            if (temp1.val <= temp2.val) {\n                temp.next = temp1;\n                temp1 = temp1.next;\n            }else {\n                temp.next = temp2;\n                temp2 = temp2.next;\n            }\n            temp = temp.next;\n        }\n        if(temp1 != null) {\n            temp.next = temp1;\n        }else {\n            temp.next = temp2;\n        }\n        return support.next;\n    }\n}\n```","source":"_posts/algorithm/LeetCode 21. Merge Two Sorted Lists.md","raw":"---\ntitle: LeetCode 21. Merge Two Sorted Lists\ndate: 2020-07-04 20:42:36\ncategories: 算法日常练习\ntags:\n- 数据结构与算法\n- 链表\n\n---\n\n### 题目:\n\n[LeetCode 21. Merge Two Sorted Lists](https://leetcode.com/problems/merge-two-sorted-lists/)\n\n### 思路:\n\n基本思想就是新建一个链表, 然后从两个列表的头结点分别依次比较大小, 并将较小的插入新链表中.\n实现1: 递归实现\n实现2: 两个链表依次遍历插入新链表\n<!--more-->\n\n### 代码实现:\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        if (l1 == null) return l2;\n        \n        if (l2 == null) return l1;\n        \n        ListNode temp = null;\n        if(l1.val > l2.val){\n            temp = l2;\n            temp.next = mergeTwoLists(l1, l2.next);\n        }else{\n            temp = l1;\n            temp.next = mergeTwoLists(l1.next, l2);\n        }\n        return temp;\n    }\n}\n```\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        if (l1 == null || l2 == null) {\n            return l1 == null ? l2 : l1;\n        }\n        ListNode support = new ListNode(0);\n        ListNode temp = support;\n        ListNode temp1 = l1;\n        ListNode temp2 = l2;\n        while (temp1 != null && temp2 != null) {\n            if (temp1.val <= temp2.val) {\n                temp.next = temp1;\n                temp1 = temp1.next;\n            }else {\n                temp.next = temp2;\n                temp2 = temp2.next;\n            }\n            temp = temp.next;\n        }\n        if(temp1 != null) {\n            temp.next = temp1;\n        }else {\n            temp.next = temp2;\n        }\n        return support.next;\n    }\n}\n```","slug":"algorithm/LeetCode 21. Merge Two Sorted Lists","published":1,"updated":"2020-10-27T08:08:15.923Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckio9dwd0000bk8ne9rah7rvo","content":"<h3 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目:\"></a>题目:</h3><p><a href=\"https://leetcode.com/problems/merge-two-sorted-lists/\" target=\"_blank\" rel=\"noopener\">LeetCode 21. Merge Two Sorted Lists</a></p>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路:\"></a>思路:</h3><p>基本思想就是新建一个链表, 然后从两个列表的头结点分别依次比较大小, 并将较小的插入新链表中.<br>实现1: 递归实现<br>实现2: 两个链表依次遍历插入新链表</p>\n<a id=\"more\"></a>\n\n<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现:\"></a>代码实现:</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">mergeTwoLists</span><span class=\"params\">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (l1 == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> l2;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (l2 == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> l1;</span><br><span class=\"line\">        </span><br><span class=\"line\">        ListNode temp = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(l1.val &gt; l2.val)&#123;</span><br><span class=\"line\">            temp = l2;</span><br><span class=\"line\">            temp.next = mergeTwoLists(l1, l2.next);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            temp = l1;</span><br><span class=\"line\">            temp.next = mergeTwoLists(l1.next, l2);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> temp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode() &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">mergeTwoLists</span><span class=\"params\">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (l1 == <span class=\"keyword\">null</span> || l2 == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> l1 == <span class=\"keyword\">null</span> ? l2 : l1;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ListNode support = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">0</span>);</span><br><span class=\"line\">        ListNode temp = support;</span><br><span class=\"line\">        ListNode temp1 = l1;</span><br><span class=\"line\">        ListNode temp2 = l2;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (temp1 != <span class=\"keyword\">null</span> &amp;&amp; temp2 != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (temp1.val &lt;= temp2.val) &#123;</span><br><span class=\"line\">                temp.next = temp1;</span><br><span class=\"line\">                temp1 = temp1.next;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                temp.next = temp2;</span><br><span class=\"line\">                temp2 = temp2.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            temp = temp.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(temp1 != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            temp.next = temp1;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            temp.next = temp2;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> support.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h3 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目:\"></a>题目:</h3><p><a href=\"https://leetcode.com/problems/merge-two-sorted-lists/\" target=\"_blank\" rel=\"noopener\">LeetCode 21. Merge Two Sorted Lists</a></p>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路:\"></a>思路:</h3><p>基本思想就是新建一个链表, 然后从两个列表的头结点分别依次比较大小, 并将较小的插入新链表中.<br>实现1: 递归实现<br>实现2: 两个链表依次遍历插入新链表</p>","more":"<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现:\"></a>代码实现:</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">mergeTwoLists</span><span class=\"params\">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (l1 == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> l2;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (l2 == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> l1;</span><br><span class=\"line\">        </span><br><span class=\"line\">        ListNode temp = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(l1.val &gt; l2.val)&#123;</span><br><span class=\"line\">            temp = l2;</span><br><span class=\"line\">            temp.next = mergeTwoLists(l1, l2.next);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            temp = l1;</span><br><span class=\"line\">            temp.next = mergeTwoLists(l1.next, l2);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> temp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode() &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">mergeTwoLists</span><span class=\"params\">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (l1 == <span class=\"keyword\">null</span> || l2 == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> l1 == <span class=\"keyword\">null</span> ? l2 : l1;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ListNode support = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">0</span>);</span><br><span class=\"line\">        ListNode temp = support;</span><br><span class=\"line\">        ListNode temp1 = l1;</span><br><span class=\"line\">        ListNode temp2 = l2;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (temp1 != <span class=\"keyword\">null</span> &amp;&amp; temp2 != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (temp1.val &lt;= temp2.val) &#123;</span><br><span class=\"line\">                temp.next = temp1;</span><br><span class=\"line\">                temp1 = temp1.next;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                temp.next = temp2;</span><br><span class=\"line\">                temp2 = temp2.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            temp = temp.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(temp1 != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            temp.next = temp1;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            temp.next = temp2;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> support.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode 141. Linked List Cycle","date":"2020-07-20T14:35:39.000Z","_content":"\n### 题目:\n\n[LeetCode 141. Linked List Cycle](https://leetcode.com/problems/linked-list-cycle/)\n\n### 思路:\n\n1. 最先想到的是遍历链表, 并将结点的内存地址存在`HashSet`中.如果当前结点的内存地址已经存在,则表示存在环,直接返回`true`\n2. 还可以用双指针(快慢指针)来解决, 如果两个指针相遇(套圈), 则代表存在环.\n<!--more-->\n### 代码实现:\n\n```java\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public boolean hasCycle(ListNode head) {\n        if (head == null || head.next == null) {\n            return false;\n        }\n        Set<ListNode> set = new HashSet<>();\n        while (head != null) {\n            if (set.contains(head)){\n                return true;\n            }\n            set.add(head);\n            head = head.next;\n        }\n        return false;\n    }\n}\n```\n\n```java\npublic class Solution {\n    public boolean hasCycle(ListNode head) {\n        if (head == null || head.next == null) {\n            return false;\n        }\n        ListNode slow = head;\n        ListNode fast = head.next;\n        while (slow != fast) {\n            if (fast == null || fast.next == null) {\n                return false;\n            }\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        return true;\n    }\n}\n```","source":"_posts/algorithm/LeetCode 141. Linked List Cycle.md","raw":"---\ntitle: LeetCode 141. Linked List Cycle\ndate: 2020-07-20 22:35:39\ncategories: 算法日常练习\ntags:\n- 数据结构与算法\n- 链表\n  \n---\n\n### 题目:\n\n[LeetCode 141. Linked List Cycle](https://leetcode.com/problems/linked-list-cycle/)\n\n### 思路:\n\n1. 最先想到的是遍历链表, 并将结点的内存地址存在`HashSet`中.如果当前结点的内存地址已经存在,则表示存在环,直接返回`true`\n2. 还可以用双指针(快慢指针)来解决, 如果两个指针相遇(套圈), 则代表存在环.\n<!--more-->\n### 代码实现:\n\n```java\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public boolean hasCycle(ListNode head) {\n        if (head == null || head.next == null) {\n            return false;\n        }\n        Set<ListNode> set = new HashSet<>();\n        while (head != null) {\n            if (set.contains(head)){\n                return true;\n            }\n            set.add(head);\n            head = head.next;\n        }\n        return false;\n    }\n}\n```\n\n```java\npublic class Solution {\n    public boolean hasCycle(ListNode head) {\n        if (head == null || head.next == null) {\n            return false;\n        }\n        ListNode slow = head;\n        ListNode fast = head.next;\n        while (slow != fast) {\n            if (fast == null || fast.next == null) {\n                return false;\n            }\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        return true;\n    }\n}\n```","slug":"algorithm/LeetCode 141. Linked List Cycle","published":1,"updated":"2020-10-27T08:08:15.920Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckio9dwd2000ck8neokk8lq6w","content":"<h3 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目:\"></a>题目:</h3><p><a href=\"https://leetcode.com/problems/linked-list-cycle/\" target=\"_blank\" rel=\"noopener\">LeetCode 141. Linked List Cycle</a></p>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路:\"></a>思路:</h3><ol>\n<li>最先想到的是遍历链表, 并将结点的内存地址存在<code>HashSet</code>中.如果当前结点的内存地址已经存在,则表示存在环,直接返回<code>true</code></li>\n<li>还可以用双指针(快慢指针)来解决, 如果两个指针相遇(套圈), 则代表存在环.<a id=\"more\"></a>\n<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现:\"></a>代码实现:</h3></li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * class ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         val = x;</span></span><br><span class=\"line\"><span class=\"comment\"> *         next = null;</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasCycle</span><span class=\"params\">(ListNode head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (head == <span class=\"keyword\">null</span> || head.next == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Set&lt;ListNode&gt; set = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (head != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (set.contains(head))&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            set.add(head);</span><br><span class=\"line\">            head = head.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasCycle</span><span class=\"params\">(ListNode head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (head == <span class=\"keyword\">null</span> || head.next == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ListNode slow = head;</span><br><span class=\"line\">        ListNode fast = head.next;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (slow != fast) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (fast == <span class=\"keyword\">null</span> || fast.next == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            slow = slow.next;</span><br><span class=\"line\">            fast = fast.next.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h3 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目:\"></a>题目:</h3><p><a href=\"https://leetcode.com/problems/linked-list-cycle/\" target=\"_blank\" rel=\"noopener\">LeetCode 141. Linked List Cycle</a></p>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路:\"></a>思路:</h3><ol>\n<li>最先想到的是遍历链表, 并将结点的内存地址存在<code>HashSet</code>中.如果当前结点的内存地址已经存在,则表示存在环,直接返回<code>true</code></li>\n<li>还可以用双指针(快慢指针)来解决, 如果两个指针相遇(套圈), 则代表存在环.","more":"<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现:\"></a>代码实现:</h3></li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * class ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         val = x;</span></span><br><span class=\"line\"><span class=\"comment\"> *         next = null;</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasCycle</span><span class=\"params\">(ListNode head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (head == <span class=\"keyword\">null</span> || head.next == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Set&lt;ListNode&gt; set = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (head != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (set.contains(head))&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            set.add(head);</span><br><span class=\"line\">            head = head.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasCycle</span><span class=\"params\">(ListNode head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (head == <span class=\"keyword\">null</span> || head.next == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ListNode slow = head;</span><br><span class=\"line\">        ListNode fast = head.next;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (slow != fast) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (fast == <span class=\"keyword\">null</span> || fast.next == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            slow = slow.next;</span><br><span class=\"line\">            fast = fast.next.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode 2. 两数相加","date":"2020-07-21T01:50:01.000Z","_content":"\n### 题目\n\n[LeetCode 2. Add Two Numbers](https://leetcode.com/problems/add-two-numbers/solution/)\n\n### 思路\n\n1. 两个逆序存储数值的链表, 要求返回数值相加结果并且逆序存储的链表.\n2. 就两个链表一起遍历, 每一位相加:\n\n    * 若小于10直接拼接到新链表中\n    * 若大于10, 则个位数拼接到新链表, 十位数加入到下一个链表节点的计算中(实际就是进位)\n\n其实就是两数相加, 链表的头节点就是个位, 依此类推. \n<!--more-->\n### 代码实现\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        ListNode support = new ListNode();\n        ListNode p = l1;\n        ListNode q = l2;\n        ListNode curr = support;\n        int carry = 0;\n        while (p != null || q != null) {\n            int x = (p == null) ? 0 : p.val;\n            int y = (q == null) ? 0 : q.val;\n            int sum = carry + x + y;\n            //余数\n            carry = sum / 10;\n            curr.next = new ListNode(sum % 10);\n            curr = curr.next;\n            if (p != null) {\n                p = p.next;\n            }\n            if (q != null) {\n                q = q.next;\n            }\n        }\n        if (carry > 0) {\n            curr.next = new ListNode(carry);\n        }\n        return support.next;\n    }\n}\n```","source":"_posts/algorithm/LeetCode 2. 两数相加.md","raw":"---\ntitle: LeetCode 2. 两数相加\ndate: 2020-07-21 09:50:01\ncategories: 算法日常练习\ntags:\n- 数据结构与算法\n- 链表\n---\n\n### 题目\n\n[LeetCode 2. Add Two Numbers](https://leetcode.com/problems/add-two-numbers/solution/)\n\n### 思路\n\n1. 两个逆序存储数值的链表, 要求返回数值相加结果并且逆序存储的链表.\n2. 就两个链表一起遍历, 每一位相加:\n\n    * 若小于10直接拼接到新链表中\n    * 若大于10, 则个位数拼接到新链表, 十位数加入到下一个链表节点的计算中(实际就是进位)\n\n其实就是两数相加, 链表的头节点就是个位, 依此类推. \n<!--more-->\n### 代码实现\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        ListNode support = new ListNode();\n        ListNode p = l1;\n        ListNode q = l2;\n        ListNode curr = support;\n        int carry = 0;\n        while (p != null || q != null) {\n            int x = (p == null) ? 0 : p.val;\n            int y = (q == null) ? 0 : q.val;\n            int sum = carry + x + y;\n            //余数\n            carry = sum / 10;\n            curr.next = new ListNode(sum % 10);\n            curr = curr.next;\n            if (p != null) {\n                p = p.next;\n            }\n            if (q != null) {\n                q = q.next;\n            }\n        }\n        if (carry > 0) {\n            curr.next = new ListNode(carry);\n        }\n        return support.next;\n    }\n}\n```","slug":"algorithm/LeetCode 2. 两数相加","published":1,"updated":"2020-10-27T08:08:15.922Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckio9dwd5000gk8nejtyrvwpg","content":"<h3 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h3><p><a href=\"https://leetcode.com/problems/add-two-numbers/solution/\" target=\"_blank\" rel=\"noopener\">LeetCode 2. Add Two Numbers</a></p>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><ol>\n<li><p>两个逆序存储数值的链表, 要求返回数值相加结果并且逆序存储的链表.</p>\n</li>\n<li><p>就两个链表一起遍历, 每一位相加:</p>\n<ul>\n<li>若小于10直接拼接到新链表中</li>\n<li>若大于10, 则个位数拼接到新链表, 十位数加入到下一个链表节点的计算中(实际就是进位)</li>\n</ul>\n</li>\n</ol>\n<p>其实就是两数相加, 链表的头节点就是个位, 依此类推. </p>\n<a id=\"more\"></a>\n<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode() &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">addTwoNumbers</span><span class=\"params\">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class=\"line\">        ListNode support = <span class=\"keyword\">new</span> ListNode();</span><br><span class=\"line\">        ListNode p = l1;</span><br><span class=\"line\">        ListNode q = l2;</span><br><span class=\"line\">        ListNode curr = support;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> carry = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (p != <span class=\"keyword\">null</span> || q != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> x = (p == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : p.val;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> y = (q == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : q.val;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> sum = carry + x + y;</span><br><span class=\"line\">            <span class=\"comment\">//余数</span></span><br><span class=\"line\">            carry = sum / <span class=\"number\">10</span>;</span><br><span class=\"line\">            curr.next = <span class=\"keyword\">new</span> ListNode(sum % <span class=\"number\">10</span>);</span><br><span class=\"line\">            curr = curr.next;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                p = p.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (q != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                q = q.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (carry &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            curr.next = <span class=\"keyword\">new</span> ListNode(carry);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> support.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h3 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h3><p><a href=\"https://leetcode.com/problems/add-two-numbers/solution/\" target=\"_blank\" rel=\"noopener\">LeetCode 2. Add Two Numbers</a></p>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><ol>\n<li><p>两个逆序存储数值的链表, 要求返回数值相加结果并且逆序存储的链表.</p>\n</li>\n<li><p>就两个链表一起遍历, 每一位相加:</p>\n<ul>\n<li>若小于10直接拼接到新链表中</li>\n<li>若大于10, 则个位数拼接到新链表, 十位数加入到下一个链表节点的计算中(实际就是进位)</li>\n</ul>\n</li>\n</ol>\n<p>其实就是两数相加, 链表的头节点就是个位, 依此类推. </p>","more":"<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode() &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">addTwoNumbers</span><span class=\"params\">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class=\"line\">        ListNode support = <span class=\"keyword\">new</span> ListNode();</span><br><span class=\"line\">        ListNode p = l1;</span><br><span class=\"line\">        ListNode q = l2;</span><br><span class=\"line\">        ListNode curr = support;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> carry = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (p != <span class=\"keyword\">null</span> || q != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> x = (p == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : p.val;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> y = (q == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : q.val;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> sum = carry + x + y;</span><br><span class=\"line\">            <span class=\"comment\">//余数</span></span><br><span class=\"line\">            carry = sum / <span class=\"number\">10</span>;</span><br><span class=\"line\">            curr.next = <span class=\"keyword\">new</span> ListNode(sum % <span class=\"number\">10</span>);</span><br><span class=\"line\">            curr = curr.next;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                p = p.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (q != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                q = q.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (carry &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            curr.next = <span class=\"keyword\">new</span> ListNode(carry);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> support.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode 206. Reverse Linked List","date":"2020-06-18T13:37:04.000Z","_content":"\n### 题目:\n\n [LeetCode 206. Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/)\n\n### 思路:\n\n链表的问题说简单也简单, 但是手写代码时也挺容易出错的,主要考验对边界问题的处理.\n<br>\n单链表反转我觉得重点在于<b>头节点的后继指针指向<code>null</code></b>\n<br>\n其次循环中的逻辑就比较简单了:\n<!--more-->\n1. 保存临时后继结点\n2. 把指针指向前驱结点\n3. 指定当前结点为前驱, 后继结点为当前, 进行下一个结点的反转\n\n### 代码实现\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\n class solution {\n     public ListNode reverseList(ListNode head) {\n         ListNode currNode = head;\n         ListNode prevNode = null;\n         ListNode nextTemp = null;\n         while (currNode.next != null) {\n             nextTemp = currNode.next;\n             currNode.next = prevNode;\n             prevNode = currNode;\n             currNode = nextTemp;\n         }\n         return prev;\n     }\n }\n```","source":"_posts/algorithm/LeetCode 206. Reverse Linked List.md","raw":"---\ntitle: LeetCode 206. Reverse Linked List\ndate: 2020-06-18 21:37:04\ncategories: 算法日常练习\ntags:\n- 数据结构与算法\n- 链表\n---\n\n### 题目:\n\n [LeetCode 206. Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/)\n\n### 思路:\n\n链表的问题说简单也简单, 但是手写代码时也挺容易出错的,主要考验对边界问题的处理.\n<br>\n单链表反转我觉得重点在于<b>头节点的后继指针指向<code>null</code></b>\n<br>\n其次循环中的逻辑就比较简单了:\n<!--more-->\n1. 保存临时后继结点\n2. 把指针指向前驱结点\n3. 指定当前结点为前驱, 后继结点为当前, 进行下一个结点的反转\n\n### 代码实现\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\n class solution {\n     public ListNode reverseList(ListNode head) {\n         ListNode currNode = head;\n         ListNode prevNode = null;\n         ListNode nextTemp = null;\n         while (currNode.next != null) {\n             nextTemp = currNode.next;\n             currNode.next = prevNode;\n             prevNode = currNode;\n             currNode = nextTemp;\n         }\n         return prev;\n     }\n }\n```","slug":"algorithm/LeetCode 206. Reverse Linked List","published":1,"updated":"2020-10-27T08:08:15.922Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckio9dwd6000jk8nexq477swe","content":"<h3 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目:\"></a>题目:</h3><p> <a href=\"https://leetcode.com/problems/reverse-linked-list/\" target=\"_blank\" rel=\"noopener\">LeetCode 206. Reverse Linked List</a></p>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路:\"></a>思路:</h3><p>链表的问题说简单也简单, 但是手写代码时也挺容易出错的,主要考验对边界问题的处理.<br><br><br>单链表反转我觉得重点在于<b>头节点的后继指针指向<code>null</code></b><br><br><br>其次循环中的逻辑就比较简单了:</p>\n<a id=\"more\"></a>\n<ol>\n<li>保存临时后继结点</li>\n<li>把指针指向前驱结点</li>\n<li>指定当前结点为前驱, 后继结点为当前, 进行下一个结点的反转</li>\n</ol>\n<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">solution</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">reverseList</span><span class=\"params\">(ListNode head)</span> </span>&#123;</span><br><span class=\"line\">         ListNode currNode = head;</span><br><span class=\"line\">         ListNode prevNode = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">         ListNode nextTemp = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">         <span class=\"keyword\">while</span> (currNode.next != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">             nextTemp = currNode.next;</span><br><span class=\"line\">             currNode.next = prevNode;</span><br><span class=\"line\">             prevNode = currNode;</span><br><span class=\"line\">             currNode = nextTemp;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> prev;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h3 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目:\"></a>题目:</h3><p> <a href=\"https://leetcode.com/problems/reverse-linked-list/\" target=\"_blank\" rel=\"noopener\">LeetCode 206. Reverse Linked List</a></p>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路:\"></a>思路:</h3><p>链表的问题说简单也简单, 但是手写代码时也挺容易出错的,主要考验对边界问题的处理.<br><br><br>单链表反转我觉得重点在于<b>头节点的后继指针指向<code>null</code></b><br><br><br>其次循环中的逻辑就比较简单了:</p>","more":"<ol>\n<li>保存临时后继结点</li>\n<li>把指针指向前驱结点</li>\n<li>指定当前结点为前驱, 后继结点为当前, 进行下一个结点的反转</li>\n</ol>\n<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">solution</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">reverseList</span><span class=\"params\">(ListNode head)</span> </span>&#123;</span><br><span class=\"line\">         ListNode currNode = head;</span><br><span class=\"line\">         ListNode prevNode = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">         ListNode nextTemp = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">         <span class=\"keyword\">while</span> (currNode.next != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">             nextTemp = currNode.next;</span><br><span class=\"line\">             currNode.next = prevNode;</span><br><span class=\"line\">             prevNode = currNode;</span><br><span class=\"line\">             currNode = nextTemp;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> prev;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode 27. 移除数组元素","date":"2020-06-28T12:45:19.000Z","_content":"\n### 题目\n\n[LeetCode 27. Remove Element](https://leetcode.com/problems/remove-element/)\n\n### 思路\n\n这道题目, 把题意读明白就好做了.\n预定义的方法中要求返回`int类型长度len`, 但代码提交时, 却是按照 `nums中[0, len)的区间输出`判断的.\n所以最终需要注意的是:\n\n1. O(1) 空间复杂度\n2. nums中跟val不等的元素, 要往前移\n<!--more-->\n### 代码实现\n\n```java\nclass Solution {\n    public int removeElement(int[] nums, int val) {\n        if (nums == null || nums.length == 0) {\n            return 0;\n        }\n        \n        int i = 0;\n        int j = 0;\n        while (i < nums.length) {\n            if (nums[i] == val) {\n                i++;\n                continue;\n            }else{\n                nums[j] = nums[i];\n                i++;\n                j++;\n            }\n        }\n        return j;\n    }\n}\n```","source":"_posts/algorithm/LeetCode 27. 移除数组元素.md","raw":"---\ntitle: LeetCode 27. 移除数组元素\ndate: 2020-6-28 20:45:19\ncategories: 算法日常练习\ntags:\n- 数据结构与算法\n---\n\n### 题目\n\n[LeetCode 27. Remove Element](https://leetcode.com/problems/remove-element/)\n\n### 思路\n\n这道题目, 把题意读明白就好做了.\n预定义的方法中要求返回`int类型长度len`, 但代码提交时, 却是按照 `nums中[0, len)的区间输出`判断的.\n所以最终需要注意的是:\n\n1. O(1) 空间复杂度\n2. nums中跟val不等的元素, 要往前移\n<!--more-->\n### 代码实现\n\n```java\nclass Solution {\n    public int removeElement(int[] nums, int val) {\n        if (nums == null || nums.length == 0) {\n            return 0;\n        }\n        \n        int i = 0;\n        int j = 0;\n        while (i < nums.length) {\n            if (nums[i] == val) {\n                i++;\n                continue;\n            }else{\n                nums[j] = nums[i];\n                i++;\n                j++;\n            }\n        }\n        return j;\n    }\n}\n```","slug":"algorithm/LeetCode 27. 移除数组元素","published":1,"updated":"2020-10-27T08:08:15.923Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckio9dwda000nk8neo1svote1","content":"<h3 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h3><p><a href=\"https://leetcode.com/problems/remove-element/\" target=\"_blank\" rel=\"noopener\">LeetCode 27. Remove Element</a></p>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>这道题目, 把题意读明白就好做了.<br>预定义的方法中要求返回<code>int类型长度len</code>, 但代码提交时, 却是按照 <code>nums中[0, len)的区间输出</code>判断的.<br>所以最终需要注意的是:</p>\n<ol>\n<li>O(1) 空间复杂度</li>\n<li>nums中跟val不等的元素, 要往前移<a id=\"more\"></a>\n<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3></li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">removeElement</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums == <span class=\"keyword\">null</span> || nums.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i &lt; nums.length) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[i] == val) &#123;</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                nums[j] = nums[i];</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">                j++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> j;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h3 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h3><p><a href=\"https://leetcode.com/problems/remove-element/\" target=\"_blank\" rel=\"noopener\">LeetCode 27. Remove Element</a></p>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>这道题目, 把题意读明白就好做了.<br>预定义的方法中要求返回<code>int类型长度len</code>, 但代码提交时, 却是按照 <code>nums中[0, len)的区间输出</code>判断的.<br>所以最终需要注意的是:</p>\n<ol>\n<li>O(1) 空间复杂度</li>\n<li>nums中跟val不等的元素, 要往前移","more":"<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3></li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">removeElement</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums == <span class=\"keyword\">null</span> || nums.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i &lt; nums.length) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[i] == val) &#123;</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                nums[j] = nums[i];</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">                j++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> j;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode 350. 两个数组的交集","date":"2020-06-20T01:59:01.000Z","_content":"\n### 题目\n\n[leetcode 350. Intersection of Two Arrays II](https://leetcode.com/problems/intersection-of-two-arrays-ii/)\n\n### 思路\n\n1. 最原始的想法就是判断数组1的元素, 是否出现在数组2中. \n2. 但如果有重复的元素会导致结果错误, 所以要忽略掉已经判断属于交集的两个数组中的元素\n3. 在这里借用map来协助计算, map结构: <元素, 出现次数>, 遍历数组1并存入map中\n4. 遍历数组2, 判断是否在map中, 存在则value--\n5. 这里并没有新建数组存储结果, 而是直接存到了数组2中, 因为移动计算过的数据不再需要\n\n### 进阶问题\n\n1. 若两个数组有序, 算法能否优化?\n<!--more-->\n\n### 代码实现\n\n```java\nclass Solution {\n    public int[] intersect(int[] nums1, int[] nums2) {\n      //valid param\n      if (nums1 == null || nums2 == null || nums1.length ==0 || nums2.length == 0) {\n          return new int[]{};\n      }\n      //convert array1 to map\n      Map<Integer, Integer> map = new HashMap<>();\n      for(int i : nums1) {\n          map.put(i, map.getOrDefault(i, 0) + 1);\n      }\n        \n      //compare array2 and map\n      int index = 0;\n      for(int j : nums2) {\n          if (map.containsKey(j) && map.get(j) > 0) {\n              map.put(j, map.get(j) - 1);\n              nums2[index] = j;\n              index++;\n          }\n      }\n           \n      //return result\n      return Arrays.copyOf(nums2, index);\n    }\n}\n```\n","source":"_posts/algorithm/LeetCode 350. 两个数组的交集.md","raw":"---\ntitle: LeetCode 350. 两个数组的交集\ndate: 2020-06-20 09:59:01\ncategories: 算法日常练习\ntags:\n- 数据结构与算法\n---\n\n### 题目\n\n[leetcode 350. Intersection of Two Arrays II](https://leetcode.com/problems/intersection-of-two-arrays-ii/)\n\n### 思路\n\n1. 最原始的想法就是判断数组1的元素, 是否出现在数组2中. \n2. 但如果有重复的元素会导致结果错误, 所以要忽略掉已经判断属于交集的两个数组中的元素\n3. 在这里借用map来协助计算, map结构: <元素, 出现次数>, 遍历数组1并存入map中\n4. 遍历数组2, 判断是否在map中, 存在则value--\n5. 这里并没有新建数组存储结果, 而是直接存到了数组2中, 因为移动计算过的数据不再需要\n\n### 进阶问题\n\n1. 若两个数组有序, 算法能否优化?\n<!--more-->\n\n### 代码实现\n\n```java\nclass Solution {\n    public int[] intersect(int[] nums1, int[] nums2) {\n      //valid param\n      if (nums1 == null || nums2 == null || nums1.length ==0 || nums2.length == 0) {\n          return new int[]{};\n      }\n      //convert array1 to map\n      Map<Integer, Integer> map = new HashMap<>();\n      for(int i : nums1) {\n          map.put(i, map.getOrDefault(i, 0) + 1);\n      }\n        \n      //compare array2 and map\n      int index = 0;\n      for(int j : nums2) {\n          if (map.containsKey(j) && map.get(j) > 0) {\n              map.put(j, map.get(j) - 1);\n              nums2[index] = j;\n              index++;\n          }\n      }\n           \n      //return result\n      return Arrays.copyOf(nums2, index);\n    }\n}\n```\n","slug":"algorithm/LeetCode 350. 两个数组的交集","published":1,"updated":"2020-10-27T08:08:15.923Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckio9dwdc000qk8nepxuhdssl","content":"<h3 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h3><p><a href=\"https://leetcode.com/problems/intersection-of-two-arrays-ii/\" target=\"_blank\" rel=\"noopener\">leetcode 350. Intersection of Two Arrays II</a></p>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><ol>\n<li>最原始的想法就是判断数组1的元素, 是否出现在数组2中. </li>\n<li>但如果有重复的元素会导致结果错误, 所以要忽略掉已经判断属于交集的两个数组中的元素</li>\n<li>在这里借用map来协助计算, map结构: &lt;元素, 出现次数&gt;, 遍历数组1并存入map中</li>\n<li>遍历数组2, 判断是否在map中, 存在则value–</li>\n<li>这里并没有新建数组存储结果, 而是直接存到了数组2中, 因为移动计算过的数据不再需要</li>\n</ol>\n<h3 id=\"进阶问题\"><a href=\"#进阶问题\" class=\"headerlink\" title=\"进阶问题\"></a>进阶问题</h3><ol>\n<li>若两个数组有序, 算法能否优化?<a id=\"more\"></a>\n\n</li>\n</ol>\n<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] intersect(<span class=\"keyword\">int</span>[] nums1, <span class=\"keyword\">int</span>[] nums2) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//valid param</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (nums1 == <span class=\"keyword\">null</span> || nums2 == <span class=\"keyword\">null</span> || nums1.length ==<span class=\"number\">0</span> || nums2.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;&#125;;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">//convert array1 to map</span></span><br><span class=\"line\">      Map&lt;Integer, Integer&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">      <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i : nums1) &#123;</span><br><span class=\"line\">          map.put(i, map.getOrDefault(i, <span class=\"number\">0</span>) + <span class=\"number\">1</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">      <span class=\"comment\">//compare array2 and map</span></span><br><span class=\"line\">      <span class=\"keyword\">int</span> index = <span class=\"number\">0</span>;</span><br><span class=\"line\">      <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j : nums2) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (map.containsKey(j) &amp;&amp; map.get(j) &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">              map.put(j, map.get(j) - <span class=\"number\">1</span>);</span><br><span class=\"line\">              nums2[index] = j;</span><br><span class=\"line\">              index++;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">           </span><br><span class=\"line\">      <span class=\"comment\">//return result</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> Arrays.copyOf(nums2, index);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<h3 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h3><p><a href=\"https://leetcode.com/problems/intersection-of-two-arrays-ii/\" target=\"_blank\" rel=\"noopener\">leetcode 350. Intersection of Two Arrays II</a></p>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><ol>\n<li>最原始的想法就是判断数组1的元素, 是否出现在数组2中. </li>\n<li>但如果有重复的元素会导致结果错误, 所以要忽略掉已经判断属于交集的两个数组中的元素</li>\n<li>在这里借用map来协助计算, map结构: &lt;元素, 出现次数&gt;, 遍历数组1并存入map中</li>\n<li>遍历数组2, 判断是否在map中, 存在则value–</li>\n<li>这里并没有新建数组存储结果, 而是直接存到了数组2中, 因为移动计算过的数据不再需要</li>\n</ol>\n<h3 id=\"进阶问题\"><a href=\"#进阶问题\" class=\"headerlink\" title=\"进阶问题\"></a>进阶问题</h3><ol>\n<li>若两个数组有序, 算法能否优化?","more":"</li>\n</ol>\n<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] intersect(<span class=\"keyword\">int</span>[] nums1, <span class=\"keyword\">int</span>[] nums2) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//valid param</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (nums1 == <span class=\"keyword\">null</span> || nums2 == <span class=\"keyword\">null</span> || nums1.length ==<span class=\"number\">0</span> || nums2.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;&#125;;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">//convert array1 to map</span></span><br><span class=\"line\">      Map&lt;Integer, Integer&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">      <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i : nums1) &#123;</span><br><span class=\"line\">          map.put(i, map.getOrDefault(i, <span class=\"number\">0</span>) + <span class=\"number\">1</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">      <span class=\"comment\">//compare array2 and map</span></span><br><span class=\"line\">      <span class=\"keyword\">int</span> index = <span class=\"number\">0</span>;</span><br><span class=\"line\">      <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j : nums2) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (map.containsKey(j) &amp;&amp; map.get(j) &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">              map.put(j, map.get(j) - <span class=\"number\">1</span>);</span><br><span class=\"line\">              nums2[index] = j;</span><br><span class=\"line\">              index++;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">           </span><br><span class=\"line\">      <span class=\"comment\">//return result</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> Arrays.copyOf(nums2, index);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode 66. 加一","date":"2020-06-29T13:52:44.000Z","_content":"\n### 题目\n\n[LeetCode 66. Plus One](https://leetcode.com/problems/plus-one/)\n\n### 思路\n\n难度在于要考虑到所有情况:\n\n1. 末位 ≠ 9, 直接++, 返回数组\n2. 末位 == 9, 且存在某位 ≠ 9, 在该位 ++ , 返回数组\n3. 末位 == 9 , 前面所有位都是9, 新建一个数组, 首位置为1, 返回\n<!--more-->\n### 代码实现\n\n```java\nclass Solution {\n    public int[] plusOne(int[] digits) {\n        int last = digits.length - 1;\n        \n        //最简单的情况,末位 != 9, 加1, 返回数组\n        if (digits[last] != 9) {\n          digits[last] = digits[last] + 1;   \n          return digits;\n        }\n        \n        for (int i = last; i >= 0; i--) {\n            //当前位 != 9, 加1, 返回数组\n            if (digits[i] != 9) {\n                digits[i] = digits[i] + 1;\n                return digits;\n            }\n            \n            digits[i] = 0;\n            //首位 == 9, 要新建数组, 首位进1, 其它位置为0, 返回\n            if (i == 0) {\n                int[] result = new int[last + 2];\n                result[0] = 1;\n                return result;\n            }\n        }\n        return digits;\n    }\n}\n```\n","source":"_posts/algorithm/LeetCode 66. 加一.md","raw":"---\ntitle: LeetCode 66. 加一\ndate: 2020-06-29 21:52:44\ncategories: 算法日常练习\ntags:\n- 数据结构与算法\n---\n\n### 题目\n\n[LeetCode 66. Plus One](https://leetcode.com/problems/plus-one/)\n\n### 思路\n\n难度在于要考虑到所有情况:\n\n1. 末位 ≠ 9, 直接++, 返回数组\n2. 末位 == 9, 且存在某位 ≠ 9, 在该位 ++ , 返回数组\n3. 末位 == 9 , 前面所有位都是9, 新建一个数组, 首位置为1, 返回\n<!--more-->\n### 代码实现\n\n```java\nclass Solution {\n    public int[] plusOne(int[] digits) {\n        int last = digits.length - 1;\n        \n        //最简单的情况,末位 != 9, 加1, 返回数组\n        if (digits[last] != 9) {\n          digits[last] = digits[last] + 1;   \n          return digits;\n        }\n        \n        for (int i = last; i >= 0; i--) {\n            //当前位 != 9, 加1, 返回数组\n            if (digits[i] != 9) {\n                digits[i] = digits[i] + 1;\n                return digits;\n            }\n            \n            digits[i] = 0;\n            //首位 == 9, 要新建数组, 首位进1, 其它位置为0, 返回\n            if (i == 0) {\n                int[] result = new int[last + 2];\n                result[0] = 1;\n                return result;\n            }\n        }\n        return digits;\n    }\n}\n```\n","slug":"algorithm/LeetCode 66. 加一","published":1,"updated":"2020-10-27T08:08:15.924Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckio9dwdd000uk8nend7cxsni","content":"<h3 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h3><p><a href=\"https://leetcode.com/problems/plus-one/\" target=\"_blank\" rel=\"noopener\">LeetCode 66. Plus One</a></p>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>难度在于要考虑到所有情况:</p>\n<ol>\n<li>末位 ≠ 9, 直接++, 返回数组</li>\n<li>末位 == 9, 且存在某位 ≠ 9, 在该位 ++ , 返回数组</li>\n<li>末位 == 9 , 前面所有位都是9, 新建一个数组, 首位置为1, 返回<a id=\"more\"></a>\n<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3></li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] plusOne(<span class=\"keyword\">int</span>[] digits) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> last = digits.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//最简单的情况,末位 != 9, 加1, 返回数组</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (digits[last] != <span class=\"number\">9</span>) &#123;</span><br><span class=\"line\">          digits[last] = digits[last] + <span class=\"number\">1</span>;   </span><br><span class=\"line\">          <span class=\"keyword\">return</span> digits;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = last; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//当前位 != 9, 加1, 返回数组</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (digits[i] != <span class=\"number\">9</span>) &#123;</span><br><span class=\"line\">                digits[i] = digits[i] + <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> digits;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            digits[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"comment\">//首位 == 9, 要新建数组, 首位进1, 其它位置为0, 返回</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span>[] result = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[last + <span class=\"number\">2</span>];</span><br><span class=\"line\">                result[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> digits;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<h3 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h3><p><a href=\"https://leetcode.com/problems/plus-one/\" target=\"_blank\" rel=\"noopener\">LeetCode 66. Plus One</a></p>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>难度在于要考虑到所有情况:</p>\n<ol>\n<li>末位 ≠ 9, 直接++, 返回数组</li>\n<li>末位 == 9, 且存在某位 ≠ 9, 在该位 ++ , 返回数组</li>\n<li>末位 == 9 , 前面所有位都是9, 新建一个数组, 首位置为1, 返回","more":"<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3></li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] plusOne(<span class=\"keyword\">int</span>[] digits) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> last = digits.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//最简单的情况,末位 != 9, 加1, 返回数组</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (digits[last] != <span class=\"number\">9</span>) &#123;</span><br><span class=\"line\">          digits[last] = digits[last] + <span class=\"number\">1</span>;   </span><br><span class=\"line\">          <span class=\"keyword\">return</span> digits;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = last; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//当前位 != 9, 加1, 返回数组</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (digits[i] != <span class=\"number\">9</span>) &#123;</span><br><span class=\"line\">                digits[i] = digits[i] + <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> digits;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            digits[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"comment\">//首位 == 9, 要新建数组, 首位进1, 其它位置为0, 返回</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span>[] result = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[last + <span class=\"number\">2</span>];</span><br><span class=\"line\">                result[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> digits;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode 6. Z字形变换","date":"2020-07-02T08:45:22.000Z","_content":"\n### 题目\n\n[LeetCode 6. ZigZag Conversion](https://leetcode.com/problems/zigzag-conversion/submissions/)\n\n### 思路\n\n1. 最开始想的就是一个二维数组, 它把原字符串, 按照规律放入固定位置, 最后再拼接\n2. 那么又分为两个问题\n   * 二维数组要考虑越界和合并判断问题\n   * 这个Z(明明是N!)的规律是什么\n3. 关于Z的规律只能说, 在纸上画一下2行,3行的情况, 发现规律是`2n-2`个字母为一个循环周期, 再拿4行验证一下\n4. 另外选用了字符串来替代一维数组, 直接拼接保存该行\n   <!--more-->\n\n### 代码实现\n\n```java\nclass Solution {\n    public String convert(String s, int numRows) {\n        if (s == null || s.length() <= 0 || numRows <= 1) {\n            return s;\n        }\n        String[] arr = new String[numRows];\n        Arrays.fill(arr,\"\");\n        int cycle = 2 * numRows - 2;\n        int position = 0;\n        int mod = 0;\n        for (char c : s.toCharArray()) {\n            mod = position % cycle;\n            if (mod < numRows) {\n                arr[mod] += c;\n            }else{\n                arr[cycle - mod] += c;\n            }\n            position++;\n        }\n        StringBuilder re = new StringBuilder();\n        for(String line : arr) {\n            re.append(line);\n        }\n        return re.toString();\n    }\n}\n```","source":"_posts/algorithm/LeetCode 6. Z字形变换.md","raw":"---\ntitle: LeetCode 6. Z字形变换\ndate: 2020-07-02 16:45:22\ncategories: 算法日常练习\ntags:\n- 数据结构与算法\n---\n\n### 题目\n\n[LeetCode 6. ZigZag Conversion](https://leetcode.com/problems/zigzag-conversion/submissions/)\n\n### 思路\n\n1. 最开始想的就是一个二维数组, 它把原字符串, 按照规律放入固定位置, 最后再拼接\n2. 那么又分为两个问题\n   * 二维数组要考虑越界和合并判断问题\n   * 这个Z(明明是N!)的规律是什么\n3. 关于Z的规律只能说, 在纸上画一下2行,3行的情况, 发现规律是`2n-2`个字母为一个循环周期, 再拿4行验证一下\n4. 另外选用了字符串来替代一维数组, 直接拼接保存该行\n   <!--more-->\n\n### 代码实现\n\n```java\nclass Solution {\n    public String convert(String s, int numRows) {\n        if (s == null || s.length() <= 0 || numRows <= 1) {\n            return s;\n        }\n        String[] arr = new String[numRows];\n        Arrays.fill(arr,\"\");\n        int cycle = 2 * numRows - 2;\n        int position = 0;\n        int mod = 0;\n        for (char c : s.toCharArray()) {\n            mod = position % cycle;\n            if (mod < numRows) {\n                arr[mod] += c;\n            }else{\n                arr[cycle - mod] += c;\n            }\n            position++;\n        }\n        StringBuilder re = new StringBuilder();\n        for(String line : arr) {\n            re.append(line);\n        }\n        return re.toString();\n    }\n}\n```","slug":"algorithm/LeetCode 6. Z字形变换","published":1,"updated":"2020-10-27T08:08:15.924Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckio9dwdf000xk8ne5j7k7mvh","content":"<h3 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h3><p><a href=\"https://leetcode.com/problems/zigzag-conversion/submissions/\" target=\"_blank\" rel=\"noopener\">LeetCode 6. ZigZag Conversion</a></p>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><ol>\n<li>最开始想的就是一个二维数组, 它把原字符串, 按照规律放入固定位置, 最后再拼接</li>\n<li>那么又分为两个问题<ul>\n<li>二维数组要考虑越界和合并判断问题</li>\n<li>这个Z(明明是N!)的规律是什么</li>\n</ul>\n</li>\n<li>关于Z的规律只能说, 在纸上画一下2行,3行的情况, 发现规律是<code>2n-2</code>个字母为一个循环周期, 再拿4行验证一下</li>\n<li>另外选用了字符串来替代一维数组, 直接拼接保存该行<a id=\"more\"></a>\n\n</li>\n</ol>\n<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">convert</span><span class=\"params\">(String s, <span class=\"keyword\">int</span> numRows)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s == <span class=\"keyword\">null</span> || s.length() &lt;= <span class=\"number\">0</span> || numRows &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        String[] arr = <span class=\"keyword\">new</span> String[numRows];</span><br><span class=\"line\">        Arrays.fill(arr,<span class=\"string\">\"\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> cycle = <span class=\"number\">2</span> * numRows - <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> position = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mod = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">char</span> c : s.toCharArray()) &#123;</span><br><span class=\"line\">            mod = position % cycle;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mod &lt; numRows) &#123;</span><br><span class=\"line\">                arr[mod] += c;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                arr[cycle - mod] += c;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            position++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        StringBuilder re = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(String line : arr) &#123;</span><br><span class=\"line\">            re.append(line);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> re.toString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h3 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h3><p><a href=\"https://leetcode.com/problems/zigzag-conversion/submissions/\" target=\"_blank\" rel=\"noopener\">LeetCode 6. ZigZag Conversion</a></p>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><ol>\n<li>最开始想的就是一个二维数组, 它把原字符串, 按照规律放入固定位置, 最后再拼接</li>\n<li>那么又分为两个问题<ul>\n<li>二维数组要考虑越界和合并判断问题</li>\n<li>这个Z(明明是N!)的规律是什么</li>\n</ul>\n</li>\n<li>关于Z的规律只能说, 在纸上画一下2行,3行的情况, 发现规律是<code>2n-2</code>个字母为一个循环周期, 再拿4行验证一下</li>\n<li>另外选用了字符串来替代一维数组, 直接拼接保存该行","more":"</li>\n</ol>\n<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">convert</span><span class=\"params\">(String s, <span class=\"keyword\">int</span> numRows)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s == <span class=\"keyword\">null</span> || s.length() &lt;= <span class=\"number\">0</span> || numRows &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        String[] arr = <span class=\"keyword\">new</span> String[numRows];</span><br><span class=\"line\">        Arrays.fill(arr,<span class=\"string\">\"\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> cycle = <span class=\"number\">2</span> * numRows - <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> position = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mod = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">char</span> c : s.toCharArray()) &#123;</span><br><span class=\"line\">            mod = position % cycle;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mod &lt; numRows) &#123;</span><br><span class=\"line\">                arr[mod] += c;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                arr[cycle - mod] += c;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            position++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        StringBuilder re = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(String line : arr) &#123;</span><br><span class=\"line\">            re.append(line);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> re.toString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode 876. Middle of the Linked List","date":"2020-06-23T13:51:37.000Z","_content":"### 题目: \n\n[LeetCode 876. Middle of the Linked List](https://leetcode.com/problems/middle-of-the-linked-list/)\n\n### 思路:\n\n刷到这个题的时候, 因为之前做过快慢指针[判断链表中是否存在环](https://blog.lixuemin.com/2019/06/20/LeetCode%E7%BB%83%E4%B9%A0-Linked-List-Cycle/)的问题.<br/>\n最先想到的解法就是: \n<b>因为快指针的速度是慢指针的一倍, 所以当快指针走到尾结点的时候, 慢指针恰好走到中间.</b>\n<!--more-->\n<br>\n需要注意的就是中间结点的判断:\n1. 假如<code>fast.next == null</code>, 代表链表结点的个数是偶数, 此时<code>slow</code>处在中间位置偏左, 因为题目要求取偏右的, 所以返回<code>slow.next</code>\n<br/> eg: [1, 2, 3, 4, 5, 6], 最终<code>fast = 6</code>,而<code>slow = 3</code>, 故需要返回<code>slow.next</code>即<code>4</code>\n<br/>\n2. 假如<code>fast.next != null && fast.next.next == null</code>, 代表链表结点数为奇数, 此时<code>fast</code>是尾结点的前驱结点, <code>slow</code>是中间结点的前驱结点, 故返回<code>slow.next</code>\n\n### 代码实现: \n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode middleNode(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        ListNode slow = head;\n        ListNode fast = head.next;\n        while (true) {\n            if (fast.next == null || fast.next.next == null) {\n                return slow.next;\n            }\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        \n    }\n}\n```","source":"_posts/algorithm/LeetCode 876. Middle of the Linked List.md","raw":"---\ntitle: LeetCode 876. Middle of the Linked List\ndate: 2020-06-23 21:51:37\ncategories: 算法日常练习\ntags:\n- 数据结构与算法\n- 链表\n- 双指针\n---\n### 题目: \n\n[LeetCode 876. Middle of the Linked List](https://leetcode.com/problems/middle-of-the-linked-list/)\n\n### 思路:\n\n刷到这个题的时候, 因为之前做过快慢指针[判断链表中是否存在环](https://blog.lixuemin.com/2019/06/20/LeetCode%E7%BB%83%E4%B9%A0-Linked-List-Cycle/)的问题.<br/>\n最先想到的解法就是: \n<b>因为快指针的速度是慢指针的一倍, 所以当快指针走到尾结点的时候, 慢指针恰好走到中间.</b>\n<!--more-->\n<br>\n需要注意的就是中间结点的判断:\n1. 假如<code>fast.next == null</code>, 代表链表结点的个数是偶数, 此时<code>slow</code>处在中间位置偏左, 因为题目要求取偏右的, 所以返回<code>slow.next</code>\n<br/> eg: [1, 2, 3, 4, 5, 6], 最终<code>fast = 6</code>,而<code>slow = 3</code>, 故需要返回<code>slow.next</code>即<code>4</code>\n<br/>\n2. 假如<code>fast.next != null && fast.next.next == null</code>, 代表链表结点数为奇数, 此时<code>fast</code>是尾结点的前驱结点, <code>slow</code>是中间结点的前驱结点, 故返回<code>slow.next</code>\n\n### 代码实现: \n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode middleNode(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        ListNode slow = head;\n        ListNode fast = head.next;\n        while (true) {\n            if (fast.next == null || fast.next.next == null) {\n                return slow.next;\n            }\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        \n    }\n}\n```","slug":"algorithm/LeetCode 876. Middle of the Linked List","published":1,"updated":"2020-10-27T08:08:15.925Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckio9dwdh0011k8neubpx14wq","content":"<h3 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目:\"></a>题目:</h3><p><a href=\"https://leetcode.com/problems/middle-of-the-linked-list/\" target=\"_blank\" rel=\"noopener\">LeetCode 876. Middle of the Linked List</a></p>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路:\"></a>思路:</h3><p>刷到这个题的时候, 因为之前做过快慢指针<a href=\"https://blog.lixuemin.com/2019/06/20/LeetCode%E7%BB%83%E4%B9%A0-Linked-List-Cycle/\" target=\"_blank\" rel=\"noopener\">判断链表中是否存在环</a>的问题.<br><br>最先想到的解法就是:<br><b>因为快指针的速度是慢指针的一倍, 所以当快指针走到尾结点的时候, 慢指针恰好走到中间.</b></p>\n<a id=\"more\"></a>\n<br>\n需要注意的就是中间结点的判断:\n1. 假如<code>fast.next == null</code>, 代表链表结点的个数是偶数, 此时<code>slow</code>处在中间位置偏左, 因为题目要求取偏右的, 所以返回<code>slow.next</code>\n<br> eg: [1, 2, 3, 4, 5, 6], 最终<code>fast = 6</code>,而<code>slow = 3</code>, 故需要返回<code>slow.next</code>即<code>4</code>\n<br>\n2. 假如<code>fast.next != null && fast.next.next == null</code>, 代表链表结点数为奇数, 此时<code>fast</code>是尾结点的前驱结点, <code>slow</code>是中间结点的前驱结点, 故返回<code>slow.next</code>\n\n<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现:\"></a>代码实现:</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">middleNode</span><span class=\"params\">(ListNode head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (head == <span class=\"keyword\">null</span> || head.next == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ListNode slow = head;</span><br><span class=\"line\">        ListNode fast = head.next;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (fast.next == <span class=\"keyword\">null</span> || fast.next.next == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> slow.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            slow = slow.next;</span><br><span class=\"line\">            fast = fast.next.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h3 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目:\"></a>题目:</h3><p><a href=\"https://leetcode.com/problems/middle-of-the-linked-list/\" target=\"_blank\" rel=\"noopener\">LeetCode 876. Middle of the Linked List</a></p>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路:\"></a>思路:</h3><p>刷到这个题的时候, 因为之前做过快慢指针<a href=\"https://blog.lixuemin.com/2019/06/20/LeetCode%E7%BB%83%E4%B9%A0-Linked-List-Cycle/\" target=\"_blank\" rel=\"noopener\">判断链表中是否存在环</a>的问题.<br><br>最先想到的解法就是:<br><b>因为快指针的速度是慢指针的一倍, 所以当快指针走到尾结点的时候, 慢指针恰好走到中间.</b></p>","more":"<br>\n需要注意的就是中间结点的判断:\n1. 假如<code>fast.next == null</code>, 代表链表结点的个数是偶数, 此时<code>slow</code>处在中间位置偏左, 因为题目要求取偏右的, 所以返回<code>slow.next</code>\n<br> eg: [1, 2, 3, 4, 5, 6], 最终<code>fast = 6</code>,而<code>slow = 3</code>, 故需要返回<code>slow.next</code>即<code>4</code>\n<br>\n2. 假如<code>fast.next != null && fast.next.next == null</code>, 代表链表结点数为奇数, 此时<code>fast</code>是尾结点的前驱结点, <code>slow</code>是中间结点的前驱结点, 故返回<code>slow.next</code>\n\n<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现:\"></a>代码实现:</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">middleNode</span><span class=\"params\">(ListNode head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (head == <span class=\"keyword\">null</span> || head.next == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ListNode slow = head;</span><br><span class=\"line\">        ListNode fast = head.next;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (fast.next == <span class=\"keyword\">null</span> || fast.next.next == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> slow.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            slow = slow.next;</span><br><span class=\"line\">            fast = fast.next.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode 104. 二叉树的最大深度","date":"2020-07-24T08:16:40.000Z","_content":"\n### 题目\n\n[LeetCode 104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)\n\n### 思路\n\n思路一: 广度优先搜索, 层层遍历\n思路二: 递归算法, 比较最大值\n\n<!--more-->\n### 代码实现\n\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        int depth = 0;\n        if (root == null) {\n            return depth;\n        }\n        List<TreeNode> line = new ArrayList<>();\n        List<TreeNode> temp;\n        line.add(root);\n        while (!line.isEmpty()) {\n            temp = new ArrayList<>();\n            for (TreeNode node : line) {\n                if (node.left != null) {\n                    temp.add(node.left);\n                }\n                if (node.right != null) {\n                    temp.add(node.right);\n                }\n            }\n            line = temp;\n            depth++;\n        }\n        return depth;\n    }\n}\n```\n\n递归解法:\n\n```java\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        int leftDepth = maxDepth(root.left);\n        int rightDepth = maxDepth(root.right);\n        return Math.max(leftDepth, rightDepth) + 1;\n    }\n}\n```","source":"_posts/algorithm/LeetCode-104-二叉树的最大深度.md","raw":"---\ntitle: LeetCode 104. 二叉树的最大深度\ndate: 2020-07-24 16:16:40\ncategories: 算法日常练习\ntags:\n- 数据结构与算法\n- 二叉树\n---\n\n### 题目\n\n[LeetCode 104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)\n\n### 思路\n\n思路一: 广度优先搜索, 层层遍历\n思路二: 递归算法, 比较最大值\n\n<!--more-->\n### 代码实现\n\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        int depth = 0;\n        if (root == null) {\n            return depth;\n        }\n        List<TreeNode> line = new ArrayList<>();\n        List<TreeNode> temp;\n        line.add(root);\n        while (!line.isEmpty()) {\n            temp = new ArrayList<>();\n            for (TreeNode node : line) {\n                if (node.left != null) {\n                    temp.add(node.left);\n                }\n                if (node.right != null) {\n                    temp.add(node.right);\n                }\n            }\n            line = temp;\n            depth++;\n        }\n        return depth;\n    }\n}\n```\n\n递归解法:\n\n```java\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        int leftDepth = maxDepth(root.left);\n        int rightDepth = maxDepth(root.right);\n        return Math.max(leftDepth, rightDepth) + 1;\n    }\n}\n```","slug":"algorithm/LeetCode-104-二叉树的最大深度","published":1,"updated":"2020-10-27T08:08:15.926Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckio9dwdi0014k8nei26tugka","content":"<h3 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h3><p><a href=\"https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/\" target=\"_blank\" rel=\"noopener\">LeetCode 104. 二叉树的最大深度</a></p>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>思路一: 广度优先搜索, 层层遍历<br>思路二: 递归算法, 比较最大值</p>\n<a id=\"more\"></a>\n<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">maxDepth</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> depth = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> depth;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        List&lt;TreeNode&gt; line = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        List&lt;TreeNode&gt; temp;</span><br><span class=\"line\">        line.add(root);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!line.isEmpty()) &#123;</span><br><span class=\"line\">            temp = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (TreeNode node : line) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (node.left != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    temp.add(node.left);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (node.right != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    temp.add(node.right);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            line = temp;</span><br><span class=\"line\">            depth++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> depth;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>递归解法:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">maxDepth</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> leftDepth = maxDepth(root.left);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> rightDepth = maxDepth(root.right);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Math.max(leftDepth, rightDepth) + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h3 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h3><p><a href=\"https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/\" target=\"_blank\" rel=\"noopener\">LeetCode 104. 二叉树的最大深度</a></p>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>思路一: 广度优先搜索, 层层遍历<br>思路二: 递归算法, 比较最大值</p>","more":"<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">maxDepth</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> depth = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> depth;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        List&lt;TreeNode&gt; line = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        List&lt;TreeNode&gt; temp;</span><br><span class=\"line\">        line.add(root);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!line.isEmpty()) &#123;</span><br><span class=\"line\">            temp = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (TreeNode node : line) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (node.left != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    temp.add(node.left);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (node.right != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    temp.add(node.right);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            line = temp;</span><br><span class=\"line\">            depth++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> depth;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>递归解法:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">maxDepth</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> leftDepth = maxDepth(root.left);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> rightDepth = maxDepth(root.right);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Math.max(leftDepth, rightDepth) + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode 102. 二叉树的层序遍历","date":"2020-07-23T14:07:05.000Z","_content":"\n### 题目\n\n[LeetCode 102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)\n\n### 思路\n\n这个实现还是挺简单的, 就是注意下每层迭代的时候, 数组要先清空.\n<!--more-->\n### 代码实现\n\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public List<List<Integer>> levelOrder(TreeNode root) {\n        List<List<Integer>> list = new ArrayList<List<Integer>>();\n        if (root == null) {\n            return list;\n        }\n        List<TreeNode> nodeList = new LinkedList<>();\n        List<TreeNode> temp;\n        List<Integer> line;\n        nodeList.add(root);\n        while(!nodeList.isEmpty()) {\n            temp = new LinkedList<>();\n            line = new LinkedList<>();\n            for (TreeNode node : nodeList) {\n                line.add(node.val);\n                if (node.left != null) {\n                    temp.add(node.left);\n                }\n                if (node.right != null) {\n                    temp.add(node.right);\n                }\n            }\n            nodeList = temp;\n            list.add(line);\n        }\n        return list;\n    }\n}\n```\n","source":"_posts/algorithm/LeetCode-102-二叉树的层序遍历.md","raw":"---\ntitle: LeetCode 102. 二叉树的层序遍历\ndate: 2020-07-23 22:07:05\ncategories: 算法日常练习\ntags:\n- 数据结构与算法\n- 二叉树\n---\n\n### 题目\n\n[LeetCode 102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)\n\n### 思路\n\n这个实现还是挺简单的, 就是注意下每层迭代的时候, 数组要先清空.\n<!--more-->\n### 代码实现\n\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public List<List<Integer>> levelOrder(TreeNode root) {\n        List<List<Integer>> list = new ArrayList<List<Integer>>();\n        if (root == null) {\n            return list;\n        }\n        List<TreeNode> nodeList = new LinkedList<>();\n        List<TreeNode> temp;\n        List<Integer> line;\n        nodeList.add(root);\n        while(!nodeList.isEmpty()) {\n            temp = new LinkedList<>();\n            line = new LinkedList<>();\n            for (TreeNode node : nodeList) {\n                line.add(node.val);\n                if (node.left != null) {\n                    temp.add(node.left);\n                }\n                if (node.right != null) {\n                    temp.add(node.right);\n                }\n            }\n            nodeList = temp;\n            list.add(line);\n        }\n        return list;\n    }\n}\n```\n","slug":"algorithm/LeetCode-102-二叉树的层序遍历","published":1,"updated":"2020-10-27T08:08:15.925Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckio9dwdk0018k8ne5zw3zfhk","content":"<h3 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h3><p><a href=\"https://leetcode-cn.com/problems/binary-tree-level-order-traversal/\" target=\"_blank\" rel=\"noopener\">LeetCode 102. 二叉树的层序遍历</a></p>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>这个实现还是挺简单的, 就是注意下每层迭代的时候, 数组要先清空.</p>\n<a id=\"more\"></a>\n<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        List&lt;TreeNode&gt; nodeList = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">        List&lt;TreeNode&gt; temp;</span><br><span class=\"line\">        List&lt;Integer&gt; line;</span><br><span class=\"line\">        nodeList.add(root);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!nodeList.isEmpty()) &#123;</span><br><span class=\"line\">            temp = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">            line = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (TreeNode node : nodeList) &#123;</span><br><span class=\"line\">                line.add(node.val);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (node.left != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    temp.add(node.left);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (node.right != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    temp.add(node.right);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            nodeList = temp;</span><br><span class=\"line\">            list.add(line);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<h3 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h3><p><a href=\"https://leetcode-cn.com/problems/binary-tree-level-order-traversal/\" target=\"_blank\" rel=\"noopener\">LeetCode 102. 二叉树的层序遍历</a></p>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>这个实现还是挺简单的, 就是注意下每层迭代的时候, 数组要先清空.</p>","more":"<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        List&lt;TreeNode&gt; nodeList = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">        List&lt;TreeNode&gt; temp;</span><br><span class=\"line\">        List&lt;Integer&gt; line;</span><br><span class=\"line\">        nodeList.add(root);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!nodeList.isEmpty()) &#123;</span><br><span class=\"line\">            temp = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">            line = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (TreeNode node : nodeList) &#123;</span><br><span class=\"line\">                line.add(node.val);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (node.left != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    temp.add(node.left);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (node.right != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    temp.add(node.right);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            nodeList = temp;</span><br><span class=\"line\">            list.add(line);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode 101. 对称二叉树","date":"2020-07-25T05:31:35.000Z","_content":"\n### 题目\n\n[LeetCode 101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)\n\n### 思路\n\n思路一: 广度优先搜索\n\n1. 分成两个链表, 分别按顺序存储根节点的左右子树的每一层节点\n2. 两个链表进行比较, 一个顺序, 一个逆序取出元素, 进行比较\n3. 要注意不完全二叉树的null值\n\n思路二: 递归\n\n1. 递归过程:\n\n* 判断当前两个节点的值是否相等\n* 判断左子树的右节点, 与右子树的左节点, 是否对称\n* 判断左子树的左节点, 与右子树的右节点, 是否堆成\n\n2.递归终止条件:\n\n* 两个节点都为`null` 返回`true`\n* 只有一个节点为`null`返回`false`\n\n<!--more-->\n### 代码实现\n\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public boolean isSymmetric(TreeNode root) {\n        if (root == null || (root.left == null && root.right == null)) {\n            return true;\n        }\n        LinkedList<TreeNode> leftLine = new LinkedList<>();\n        LinkedList<TreeNode> rightLine = new LinkedList<>();\n        leftLine.add(root.left);\n        rightLine.add(root.right);\n        while (!leftLine.isEmpty() || !rightLine.isEmpty()) {\n            if (!isTwoListEqual(leftLine, rightLine)) {\n                return false;\n            }\n            leftLine = getChildren(leftLine);\n            rightLine = getChildren(rightLine);\n        }\n        return true;\n    }\n\n    private boolean isTwoListEqual(LinkedList<TreeNode> left, LinkedList<TreeNode> right) {\n        if (left.size() != right.size()) {\n            return false;\n        }\n        TreeNode leftNode = null;\n        TreeNode rightNode = null;\n        for (int i = 0; i < left.size(); i++){\n            leftNode = left.get(i);\n            rightNode = right.get(left.size() - i - 1);\n            if (leftNode == null && rightNode == null) {\n                continue;\n            }\n            if (leftNode == null || rightNode == null) {\n                return false;\n            }\n            if (leftNode.val != rightNode.val) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private LinkedList<TreeNode> getChildren(LinkedList<TreeNode> list) {\n        LinkedList<TreeNode> temp = new LinkedList<>();\n        for (TreeNode node : list) {\n            if (node == null){\n                continue;\n            }\n            temp.add(node.left);\n            temp.add(node.right);\n        }\n        return temp;\n    }\n}\n```\n\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public boolean isSymmetric(TreeNode root) {\n        if (root == null) {\n            return true;\n        }\n        return isSymmetric(root.left, root.right);\n    }\n    public boolean isSymmetric(TreeNode leftTree, TreeNode rightTree) {\n        if (leftTree == null && rightTree == null) {\n            return true;\n        }\n        if (leftTree == null || rightTree == null) {\n            return false;\n        }\n        return (leftTree.val == rightTree.val)\n        && isSymmetric(leftTree.left, rightTree.right)\n        && isSymmetric(leftTree.right, rightTree.left);\n    }\n}\n```\n","source":"_posts/algorithm/LeetCode-101-对称二叉树.md","raw":"---\ntitle: LeetCode 101. 对称二叉树\ndate: 2020-07-25 13:31:35\ncategories: 算法日常练习\ntags:\n- 数据结构与算法\n- 二叉树\n---\n\n### 题目\n\n[LeetCode 101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)\n\n### 思路\n\n思路一: 广度优先搜索\n\n1. 分成两个链表, 分别按顺序存储根节点的左右子树的每一层节点\n2. 两个链表进行比较, 一个顺序, 一个逆序取出元素, 进行比较\n3. 要注意不完全二叉树的null值\n\n思路二: 递归\n\n1. 递归过程:\n\n* 判断当前两个节点的值是否相等\n* 判断左子树的右节点, 与右子树的左节点, 是否对称\n* 判断左子树的左节点, 与右子树的右节点, 是否堆成\n\n2.递归终止条件:\n\n* 两个节点都为`null` 返回`true`\n* 只有一个节点为`null`返回`false`\n\n<!--more-->\n### 代码实现\n\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public boolean isSymmetric(TreeNode root) {\n        if (root == null || (root.left == null && root.right == null)) {\n            return true;\n        }\n        LinkedList<TreeNode> leftLine = new LinkedList<>();\n        LinkedList<TreeNode> rightLine = new LinkedList<>();\n        leftLine.add(root.left);\n        rightLine.add(root.right);\n        while (!leftLine.isEmpty() || !rightLine.isEmpty()) {\n            if (!isTwoListEqual(leftLine, rightLine)) {\n                return false;\n            }\n            leftLine = getChildren(leftLine);\n            rightLine = getChildren(rightLine);\n        }\n        return true;\n    }\n\n    private boolean isTwoListEqual(LinkedList<TreeNode> left, LinkedList<TreeNode> right) {\n        if (left.size() != right.size()) {\n            return false;\n        }\n        TreeNode leftNode = null;\n        TreeNode rightNode = null;\n        for (int i = 0; i < left.size(); i++){\n            leftNode = left.get(i);\n            rightNode = right.get(left.size() - i - 1);\n            if (leftNode == null && rightNode == null) {\n                continue;\n            }\n            if (leftNode == null || rightNode == null) {\n                return false;\n            }\n            if (leftNode.val != rightNode.val) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private LinkedList<TreeNode> getChildren(LinkedList<TreeNode> list) {\n        LinkedList<TreeNode> temp = new LinkedList<>();\n        for (TreeNode node : list) {\n            if (node == null){\n                continue;\n            }\n            temp.add(node.left);\n            temp.add(node.right);\n        }\n        return temp;\n    }\n}\n```\n\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public boolean isSymmetric(TreeNode root) {\n        if (root == null) {\n            return true;\n        }\n        return isSymmetric(root.left, root.right);\n    }\n    public boolean isSymmetric(TreeNode leftTree, TreeNode rightTree) {\n        if (leftTree == null && rightTree == null) {\n            return true;\n        }\n        if (leftTree == null || rightTree == null) {\n            return false;\n        }\n        return (leftTree.val == rightTree.val)\n        && isSymmetric(leftTree.left, rightTree.right)\n        && isSymmetric(leftTree.right, rightTree.left);\n    }\n}\n```\n","slug":"algorithm/LeetCode-101-对称二叉树","published":1,"updated":"2020-10-27T08:08:15.925Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckio9dwdm001bk8necbribfqu","content":"<h3 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h3><p><a href=\"https://leetcode-cn.com/problems/symmetric-tree/\" target=\"_blank\" rel=\"noopener\">LeetCode 101. 对称二叉树</a></p>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>思路一: 广度优先搜索</p>\n<ol>\n<li>分成两个链表, 分别按顺序存储根节点的左右子树的每一层节点</li>\n<li>两个链表进行比较, 一个顺序, 一个逆序取出元素, 进行比较</li>\n<li>要注意不完全二叉树的null值</li>\n</ol>\n<p>思路二: 递归</p>\n<ol>\n<li>递归过程:</li>\n</ol>\n<ul>\n<li>判断当前两个节点的值是否相等</li>\n<li>判断左子树的右节点, 与右子树的左节点, 是否对称</li>\n<li>判断左子树的左节点, 与右子树的右节点, 是否堆成</li>\n</ul>\n<p>2.递归终止条件:</p>\n<ul>\n<li>两个节点都为<code>null</code> 返回<code>true</code></li>\n<li>只有一个节点为<code>null</code>返回<code>false</code></li>\n</ul>\n<a id=\"more\"></a>\n<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isSymmetric</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span> || (root.left == <span class=\"keyword\">null</span> &amp;&amp; root.right == <span class=\"keyword\">null</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        LinkedList&lt;TreeNode&gt; leftLine = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">        LinkedList&lt;TreeNode&gt; rightLine = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">        leftLine.add(root.left);</span><br><span class=\"line\">        rightLine.add(root.right);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!leftLine.isEmpty() || !rightLine.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!isTwoListEqual(leftLine, rightLine)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            leftLine = getChildren(leftLine);</span><br><span class=\"line\">            rightLine = getChildren(rightLine);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isTwoListEqual</span><span class=\"params\">(LinkedList&lt;TreeNode&gt; left, LinkedList&lt;TreeNode&gt; right)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left.size() != right.size()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        TreeNode leftNode = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        TreeNode rightNode = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; left.size(); i++)&#123;</span><br><span class=\"line\">            leftNode = left.get(i);</span><br><span class=\"line\">            rightNode = right.get(left.size() - i - <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (leftNode == <span class=\"keyword\">null</span> &amp;&amp; rightNode == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (leftNode == <span class=\"keyword\">null</span> || rightNode == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (leftNode.val != rightNode.val) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> LinkedList&lt;TreeNode&gt; <span class=\"title\">getChildren</span><span class=\"params\">(LinkedList&lt;TreeNode&gt; list)</span> </span>&#123;</span><br><span class=\"line\">        LinkedList&lt;TreeNode&gt; temp = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (TreeNode node : list) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (node == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            temp.add(node.left);</span><br><span class=\"line\">            temp.add(node.right);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> temp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isSymmetric</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> isSymmetric(root.left, root.right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isSymmetric</span><span class=\"params\">(TreeNode leftTree, TreeNode rightTree)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (leftTree == <span class=\"keyword\">null</span> &amp;&amp; rightTree == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (leftTree == <span class=\"keyword\">null</span> || rightTree == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (leftTree.val == rightTree.val)</span><br><span class=\"line\">        &amp;&amp; isSymmetric(leftTree.left, rightTree.right)</span><br><span class=\"line\">        &amp;&amp; isSymmetric(leftTree.right, rightTree.left);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<h3 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h3><p><a href=\"https://leetcode-cn.com/problems/symmetric-tree/\" target=\"_blank\" rel=\"noopener\">LeetCode 101. 对称二叉树</a></p>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>思路一: 广度优先搜索</p>\n<ol>\n<li>分成两个链表, 分别按顺序存储根节点的左右子树的每一层节点</li>\n<li>两个链表进行比较, 一个顺序, 一个逆序取出元素, 进行比较</li>\n<li>要注意不完全二叉树的null值</li>\n</ol>\n<p>思路二: 递归</p>\n<ol>\n<li>递归过程:</li>\n</ol>\n<ul>\n<li>判断当前两个节点的值是否相等</li>\n<li>判断左子树的右节点, 与右子树的左节点, 是否对称</li>\n<li>判断左子树的左节点, 与右子树的右节点, 是否堆成</li>\n</ul>\n<p>2.递归终止条件:</p>\n<ul>\n<li>两个节点都为<code>null</code> 返回<code>true</code></li>\n<li>只有一个节点为<code>null</code>返回<code>false</code></li>\n</ul>","more":"<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isSymmetric</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span> || (root.left == <span class=\"keyword\">null</span> &amp;&amp; root.right == <span class=\"keyword\">null</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        LinkedList&lt;TreeNode&gt; leftLine = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">        LinkedList&lt;TreeNode&gt; rightLine = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">        leftLine.add(root.left);</span><br><span class=\"line\">        rightLine.add(root.right);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!leftLine.isEmpty() || !rightLine.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!isTwoListEqual(leftLine, rightLine)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            leftLine = getChildren(leftLine);</span><br><span class=\"line\">            rightLine = getChildren(rightLine);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isTwoListEqual</span><span class=\"params\">(LinkedList&lt;TreeNode&gt; left, LinkedList&lt;TreeNode&gt; right)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left.size() != right.size()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        TreeNode leftNode = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        TreeNode rightNode = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; left.size(); i++)&#123;</span><br><span class=\"line\">            leftNode = left.get(i);</span><br><span class=\"line\">            rightNode = right.get(left.size() - i - <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (leftNode == <span class=\"keyword\">null</span> &amp;&amp; rightNode == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (leftNode == <span class=\"keyword\">null</span> || rightNode == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (leftNode.val != rightNode.val) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> LinkedList&lt;TreeNode&gt; <span class=\"title\">getChildren</span><span class=\"params\">(LinkedList&lt;TreeNode&gt; list)</span> </span>&#123;</span><br><span class=\"line\">        LinkedList&lt;TreeNode&gt; temp = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (TreeNode node : list) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (node == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            temp.add(node.left);</span><br><span class=\"line\">            temp.add(node.right);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> temp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isSymmetric</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> isSymmetric(root.left, root.right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isSymmetric</span><span class=\"params\">(TreeNode leftTree, TreeNode rightTree)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (leftTree == <span class=\"keyword\">null</span> &amp;&amp; rightTree == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (leftTree == <span class=\"keyword\">null</span> || rightTree == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (leftTree.val == rightTree.val)</span><br><span class=\"line\">        &amp;&amp; isSymmetric(leftTree.left, rightTree.right)</span><br><span class=\"line\">        &amp;&amp; isSymmetric(leftTree.right, rightTree.left);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode 112. 路径总和","date":"2020-07-26T06:09:47.000Z","_content":"\n### 题目\n\n[LeetCode 112. 路径总和](https://leetcode-cn.com/problems/path-sum/)\n\n### 思路\n\n这道题, 递归和广度优先都可以, 关键在于迭代的时候, 可以通过传递sum与节点值的`差值`来得到结果. \n\n当`差值`为`0`, 代表确实存在这样一条路径. \n\n如果使用额外的数据结构存储每条路径的和, 反而会极大增加代码复杂度.\n<!--more-->\n### 代码实现\n\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public boolean hasPathSum(TreeNode root, int sum) {\n        return hasPath(root, sum);\n    }\n\n    private boolean hasPath(TreeNode node, int sum) {\n        if (node == null) {\n            return false;\n        }\n        int result = sum - node.val;\n        if (result == 0 && node.left == null && node.right == null) {\n            return true;\n        }\n        return hasPath(node.left, result) || hasPath(node.right, result);\n    }\n}\n```\n","source":"_posts/algorithm/LeetCode-112-路径总和.md","raw":"---\ntitle: LeetCode 112. 路径总和\ndate: 2020-07-26 14:09:47\ncategories: 算法日常练习\ntags:\n- 数据结构与算法\n- 二叉树\n---\n\n### 题目\n\n[LeetCode 112. 路径总和](https://leetcode-cn.com/problems/path-sum/)\n\n### 思路\n\n这道题, 递归和广度优先都可以, 关键在于迭代的时候, 可以通过传递sum与节点值的`差值`来得到结果. \n\n当`差值`为`0`, 代表确实存在这样一条路径. \n\n如果使用额外的数据结构存储每条路径的和, 反而会极大增加代码复杂度.\n<!--more-->\n### 代码实现\n\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public boolean hasPathSum(TreeNode root, int sum) {\n        return hasPath(root, sum);\n    }\n\n    private boolean hasPath(TreeNode node, int sum) {\n        if (node == null) {\n            return false;\n        }\n        int result = sum - node.val;\n        if (result == 0 && node.left == null && node.right == null) {\n            return true;\n        }\n        return hasPath(node.left, result) || hasPath(node.right, result);\n    }\n}\n```\n","slug":"algorithm/LeetCode-112-路径总和","published":1,"updated":"2020-10-27T08:08:15.926Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckio9dwdo001fk8nebhmn7brz","content":"<h3 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h3><p><a href=\"https://leetcode-cn.com/problems/path-sum/\" target=\"_blank\" rel=\"noopener\">LeetCode 112. 路径总和</a></p>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>这道题, 递归和广度优先都可以, 关键在于迭代的时候, 可以通过传递sum与节点值的<code>差值</code>来得到结果. </p>\n<p>当<code>差值</code>为<code>0</code>, 代表确实存在这样一条路径. </p>\n<p>如果使用额外的数据结构存储每条路径的和, 反而会极大增加代码复杂度.</p>\n<a id=\"more\"></a>\n<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasPathSum</span><span class=\"params\">(TreeNode root, <span class=\"keyword\">int</span> sum)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> hasPath(root, sum);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasPath</span><span class=\"params\">(TreeNode node, <span class=\"keyword\">int</span> sum)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> result = sum - node.val;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (result == <span class=\"number\">0</span> &amp;&amp; node.left == <span class=\"keyword\">null</span> &amp;&amp; node.right == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> hasPath(node.left, result) || hasPath(node.right, result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<h3 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h3><p><a href=\"https://leetcode-cn.com/problems/path-sum/\" target=\"_blank\" rel=\"noopener\">LeetCode 112. 路径总和</a></p>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>这道题, 递归和广度优先都可以, 关键在于迭代的时候, 可以通过传递sum与节点值的<code>差值</code>来得到结果. </p>\n<p>当<code>差值</code>为<code>0</code>, 代表确实存在这样一条路径. </p>\n<p>如果使用额外的数据结构存储每条路径的和, 反而会极大增加代码复杂度.</p>","more":"<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasPathSum</span><span class=\"params\">(TreeNode root, <span class=\"keyword\">int</span> sum)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> hasPath(root, sum);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasPath</span><span class=\"params\">(TreeNode node, <span class=\"keyword\">int</span> sum)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> result = sum - node.val;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (result == <span class=\"number\">0</span> &amp;&amp; node.left == <span class=\"keyword\">null</span> &amp;&amp; node.right == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> hasPath(node.left, result) || hasPath(node.right, result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode 144. 二叉树的前序遍历","date":"2020-07-23T14:06:02.000Z","_content":"\n### 题目\n\n[LeetCode 144. 二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)\n\n### 思路\n\n前序遍历是按照`根-左-右`的顺序.\n\n从根节点开始, 每次迭代弹出栈顶元素, 并将其孩子节点压入栈中, 先压入右孩子再压入左孩子.\n<!--more-->\n\n### 代码实现\n\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public List<Integer> preorderTraversal(TreeNode node) {\n        List<Integer> list = new LinkedList<Integer>();\n        if (node == null) {\n            return list;\n        }\n\t    Stack<TreeNode> stack = new Stack<>();\n        stack.push(node);\n        while (!stack.isEmpty()) {\n            node = stack.pop();\n            list.add(node.val);\n            if (node.right != null){\n                stack.push(node.right);\n            }\n            if (node.left != null) {\n                stack.push(node.left);\n            }\n        }\n        return list;\n    }\n}\n```","source":"_posts/algorithm/LeetCode-144-二叉树的前序遍历.md","raw":"---\ntitle: LeetCode 144. 二叉树的前序遍历\ndate: 2020-07-23 22:06:02\ncategories: 算法日常练习\ntags:\n- 数据结构与算法\n- 二叉树\n---\n\n### 题目\n\n[LeetCode 144. 二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)\n\n### 思路\n\n前序遍历是按照`根-左-右`的顺序.\n\n从根节点开始, 每次迭代弹出栈顶元素, 并将其孩子节点压入栈中, 先压入右孩子再压入左孩子.\n<!--more-->\n\n### 代码实现\n\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public List<Integer> preorderTraversal(TreeNode node) {\n        List<Integer> list = new LinkedList<Integer>();\n        if (node == null) {\n            return list;\n        }\n\t    Stack<TreeNode> stack = new Stack<>();\n        stack.push(node);\n        while (!stack.isEmpty()) {\n            node = stack.pop();\n            list.add(node.val);\n            if (node.right != null){\n                stack.push(node.right);\n            }\n            if (node.left != null) {\n                stack.push(node.left);\n            }\n        }\n        return list;\n    }\n}\n```","slug":"algorithm/LeetCode-144-二叉树的前序遍历","published":1,"updated":"2020-10-27T08:08:15.927Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckio9dwdq001ik8ned5musc3o","content":"<h3 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h3><p><a href=\"https://leetcode-cn.com/problems/binary-tree-preorder-traversal/\" target=\"_blank\" rel=\"noopener\">LeetCode 144. 二叉树的前序遍历</a></p>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>前序遍历是按照<code>根-左-右</code>的顺序.</p>\n<p>从根节点开始, 每次迭代弹出栈顶元素, 并将其孩子节点压入栈中, 先压入右孩子再压入左孩子.</p>\n<a id=\"more\"></a>\n\n<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title\">preorderTraversal</span><span class=\"params\">(TreeNode node)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;Integer&gt; list = <span class=\"keyword\">new</span> LinkedList&lt;Integer&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t    Stack&lt;TreeNode&gt; stack = <span class=\"keyword\">new</span> Stack&lt;&gt;();</span><br><span class=\"line\">        stack.push(node);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!stack.isEmpty()) &#123;</span><br><span class=\"line\">            node = stack.pop();</span><br><span class=\"line\">            list.add(node.val);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (node.right != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">                stack.push(node.right);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (node.left != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                stack.push(node.left);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h3 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h3><p><a href=\"https://leetcode-cn.com/problems/binary-tree-preorder-traversal/\" target=\"_blank\" rel=\"noopener\">LeetCode 144. 二叉树的前序遍历</a></p>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>前序遍历是按照<code>根-左-右</code>的顺序.</p>\n<p>从根节点开始, 每次迭代弹出栈顶元素, 并将其孩子节点压入栈中, 先压入右孩子再压入左孩子.</p>","more":"<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title\">preorderTraversal</span><span class=\"params\">(TreeNode node)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;Integer&gt; list = <span class=\"keyword\">new</span> LinkedList&lt;Integer&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t    Stack&lt;TreeNode&gt; stack = <span class=\"keyword\">new</span> Stack&lt;&gt;();</span><br><span class=\"line\">        stack.push(node);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!stack.isEmpty()) &#123;</span><br><span class=\"line\">            node = stack.pop();</span><br><span class=\"line\">            list.add(node.val);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (node.right != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">                stack.push(node.right);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (node.left != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                stack.push(node.left);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode 53. 最大子序和","date":"2020-07-22T08:10:22.000Z","_content":"\n### 题目\n\n[LeetCode 53. 最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)\n\n### 思路\n\n* 对数组进行遍历，当前最大连续子序列和为 sum，缓存结果为 ans\n* 如果 sum > 0，则说明 sum 结果是好的, 累加当前遍历的值\n* 如果 sum <= 0，则sum结果是坏的, 需要舍弃，则 sum 直接更新为当前遍历的值\n* 每次比较 sum 和 ans的大小，将最大值置为ans，遍历结束返回结果\n<!--more-->\n### 代码实现\n\n```java\nclass Solution {\n    public int maxSubArray(int[] nums) {\n        if(nums == null || nums.length == 0) {\n            return 0;\n        }\n        if (nums.length == 1) {\n            return nums[0];\n        }\n\n        int sum = 0;\n        int ans = nums[0];\n        \n        for (int n : nums) {\n            if (sum <= 0) {\n                sum = n;\n            }else {\n                sum += n;\n            }\n            ans = Math.max(sum, ans);\n        }\n        return ans;\n    }\n}\n```","source":"_posts/algorithm/LeetCode-53-最大子序和.md","raw":"---\ntitle: LeetCode 53. 最大子序和\ndate: 2020-07-22 16:10:22\ncategories: 算法日常练习\ntags:\n- 数据结构与算法\n- 动态规划\n---\n\n### 题目\n\n[LeetCode 53. 最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)\n\n### 思路\n\n* 对数组进行遍历，当前最大连续子序列和为 sum，缓存结果为 ans\n* 如果 sum > 0，则说明 sum 结果是好的, 累加当前遍历的值\n* 如果 sum <= 0，则sum结果是坏的, 需要舍弃，则 sum 直接更新为当前遍历的值\n* 每次比较 sum 和 ans的大小，将最大值置为ans，遍历结束返回结果\n<!--more-->\n### 代码实现\n\n```java\nclass Solution {\n    public int maxSubArray(int[] nums) {\n        if(nums == null || nums.length == 0) {\n            return 0;\n        }\n        if (nums.length == 1) {\n            return nums[0];\n        }\n\n        int sum = 0;\n        int ans = nums[0];\n        \n        for (int n : nums) {\n            if (sum <= 0) {\n                sum = n;\n            }else {\n                sum += n;\n            }\n            ans = Math.max(sum, ans);\n        }\n        return ans;\n    }\n}\n```","slug":"algorithm/LeetCode-53-最大子序和","published":1,"updated":"2020-10-27T08:08:15.928Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckio9dwds001mk8ne0ilej18t","content":"<h3 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h3><p><a href=\"https://leetcode-cn.com/problems/maximum-subarray/\" target=\"_blank\" rel=\"noopener\">LeetCode 53. 最大子序和</a></p>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><ul>\n<li>对数组进行遍历，当前最大连续子序列和为 sum，缓存结果为 ans</li>\n<li>如果 sum &gt; 0，则说明 sum 结果是好的, 累加当前遍历的值</li>\n<li>如果 sum &lt;= 0，则sum结果是坏的, 需要舍弃，则 sum 直接更新为当前遍历的值</li>\n<li>每次比较 sum 和 ans的大小，将最大值置为ans，遍历结束返回结果<a id=\"more\"></a>\n<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">maxSubArray</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums == <span class=\"keyword\">null</span> || nums.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums.length == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ans = nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> n : nums) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (sum &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                sum = n;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                sum += n;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ans = Math.max(sum, ans);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h3 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h3><p><a href=\"https://leetcode-cn.com/problems/maximum-subarray/\" target=\"_blank\" rel=\"noopener\">LeetCode 53. 最大子序和</a></p>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><ul>\n<li>对数组进行遍历，当前最大连续子序列和为 sum，缓存结果为 ans</li>\n<li>如果 sum &gt; 0，则说明 sum 结果是好的, 累加当前遍历的值</li>\n<li>如果 sum &lt;= 0，则sum结果是坏的, 需要舍弃，则 sum 直接更新为当前遍历的值</li>\n<li>每次比较 sum 和 ans的大小，将最大值置为ans，遍历结束返回结果","more":"<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">maxSubArray</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums == <span class=\"keyword\">null</span> || nums.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums.length == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ans = nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> n : nums) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (sum &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                sum = n;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                sum += n;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ans = Math.max(sum, ans);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode 94. 二叉树的中序遍历","date":"2020-07-23T14:06:29.000Z","_content":"\n### 题目\n\n[LeetCode 94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)\n\n### 思路\n\n中序遍历是按照`左-根-右`的顺序.\n\n1. 首先要找到左-左-左....的那个节点\n2. 打印后, 再判断它有没有右孩子, 若存在则继续迭代, 若无则打印当前节点\n3. 打印完毕再从栈中取出之前存入的节点\n<!--more-->\n\n### 代码实现\n\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public List<Integer> inorderTraversal(TreeNode root) {\n        List<Integer> list = new LinkedList<>();\n        if(root == null) {\n            return list;\n        }\n        Stack<TreeNode> stack = new Stack<>();\n        while (!stack.isEmpty() || root != null) {\n            while (root != null) {\n                stack.push(root);\n                root = root.left;\n            }\n            root = stack.pop();\n            list.add(root.val);\n            root = root.right;\n        }\n        return list;\n    }\n}\n```","source":"_posts/algorithm/LeetCode-94-二叉树的中序遍历.md","raw":"---\ntitle: LeetCode 94. 二叉树的中序遍历\ndate: 2020-07-23 22:06:29\ncategories: 算法日常练习\ntags:\n- 数据结构与算法\n- 二叉树\n---\n\n### 题目\n\n[LeetCode 94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)\n\n### 思路\n\n中序遍历是按照`左-根-右`的顺序.\n\n1. 首先要找到左-左-左....的那个节点\n2. 打印后, 再判断它有没有右孩子, 若存在则继续迭代, 若无则打印当前节点\n3. 打印完毕再从栈中取出之前存入的节点\n<!--more-->\n\n### 代码实现\n\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public List<Integer> inorderTraversal(TreeNode root) {\n        List<Integer> list = new LinkedList<>();\n        if(root == null) {\n            return list;\n        }\n        Stack<TreeNode> stack = new Stack<>();\n        while (!stack.isEmpty() || root != null) {\n            while (root != null) {\n                stack.push(root);\n                root = root.left;\n            }\n            root = stack.pop();\n            list.add(root.val);\n            root = root.right;\n        }\n        return list;\n    }\n}\n```","slug":"algorithm/LeetCode-94-二叉树的中序遍历","published":1,"updated":"2020-10-27T08:08:15.928Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckio9dwdu001pk8ne02m8dqp8","content":"<h3 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h3><p><a href=\"https://leetcode-cn.com/problems/binary-tree-inorder-traversal/\" target=\"_blank\" rel=\"noopener\">LeetCode 94. 二叉树的中序遍历</a></p>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>中序遍历是按照<code>左-根-右</code>的顺序.</p>\n<ol>\n<li>首先要找到左-左-左….的那个节点</li>\n<li>打印后, 再判断它有没有右孩子, 若存在则继续迭代, 若无则打印当前节点</li>\n<li>打印完毕再从栈中取出之前存入的节点<a id=\"more\"></a>\n\n</li>\n</ol>\n<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode() &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = val;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = left;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title\">inorderTraversal</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;Integer&gt; list = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Stack&lt;TreeNode&gt; stack = <span class=\"keyword\">new</span> Stack&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!stack.isEmpty() || root != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (root != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                stack.push(root);</span><br><span class=\"line\">                root = root.left;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            root = stack.pop();</span><br><span class=\"line\">            list.add(root.val);</span><br><span class=\"line\">            root = root.right;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h3 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h3><p><a href=\"https://leetcode-cn.com/problems/binary-tree-inorder-traversal/\" target=\"_blank\" rel=\"noopener\">LeetCode 94. 二叉树的中序遍历</a></p>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>中序遍历是按照<code>左-根-右</code>的顺序.</p>\n<ol>\n<li>首先要找到左-左-左….的那个节点</li>\n<li>打印后, 再判断它有没有右孩子, 若存在则继续迭代, 若无则打印当前节点</li>\n<li>打印完毕再从栈中取出之前存入的节点","more":"</li>\n</ol>\n<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode() &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = val;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = left;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title\">inorderTraversal</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;Integer&gt; list = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Stack&lt;TreeNode&gt; stack = <span class=\"keyword\">new</span> Stack&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!stack.isEmpty() || root != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (root != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                stack.push(root);</span><br><span class=\"line\">                root = root.left;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            root = stack.pop();</span><br><span class=\"line\">            list.add(root.val);</span><br><span class=\"line\">            root = root.right;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode 145. 二叉树的后序遍历","date":"2020-07-23T14:06:49.000Z","_content":"\n### 题目\n\n[LeetCode 145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)\n\n### 思路\n\n后序遍历是按照`左-右-根`的顺序.\n\n按照`根-左-右`的顺序将节点入栈, 出栈顺序则是后序遍历的值.\n<!--more-->\n### 代码实现\n\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public List<Integer> postorderTraversal(TreeNode root) {\n        LinkedList<Integer> list = new LinkedList<>();\n        if(root == null) {\n            return list;\n        }\n        Stack<TreeNode> stack = new Stack<>();\n        stack.push(root);\n        while (!stack.isEmpty()) {\n            root = stack.pop();\n            list.addFirst(root.val);\n            if (root.left != null) {\n                stack.add(root.left);\n            }\n            if (root.right != null) {\n                stack.add(root.right);\n            }\n        }\n        return list;\n    }\n}\n```\n","source":"_posts/algorithm/LeetCode-145-二叉树的后序遍历.md","raw":"---\ntitle: LeetCode 145. 二叉树的后序遍历\ndate: 2020-07-23 22:06:49\ncategories: 算法日常练习\ntags:\n- 数据结构与算法\n- 二叉树\n---\n\n### 题目\n\n[LeetCode 145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)\n\n### 思路\n\n后序遍历是按照`左-右-根`的顺序.\n\n按照`根-左-右`的顺序将节点入栈, 出栈顺序则是后序遍历的值.\n<!--more-->\n### 代码实现\n\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public List<Integer> postorderTraversal(TreeNode root) {\n        LinkedList<Integer> list = new LinkedList<>();\n        if(root == null) {\n            return list;\n        }\n        Stack<TreeNode> stack = new Stack<>();\n        stack.push(root);\n        while (!stack.isEmpty()) {\n            root = stack.pop();\n            list.addFirst(root.val);\n            if (root.left != null) {\n                stack.add(root.left);\n            }\n            if (root.right != null) {\n                stack.add(root.right);\n            }\n        }\n        return list;\n    }\n}\n```\n","slug":"algorithm/LeetCode-145-二叉树的后序遍历","published":1,"updated":"2020-10-27T08:08:15.927Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckio9dwdw001tk8nemy5umwp0","content":"<h3 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h3><p><a href=\"https://leetcode-cn.com/problems/binary-tree-postorder-traversal/\" target=\"_blank\" rel=\"noopener\">LeetCode 145. 二叉树的后序遍历</a></p>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>后序遍历是按照<code>左-右-根</code>的顺序.</p>\n<p>按照<code>根-左-右</code>的顺序将节点入栈, 出栈顺序则是后序遍历的值.</p>\n<a id=\"more\"></a>\n<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode() &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = val;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = left;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title\">postorderTraversal</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        LinkedList&lt;Integer&gt; list = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Stack&lt;TreeNode&gt; stack = <span class=\"keyword\">new</span> Stack&lt;&gt;();</span><br><span class=\"line\">        stack.push(root);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!stack.isEmpty()) &#123;</span><br><span class=\"line\">            root = stack.pop();</span><br><span class=\"line\">            list.addFirst(root.val);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (root.left != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                stack.add(root.left);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (root.right != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                stack.add(root.right);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<h3 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h3><p><a href=\"https://leetcode-cn.com/problems/binary-tree-postorder-traversal/\" target=\"_blank\" rel=\"noopener\">LeetCode 145. 二叉树的后序遍历</a></p>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>后序遍历是按照<code>左-右-根</code>的顺序.</p>\n<p>按照<code>根-左-右</code>的顺序将节点入栈, 出栈顺序则是后序遍历的值.</p>","more":"<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode() &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = val;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = left;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title\">postorderTraversal</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        LinkedList&lt;Integer&gt; list = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Stack&lt;TreeNode&gt; stack = <span class=\"keyword\">new</span> Stack&lt;&gt;();</span><br><span class=\"line\">        stack.push(root);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!stack.isEmpty()) &#123;</span><br><span class=\"line\">            root = stack.pop();</span><br><span class=\"line\">            list.addFirst(root.val);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (root.left != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                stack.add(root.left);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (root.right != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                stack.add(root.right);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode 977.有序数组的平方","date":"2020-08-01T09:07:01.000Z","_content":"\n### 题目\n\n[LeetCode 977. 有序数组的平方](https://leetcode-cn.com/problems/squares-of-a-sorted-array/)\n\n### 思路\n\n1. 最简单的思路是首先遍历数组, 每个值求平方, 然后排序并返回\n\n时间复杂度 = 遍历一次数组O(n) + 调用一次`Arrays.sort()` 快排O(n*logn)\n即O(n + n* logn) = O(n * logn)\n\n2. 另外仔细审题, 提示*已经按非递减顺序排序*, 所以说其实数据是由小到大排序的.\n那么可以得出:\n\n* 如果数组中没有负数, 那么只需要按顺序求平方并返回结果即可.\n* 负数部分由小到大, 说明它们的绝对值是按*由大到小*排序的.\n<!--more-->\n那么用两个指针分别从前后开始, 比较绝对值大小, 最大的那个元素求平方放到数组最末位, 便能得到结果.\n\n### 代码实现\n\n遍历+排序\n\n```java\nclass Solution {\n    public int[] sortedSquares(int[] A) {\n        int[] r = new int[A.length];\n        int index = 0;\n        for(int i : A) {\n            r[index] = i * i;\n            index++;\n        }\n        Arrays.sort(r);\n        return r;\n    }\n}\n```\n\n双指针解法\n\n```java\nclass Solution {\n    public int[] sortedSquares(int[] A) {\n        int[] r = new int[A.length];\n        int left = 0;\n        int right = A.length - 1;\n        int index = A.length -1;\n        while (index >= 0){\n            if (Math.abs(A[left]) > Math.abs(A[right])) {\n                r[index--] = A[left] * A[left];\n                left++;\n            } else {\n                r[index--] = A[right] * A[right];\n                right--;\n            }\n        }\n        return r;\n    }\n}\n```\n","source":"_posts/algorithm/LeetCode-977-有序数组的平方.md","raw":"---\ntitle: LeetCode 977.有序数组的平方\ndate: 2020-08-01 17:07:01\ncategories: 算法日常练习\ntags:\n- 数据结构与算法\n- 双指针\n---\n\n### 题目\n\n[LeetCode 977. 有序数组的平方](https://leetcode-cn.com/problems/squares-of-a-sorted-array/)\n\n### 思路\n\n1. 最简单的思路是首先遍历数组, 每个值求平方, 然后排序并返回\n\n时间复杂度 = 遍历一次数组O(n) + 调用一次`Arrays.sort()` 快排O(n*logn)\n即O(n + n* logn) = O(n * logn)\n\n2. 另外仔细审题, 提示*已经按非递减顺序排序*, 所以说其实数据是由小到大排序的.\n那么可以得出:\n\n* 如果数组中没有负数, 那么只需要按顺序求平方并返回结果即可.\n* 负数部分由小到大, 说明它们的绝对值是按*由大到小*排序的.\n<!--more-->\n那么用两个指针分别从前后开始, 比较绝对值大小, 最大的那个元素求平方放到数组最末位, 便能得到结果.\n\n### 代码实现\n\n遍历+排序\n\n```java\nclass Solution {\n    public int[] sortedSquares(int[] A) {\n        int[] r = new int[A.length];\n        int index = 0;\n        for(int i : A) {\n            r[index] = i * i;\n            index++;\n        }\n        Arrays.sort(r);\n        return r;\n    }\n}\n```\n\n双指针解法\n\n```java\nclass Solution {\n    public int[] sortedSquares(int[] A) {\n        int[] r = new int[A.length];\n        int left = 0;\n        int right = A.length - 1;\n        int index = A.length -1;\n        while (index >= 0){\n            if (Math.abs(A[left]) > Math.abs(A[right])) {\n                r[index--] = A[left] * A[left];\n                left++;\n            } else {\n                r[index--] = A[right] * A[right];\n                right--;\n            }\n        }\n        return r;\n    }\n}\n```\n","slug":"algorithm/LeetCode-977-有序数组的平方","published":1,"updated":"2020-10-27T08:08:15.929Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckio9dwdx001wk8nehzqb6a45","content":"<h3 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h3><p><a href=\"https://leetcode-cn.com/problems/squares-of-a-sorted-array/\" target=\"_blank\" rel=\"noopener\">LeetCode 977. 有序数组的平方</a></p>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><ol>\n<li>最简单的思路是首先遍历数组, 每个值求平方, 然后排序并返回</li>\n</ol>\n<p>时间复杂度 = 遍历一次数组O(n) + 调用一次<code>Arrays.sort()</code> 快排O(n<em>logn)<br>即O(n + n</em> logn) = O(n * logn)</p>\n<ol start=\"2\">\n<li>另外仔细审题, 提示<em>已经按非递减顺序排序</em>, 所以说其实数据是由小到大排序的.<br>那么可以得出:</li>\n</ol>\n<ul>\n<li>如果数组中没有负数, 那么只需要按顺序求平方并返回结果即可.</li>\n<li>负数部分由小到大, 说明它们的绝对值是按<em>由大到小</em>排序的.<a id=\"more\"></a>\n那么用两个指针分别从前后开始, 比较绝对值大小, 最大的那个元素求平方放到数组最末位, 便能得到结果.</li>\n</ul>\n<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><p>遍历+排序</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] sortedSquares(<span class=\"keyword\">int</span>[] A) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] r = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[A.length];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> index = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i : A) &#123;</span><br><span class=\"line\">            r[index] = i * i;</span><br><span class=\"line\">            index++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Arrays.sort(r);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>双指针解法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] sortedSquares(<span class=\"keyword\">int</span>[] A) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] r = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[A.length];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> left = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> right = A.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> index = A.length -<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (index &gt;= <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (Math.abs(A[left]) &gt; Math.abs(A[right])) &#123;</span><br><span class=\"line\">                r[index--] = A[left] * A[left];</span><br><span class=\"line\">                left++;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                r[index--] = A[right] * A[right];</span><br><span class=\"line\">                right--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<h3 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h3><p><a href=\"https://leetcode-cn.com/problems/squares-of-a-sorted-array/\" target=\"_blank\" rel=\"noopener\">LeetCode 977. 有序数组的平方</a></p>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><ol>\n<li>最简单的思路是首先遍历数组, 每个值求平方, 然后排序并返回</li>\n</ol>\n<p>时间复杂度 = 遍历一次数组O(n) + 调用一次<code>Arrays.sort()</code> 快排O(n<em>logn)<br>即O(n + n</em> logn) = O(n * logn)</p>\n<ol start=\"2\">\n<li>另外仔细审题, 提示<em>已经按非递减顺序排序</em>, 所以说其实数据是由小到大排序的.<br>那么可以得出:</li>\n</ol>\n<ul>\n<li>如果数组中没有负数, 那么只需要按顺序求平方并返回结果即可.</li>\n<li>负数部分由小到大, 说明它们的绝对值是按<em>由大到小</em>排序的.","more":"那么用两个指针分别从前后开始, 比较绝对值大小, 最大的那个元素求平方放到数组最末位, 便能得到结果.</li>\n</ul>\n<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><p>遍历+排序</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] sortedSquares(<span class=\"keyword\">int</span>[] A) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] r = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[A.length];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> index = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i : A) &#123;</span><br><span class=\"line\">            r[index] = i * i;</span><br><span class=\"line\">            index++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Arrays.sort(r);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>双指针解法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] sortedSquares(<span class=\"keyword\">int</span>[] A) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] r = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[A.length];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> left = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> right = A.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> index = A.length -<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (index &gt;= <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (Math.abs(A[left]) &gt; Math.abs(A[right])) &#123;</span><br><span class=\"line\">                r[index--] = A[left] * A[left];</span><br><span class=\"line\">                left++;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                r[index--] = A[right] * A[right];</span><br><span class=\"line\">                right--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"打印两个有序链表的公共部分","date":"2020-06-13T14:36:35.000Z","_content":"\n### 题目\n\n给定两个有序链表的头指针head1和head2, 打印两个链表的公共部分.\n链表使用如下结构:\n\n```Java\npublic class Node {\n    public int value;\n    public Node next;\n    public Node(int data) {\n        this.value = data;\n    }\n}\n```\n\n### 思路\n\n* head1 < head2, head1后移\n* head1 > head2, head2后移\n* head1 = head2, 打印value, head1和head2同时后移\n* <!--more-->\n* head1或head2任意next为null, 终止\n\n### 代码实现\n\n```Java\npublic void getCommonPart(Node head1, Node head2) {\n        System.out.println(\"Common Part: \");\n        while (head1.next != null && head2.next != null) {\n            if(head1.value < head2.value) {\n                System.out.println(head1.value + \",\");\n                head1 = head1.next;\n                continue;\n            }\n            if (head1.value > head2.value) {\n                System.out.println(head2.value + \",\");\n                head2 = head2.next;\n                continue;\n            }\n            System.out.println(head1.value + \",\");\n            head1 = head1.next;\n            head2 = head2.next;\n        }\n        System.out.println(\"\");\n    }\n```","source":"_posts/algorithm/打印两个有序链表的公共部分.md","raw":"---\ntitle: 打印两个有序链表的公共部分\ndate: 2020-06-13 22:36:35\ncategories: 算法日常练习\ntags:\n- 数据结构与算法\n- 链表\n---\n\n### 题目\n\n给定两个有序链表的头指针head1和head2, 打印两个链表的公共部分.\n链表使用如下结构:\n\n```Java\npublic class Node {\n    public int value;\n    public Node next;\n    public Node(int data) {\n        this.value = data;\n    }\n}\n```\n\n### 思路\n\n* head1 < head2, head1后移\n* head1 > head2, head2后移\n* head1 = head2, 打印value, head1和head2同时后移\n* <!--more-->\n* head1或head2任意next为null, 终止\n\n### 代码实现\n\n```Java\npublic void getCommonPart(Node head1, Node head2) {\n        System.out.println(\"Common Part: \");\n        while (head1.next != null && head2.next != null) {\n            if(head1.value < head2.value) {\n                System.out.println(head1.value + \",\");\n                head1 = head1.next;\n                continue;\n            }\n            if (head1.value > head2.value) {\n                System.out.println(head2.value + \",\");\n                head2 = head2.next;\n                continue;\n            }\n            System.out.println(head1.value + \",\");\n            head1 = head1.next;\n            head2 = head2.next;\n        }\n        System.out.println(\"\");\n    }\n```","slug":"algorithm/打印两个有序链表的公共部分","published":1,"updated":"2020-10-27T08:08:15.930Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckio9dwdz0020k8neuvg84tta","content":"<h3 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h3><p>给定两个有序链表的头指针head1和head2, 打印两个链表的公共部分.<br>链表使用如下结构:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> value;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> Node next;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Node</span><span class=\"params\">(<span class=\"keyword\">int</span> data)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.value = data;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><ul>\n<li>head1 &lt; head2, head1后移</li>\n<li>head1 &gt; head2, head2后移</li>\n<li>head1 = head2, 打印value, head1和head2同时后移</li>\n<li><a id=\"more\"></a></li>\n<li>head1或head2任意next为null, 终止</li>\n</ul>\n<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">getCommonPart</span><span class=\"params\">(Node head1, Node head2)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Common Part: \"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (head1.next != <span class=\"keyword\">null</span> &amp;&amp; head2.next != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(head1.value &lt; head2.value) &#123;</span><br><span class=\"line\">                System.out.println(head1.value + <span class=\"string\">\",\"</span>);</span><br><span class=\"line\">                head1 = head1.next;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (head1.value &gt; head2.value) &#123;</span><br><span class=\"line\">                System.out.println(head2.value + <span class=\"string\">\",\"</span>);</span><br><span class=\"line\">                head2 = head2.next;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(head1.value + <span class=\"string\">\",\"</span>);</span><br><span class=\"line\">            head1 = head1.next;</span><br><span class=\"line\">            head2 = head2.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"\"</span>);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h3 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h3><p>给定两个有序链表的头指针head1和head2, 打印两个链表的公共部分.<br>链表使用如下结构:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> value;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> Node next;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Node</span><span class=\"params\">(<span class=\"keyword\">int</span> data)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.value = data;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><ul>\n<li>head1 &lt; head2, head1后移</li>\n<li>head1 &gt; head2, head2后移</li>\n<li>head1 = head2, 打印value, head1和head2同时后移</li>\n<li>","more":"</li>\n<li>head1或head2任意next为null, 终止</li>\n</ul>\n<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">getCommonPart</span><span class=\"params\">(Node head1, Node head2)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Common Part: \"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (head1.next != <span class=\"keyword\">null</span> &amp;&amp; head2.next != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(head1.value &lt; head2.value) &#123;</span><br><span class=\"line\">                System.out.println(head1.value + <span class=\"string\">\",\"</span>);</span><br><span class=\"line\">                head1 = head1.next;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (head1.value &gt; head2.value) &#123;</span><br><span class=\"line\">                System.out.println(head2.value + <span class=\"string\">\",\"</span>);</span><br><span class=\"line\">                head2 = head2.next;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(head1.value + <span class=\"string\">\",\"</span>);</span><br><span class=\"line\">            head1 = head1.next;</span><br><span class=\"line\">            head2 = head2.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"\"</span>);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>"},{"title":"仅用递归函数和栈操作逆序一个栈","date":"2020-06-09T15:11:20.000Z","_content":"\n### 题目\n\n实现栈中元素的逆序, 但是只能用递归函数来实现, 不能使用其它数据结构.\n\n### 思路\n\n递归获取栈底元素\n<!--more-->\n\n### 代码实现\n\n```java\n/**\n* 将栈倒置\n*/\npublic static void reverse(Stack<Integer> stack) {\n    if (stack.isEmpty()) {\n      return;\n    }\n    int item = getAndRemoveLastElement(stack);\n    reverse(stack);\n    stack.push(item);\n  }\n\n\n  /**\n   * 将stack的栈底元素返回并移除\n   * */\n  public static int getAndRemoveLastElement(Stack<Integer> stack){\n    int result = stack.pop();\n    if (stack.isEmpty()) {\n      return result;\n    }\n    int last = getAndRemoveLastElement(stack);\n    stack.push(result);\n    return last;\n  }\n```","source":"_posts/algorithm/仅用递归函数和栈操作逆序一个栈.md","raw":"---\ntitle: 仅用递归函数和栈操作逆序一个栈\ndate: 2020-06-09 23:11:20\ncategories: 算法日常练习\ntags:\n- 数据结构与算法\n- 栈\n- 递归\n---\n\n### 题目\n\n实现栈中元素的逆序, 但是只能用递归函数来实现, 不能使用其它数据结构.\n\n### 思路\n\n递归获取栈底元素\n<!--more-->\n\n### 代码实现\n\n```java\n/**\n* 将栈倒置\n*/\npublic static void reverse(Stack<Integer> stack) {\n    if (stack.isEmpty()) {\n      return;\n    }\n    int item = getAndRemoveLastElement(stack);\n    reverse(stack);\n    stack.push(item);\n  }\n\n\n  /**\n   * 将stack的栈底元素返回并移除\n   * */\n  public static int getAndRemoveLastElement(Stack<Integer> stack){\n    int result = stack.pop();\n    if (stack.isEmpty()) {\n      return result;\n    }\n    int last = getAndRemoveLastElement(stack);\n    stack.push(result);\n    return last;\n  }\n```","slug":"algorithm/仅用递归函数和栈操作逆序一个栈","published":1,"updated":"2020-10-27T08:08:15.929Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckio9dwe00023k8nejrp4dxxl","content":"<h3 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h3><p>实现栈中元素的逆序, 但是只能用递归函数来实现, 不能使用其它数据结构.</p>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>递归获取栈底元素</p>\n<a id=\"more\"></a>\n\n<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 将栈倒置</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">reverse</span><span class=\"params\">(Stack&lt;Integer&gt; stack)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (stack.isEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> item = getAndRemoveLastElement(stack);</span><br><span class=\"line\">    reverse(stack);</span><br><span class=\"line\">    stack.push(item);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 将stack的栈底元素返回并移除</span></span><br><span class=\"line\"><span class=\"comment\">   * */</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">getAndRemoveLastElement</span><span class=\"params\">(Stack&lt;Integer&gt; stack)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> result = stack.pop();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (stack.isEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> last = getAndRemoveLastElement(stack);</span><br><span class=\"line\">    stack.push(result);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> last;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h3 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h3><p>实现栈中元素的逆序, 但是只能用递归函数来实现, 不能使用其它数据结构.</p>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>递归获取栈底元素</p>","more":"<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 将栈倒置</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">reverse</span><span class=\"params\">(Stack&lt;Integer&gt; stack)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (stack.isEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> item = getAndRemoveLastElement(stack);</span><br><span class=\"line\">    reverse(stack);</span><br><span class=\"line\">    stack.push(item);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 将stack的栈底元素返回并移除</span></span><br><span class=\"line\"><span class=\"comment\">   * */</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">getAndRemoveLastElement</span><span class=\"params\">(Stack&lt;Integer&gt; stack)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> result = stack.pop();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (stack.isEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> last = getAndRemoveLastElement(stack);</span><br><span class=\"line\">    stack.push(result);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> last;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>"},{"title":"单链表删除倒数第K个节点","date":"2020-06-14T14:42:33.000Z","_content":"\n### 题目\n\n实现一个函数, 可以删除单链表中倒数第K个节点.\n要求:\n如果链表长度为N, 时间复杂度达到O(N),额外空间复杂度达到O(1)\n\n### 思路\n\n假设让链表从头开始走到尾, 每移动一步就让K值减一,则当链表走到结尾时:\n\n* K > 0, 代表K - N > 0, 则K > N,说明链表不存在倒数第K个节点, 不用调整链表\n* K = 0, 代表K = N, 倒数第K个节点就是头节点, 删除头节点即可\n* K < 0, 代表存在该节点, 单链表已经遍历过了, 那么怎么找到要删除的节点的前驱节点呢? (通过node.next = node.next.next来删除)\n  1. 重新从头节点遍历, 每移动一步让K加一\n  2. 当K等于0时, 移动停止, 移动到的节点就是要删除节点的前驱节点\n<!--more-->\n     解释:\n     * 要删除的节点是倒数第K个, 也就是正数 N-K+1个, 那么它的前驱节点就是第N-K个\n     * 第一次遍历后, K的值变为K-N, 第二次遍历加到0停止, 就是 0 - (K - N) = N - K\n     * 魔鬼逻辑, 毫无漏洞...\n\n### 代码实现\n\n```Java\npublic class Node {\n    public int value;\n    public Node next;\n    public Node(int data) {\n        this.value = data;\n    }\n}\n\npublic Node removeLastKthNode (Node head, int lastKth) {\n    if (head == null || lastKth < 1) {\n        return head;\n    }\n    Node cur = head;\n    while (cur != null) {\n        lastKth--;\n        cur = cur.next;\n    }\n    if (lastKth > 0 ) {\n        return head;\n    }\n\n    if (lastKth == 0) {\n        head = head.next;\n        return head;\n    }\n\n    if (lastKth < 0) {\n        cur = head;\n        while (++lastKth != 0) {\n            cur = cur.next;\n        }\n        cur.next = cur.next.next;\n    }\n    return head;\n}\n\n```\n","source":"_posts/algorithm/单链表删除倒数第K个节点.md","raw":"---\ntitle: 单链表删除倒数第K个节点\ndate: 2020-06-14 22:42:33\ncategories: 算法日常练习\ntags:\n- 数据结构与算法\n- 链表\n---\n\n### 题目\n\n实现一个函数, 可以删除单链表中倒数第K个节点.\n要求:\n如果链表长度为N, 时间复杂度达到O(N),额外空间复杂度达到O(1)\n\n### 思路\n\n假设让链表从头开始走到尾, 每移动一步就让K值减一,则当链表走到结尾时:\n\n* K > 0, 代表K - N > 0, 则K > N,说明链表不存在倒数第K个节点, 不用调整链表\n* K = 0, 代表K = N, 倒数第K个节点就是头节点, 删除头节点即可\n* K < 0, 代表存在该节点, 单链表已经遍历过了, 那么怎么找到要删除的节点的前驱节点呢? (通过node.next = node.next.next来删除)\n  1. 重新从头节点遍历, 每移动一步让K加一\n  2. 当K等于0时, 移动停止, 移动到的节点就是要删除节点的前驱节点\n<!--more-->\n     解释:\n     * 要删除的节点是倒数第K个, 也就是正数 N-K+1个, 那么它的前驱节点就是第N-K个\n     * 第一次遍历后, K的值变为K-N, 第二次遍历加到0停止, 就是 0 - (K - N) = N - K\n     * 魔鬼逻辑, 毫无漏洞...\n\n### 代码实现\n\n```Java\npublic class Node {\n    public int value;\n    public Node next;\n    public Node(int data) {\n        this.value = data;\n    }\n}\n\npublic Node removeLastKthNode (Node head, int lastKth) {\n    if (head == null || lastKth < 1) {\n        return head;\n    }\n    Node cur = head;\n    while (cur != null) {\n        lastKth--;\n        cur = cur.next;\n    }\n    if (lastKth > 0 ) {\n        return head;\n    }\n\n    if (lastKth == 0) {\n        head = head.next;\n        return head;\n    }\n\n    if (lastKth < 0) {\n        cur = head;\n        while (++lastKth != 0) {\n            cur = cur.next;\n        }\n        cur.next = cur.next.next;\n    }\n    return head;\n}\n\n```\n","slug":"algorithm/单链表删除倒数第K个节点","published":1,"updated":"2020-10-27T08:08:15.929Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckio9dwe30027k8nexkmrefuj","content":"<h3 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h3><p>实现一个函数, 可以删除单链表中倒数第K个节点.<br>要求:<br>如果链表长度为N, 时间复杂度达到O(N),额外空间复杂度达到O(1)</p>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>假设让链表从头开始走到尾, 每移动一步就让K值减一,则当链表走到结尾时:</p>\n<ul>\n<li>K &gt; 0, 代表K - N &gt; 0, 则K &gt; N,说明链表不存在倒数第K个节点, 不用调整链表</li>\n<li>K = 0, 代表K = N, 倒数第K个节点就是头节点, 删除头节点即可</li>\n<li>K &lt; 0, 代表存在该节点, 单链表已经遍历过了, 那么怎么找到要删除的节点的前驱节点呢? (通过node.next = node.next.next来删除)<ol>\n<li>重新从头节点遍历, 每移动一步让K加一</li>\n<li>当K等于0时, 移动停止, 移动到的节点就是要删除节点的前驱节点<a id=\"more\"></a>\n解释:<ul>\n<li>要删除的节点是倒数第K个, 也就是正数 N-K+1个, 那么它的前驱节点就是第N-K个</li>\n<li>第一次遍历后, K的值变为K-N, 第二次遍历加到0停止, 就是 0 - (K - N) = N - K</li>\n<li>魔鬼逻辑, 毫无漏洞…</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> value;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> Node next;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Node</span><span class=\"params\">(<span class=\"keyword\">int</span> data)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.value = data;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Node <span class=\"title\">removeLastKthNode</span> <span class=\"params\">(Node head, <span class=\"keyword\">int</span> lastKth)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (head == <span class=\"keyword\">null</span> || lastKth &lt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Node cur = head;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (cur != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        lastKth--;</span><br><span class=\"line\">        cur = cur.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (lastKth &gt; <span class=\"number\">0</span> ) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (lastKth == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        head = head.next;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (lastKth &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        cur = head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (++lastKth != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            cur = cur.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cur.next = cur.next.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<h3 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h3><p>实现一个函数, 可以删除单链表中倒数第K个节点.<br>要求:<br>如果链表长度为N, 时间复杂度达到O(N),额外空间复杂度达到O(1)</p>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>假设让链表从头开始走到尾, 每移动一步就让K值减一,则当链表走到结尾时:</p>\n<ul>\n<li>K &gt; 0, 代表K - N &gt; 0, 则K &gt; N,说明链表不存在倒数第K个节点, 不用调整链表</li>\n<li>K = 0, 代表K = N, 倒数第K个节点就是头节点, 删除头节点即可</li>\n<li>K &lt; 0, 代表存在该节点, 单链表已经遍历过了, 那么怎么找到要删除的节点的前驱节点呢? (通过node.next = node.next.next来删除)<ol>\n<li>重新从头节点遍历, 每移动一步让K加一</li>\n<li>当K等于0时, 移动停止, 移动到的节点就是要删除节点的前驱节点","more":"解释:<ul>\n<li>要删除的节点是倒数第K个, 也就是正数 N-K+1个, 那么它的前驱节点就是第N-K个</li>\n<li>第一次遍历后, K的值变为K-N, 第二次遍历加到0停止, 就是 0 - (K - N) = N - K</li>\n<li>魔鬼逻辑, 毫无漏洞…</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> value;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> Node next;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Node</span><span class=\"params\">(<span class=\"keyword\">int</span> data)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.value = data;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Node <span class=\"title\">removeLastKthNode</span> <span class=\"params\">(Node head, <span class=\"keyword\">int</span> lastKth)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (head == <span class=\"keyword\">null</span> || lastKth &lt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Node cur = head;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (cur != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        lastKth--;</span><br><span class=\"line\">        cur = cur.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (lastKth &gt; <span class=\"number\">0</span> ) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (lastKth == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        head = head.next;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (lastKth &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        cur = head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (++lastKth != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            cur = cur.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cur.next = cur.next.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"汉诺塔问题","date":"2020-06-12T15:39:19.000Z","_content":"\n### 题目\n\n在经典汉诺塔问题中，有 3 根柱子及 N 个不同大小的穿孔圆盘，盘子可以滑入任意一根柱子。一开始，所有盘子自上而下按升序依次套在第一根柱子上(即每一个盘子只能放在更大的盘子上面)。移动圆盘时受到以下限制:\n(1) 每次只能移动一个盘子;\n(2) 盘子只能从柱子顶端滑出移到下一根柱子;\n(3) 盘子只能叠在比它大的盘子上。\n\n请编写程序，用栈将所有盘子从第一根柱子移到最后一根柱子。\n<!--more-->\n你需要原地修改栈。\n\n示例1:\n\n 输入：A = [2, 1, 0], B = [], C = []\n 输出：C = [2, 1, 0]\n示例2:\n\n 输入：A = [1, 0], B = [], C = []\n 输出：C = [1, 0]\n提示:\n\nA中盘子的数目不大于14个。\n\n### 解决思路\n\n优先考虑递归实现, 那么考虑以下3个问题:\n\n1. 问题能否分解?\n2. 问题与分解后的子问题, 除了数据规模不同, 解决思路完全一样吗?\n3. 递归终止条件?\n\n首先模拟一下小数据量时的解决过程:\n\n* n = 1:\n    A将最大盘子移到C,A -> C\n* n = 2:\n    A将1个盘子移到B, 再将最大盘子移到C,B再将1个盘子移到C\n    A -> B, A -> C, B -> C\n* n = 3时:  \n    A将2个盘子移到B, 再将最大盘子移到C,B再将2个盘子移到C\n    A -> C, A -> B, C -> B, A -> C | B -> A, B -> C, A -> C\n\n那么, 我们可以推出子问题和递归终止条件了:\n\n* 当n > 1:\n  * 先把A上的n-1个盘子<del>通过C</del>移到B(子问题, 递归)\n  * 再把A上最大盘子移到C\n  * 再把B上n-1个盘子<del>通过A</del>移到C(子问题, 递归)\n\n* 递归终止条件:\n  n = 1, 直接把A上的盘子移到C\n\n### 代码实现\n\n```Java\n    public void hanota(List<Integer> A, List<Integer> B, List<Integer> C) {\n        if (A == null || A.size() == 0) {\n            return;\n        }\n        hanoi(A.size(), A, B, C);\n    }\n\n    public void hanoi(int n , List<Integer> A, List<Integer> B, List<Integer> C) {\n        if (n == 1) {\n            C.add(A.remove(A.size() - 1));\n            return;\n        }\n        hanoi(n - 1, A, C, B);\n        C.add(A.remove(A.size() - 1));\n        hanoi(n - 1, B, A, C);\n    }\n```","source":"_posts/algorithm/汉诺塔问题.md","raw":"---\ntitle: 汉诺塔问题\ndate: 2020-06-12 23:39:19\ncategories: 算法日常练习\ntags:\n- 数据结构与算法\n- 栈\n- 汉诺塔\n---\n\n### 题目\n\n在经典汉诺塔问题中，有 3 根柱子及 N 个不同大小的穿孔圆盘，盘子可以滑入任意一根柱子。一开始，所有盘子自上而下按升序依次套在第一根柱子上(即每一个盘子只能放在更大的盘子上面)。移动圆盘时受到以下限制:\n(1) 每次只能移动一个盘子;\n(2) 盘子只能从柱子顶端滑出移到下一根柱子;\n(3) 盘子只能叠在比它大的盘子上。\n\n请编写程序，用栈将所有盘子从第一根柱子移到最后一根柱子。\n<!--more-->\n你需要原地修改栈。\n\n示例1:\n\n 输入：A = [2, 1, 0], B = [], C = []\n 输出：C = [2, 1, 0]\n示例2:\n\n 输入：A = [1, 0], B = [], C = []\n 输出：C = [1, 0]\n提示:\n\nA中盘子的数目不大于14个。\n\n### 解决思路\n\n优先考虑递归实现, 那么考虑以下3个问题:\n\n1. 问题能否分解?\n2. 问题与分解后的子问题, 除了数据规模不同, 解决思路完全一样吗?\n3. 递归终止条件?\n\n首先模拟一下小数据量时的解决过程:\n\n* n = 1:\n    A将最大盘子移到C,A -> C\n* n = 2:\n    A将1个盘子移到B, 再将最大盘子移到C,B再将1个盘子移到C\n    A -> B, A -> C, B -> C\n* n = 3时:  \n    A将2个盘子移到B, 再将最大盘子移到C,B再将2个盘子移到C\n    A -> C, A -> B, C -> B, A -> C | B -> A, B -> C, A -> C\n\n那么, 我们可以推出子问题和递归终止条件了:\n\n* 当n > 1:\n  * 先把A上的n-1个盘子<del>通过C</del>移到B(子问题, 递归)\n  * 再把A上最大盘子移到C\n  * 再把B上n-1个盘子<del>通过A</del>移到C(子问题, 递归)\n\n* 递归终止条件:\n  n = 1, 直接把A上的盘子移到C\n\n### 代码实现\n\n```Java\n    public void hanota(List<Integer> A, List<Integer> B, List<Integer> C) {\n        if (A == null || A.size() == 0) {\n            return;\n        }\n        hanoi(A.size(), A, B, C);\n    }\n\n    public void hanoi(int n , List<Integer> A, List<Integer> B, List<Integer> C) {\n        if (n == 1) {\n            C.add(A.remove(A.size() - 1));\n            return;\n        }\n        hanoi(n - 1, A, C, B);\n        C.add(A.remove(A.size() - 1));\n        hanoi(n - 1, B, A, C);\n    }\n```","slug":"algorithm/汉诺塔问题","published":1,"updated":"2020-10-27T08:08:15.930Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckio9dwe5002ak8neba7a17ov","content":"<h3 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h3><p>在经典汉诺塔问题中，有 3 根柱子及 N 个不同大小的穿孔圆盘，盘子可以滑入任意一根柱子。一开始，所有盘子自上而下按升序依次套在第一根柱子上(即每一个盘子只能放在更大的盘子上面)。移动圆盘时受到以下限制:<br>(1) 每次只能移动一个盘子;<br>(2) 盘子只能从柱子顶端滑出移到下一根柱子;<br>(3) 盘子只能叠在比它大的盘子上。</p>\n<p>请编写程序，用栈将所有盘子从第一根柱子移到最后一根柱子。</p>\n<a id=\"more\"></a>\n<p>你需要原地修改栈。</p>\n<p>示例1:</p>\n<p> 输入：A = [2, 1, 0], B = [], C = []<br> 输出：C = [2, 1, 0]<br>示例2:</p>\n<p> 输入：A = [1, 0], B = [], C = []<br> 输出：C = [1, 0]<br>提示:</p>\n<p>A中盘子的数目不大于14个。</p>\n<h3 id=\"解决思路\"><a href=\"#解决思路\" class=\"headerlink\" title=\"解决思路\"></a>解决思路</h3><p>优先考虑递归实现, 那么考虑以下3个问题:</p>\n<ol>\n<li>问题能否分解?</li>\n<li>问题与分解后的子问题, 除了数据规模不同, 解决思路完全一样吗?</li>\n<li>递归终止条件?</li>\n</ol>\n<p>首先模拟一下小数据量时的解决过程:</p>\n<ul>\n<li>n = 1:<br>  A将最大盘子移到C,A -&gt; C</li>\n<li>n = 2:<br>  A将1个盘子移到B, 再将最大盘子移到C,B再将1个盘子移到C<br>  A -&gt; B, A -&gt; C, B -&gt; C</li>\n<li>n = 3时:<br>  A将2个盘子移到B, 再将最大盘子移到C,B再将2个盘子移到C<br>  A -&gt; C, A -&gt; B, C -&gt; B, A -&gt; C | B -&gt; A, B -&gt; C, A -&gt; C</li>\n</ul>\n<p>那么, 我们可以推出子问题和递归终止条件了:</p>\n<ul>\n<li><p>当n &gt; 1:</p>\n<ul>\n<li>先把A上的n-1个盘子<del>通过C</del>移到B(子问题, 递归)</li>\n<li>再把A上最大盘子移到C</li>\n<li>再把B上n-1个盘子<del>通过A</del>移到C(子问题, 递归)</li>\n</ul>\n</li>\n<li><p>递归终止条件:<br>n = 1, 直接把A上的盘子移到C</p>\n</li>\n</ul>\n<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">hanota</span><span class=\"params\">(List&lt;Integer&gt; A, List&lt;Integer&gt; B, List&lt;Integer&gt; C)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (A == <span class=\"keyword\">null</span> || A.size() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    hanoi(A.size(), A, B, C);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">hanoi</span><span class=\"params\">(<span class=\"keyword\">int</span> n , List&lt;Integer&gt; A, List&lt;Integer&gt; B, List&lt;Integer&gt; C)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        C.add(A.remove(A.size() - <span class=\"number\">1</span>));</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    hanoi(n - <span class=\"number\">1</span>, A, C, B);</span><br><span class=\"line\">    C.add(A.remove(A.size() - <span class=\"number\">1</span>));</span><br><span class=\"line\">    hanoi(n - <span class=\"number\">1</span>, B, A, C);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h3 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h3><p>在经典汉诺塔问题中，有 3 根柱子及 N 个不同大小的穿孔圆盘，盘子可以滑入任意一根柱子。一开始，所有盘子自上而下按升序依次套在第一根柱子上(即每一个盘子只能放在更大的盘子上面)。移动圆盘时受到以下限制:<br>(1) 每次只能移动一个盘子;<br>(2) 盘子只能从柱子顶端滑出移到下一根柱子;<br>(3) 盘子只能叠在比它大的盘子上。</p>\n<p>请编写程序，用栈将所有盘子从第一根柱子移到最后一根柱子。</p>","more":"<p>你需要原地修改栈。</p>\n<p>示例1:</p>\n<p> 输入：A = [2, 1, 0], B = [], C = []<br> 输出：C = [2, 1, 0]<br>示例2:</p>\n<p> 输入：A = [1, 0], B = [], C = []<br> 输出：C = [1, 0]<br>提示:</p>\n<p>A中盘子的数目不大于14个。</p>\n<h3 id=\"解决思路\"><a href=\"#解决思路\" class=\"headerlink\" title=\"解决思路\"></a>解决思路</h3><p>优先考虑递归实现, 那么考虑以下3个问题:</p>\n<ol>\n<li>问题能否分解?</li>\n<li>问题与分解后的子问题, 除了数据规模不同, 解决思路完全一样吗?</li>\n<li>递归终止条件?</li>\n</ol>\n<p>首先模拟一下小数据量时的解决过程:</p>\n<ul>\n<li>n = 1:<br>  A将最大盘子移到C,A -&gt; C</li>\n<li>n = 2:<br>  A将1个盘子移到B, 再将最大盘子移到C,B再将1个盘子移到C<br>  A -&gt; B, A -&gt; C, B -&gt; C</li>\n<li>n = 3时:<br>  A将2个盘子移到B, 再将最大盘子移到C,B再将2个盘子移到C<br>  A -&gt; C, A -&gt; B, C -&gt; B, A -&gt; C | B -&gt; A, B -&gt; C, A -&gt; C</li>\n</ul>\n<p>那么, 我们可以推出子问题和递归终止条件了:</p>\n<ul>\n<li><p>当n &gt; 1:</p>\n<ul>\n<li>先把A上的n-1个盘子<del>通过C</del>移到B(子问题, 递归)</li>\n<li>再把A上最大盘子移到C</li>\n<li>再把B上n-1个盘子<del>通过A</del>移到C(子问题, 递归)</li>\n</ul>\n</li>\n<li><p>递归终止条件:<br>n = 1, 直接把A上的盘子移到C</p>\n</li>\n</ul>\n<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">hanota</span><span class=\"params\">(List&lt;Integer&gt; A, List&lt;Integer&gt; B, List&lt;Integer&gt; C)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (A == <span class=\"keyword\">null</span> || A.size() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    hanoi(A.size(), A, B, C);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">hanoi</span><span class=\"params\">(<span class=\"keyword\">int</span> n , List&lt;Integer&gt; A, List&lt;Integer&gt; B, List&lt;Integer&gt; C)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        C.add(A.remove(A.size() - <span class=\"number\">1</span>));</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    hanoi(n - <span class=\"number\">1</span>, A, C, B);</span><br><span class=\"line\">    C.add(A.remove(A.size() - <span class=\"number\">1</span>));</span><br><span class=\"line\">    hanoi(n - <span class=\"number\">1</span>, B, A, C);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"爬楼梯","date":"2020-06-17T14:08:57.000Z","_content":"\n### 题目\n\n假设你正在爬楼梯。需要 n 阶你才能到达楼顶。\n\n每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？\n\n注意：给定 n 是一个正整数。\n\n示例 1：\n\n```\n输入： 2\n输出： 2\n解释： 有两种方法可以爬到楼顶。\n1.  1 阶 + 1 阶\n2.  2 阶\n```\n<!--more-->\n示例 2：\n\n```\n输入： 3\n输出： 3\n解释： 有三种方法可以爬到楼顶。\n1.  1 阶 + 1 阶 + 1 阶\n2.  1 阶 + 2 阶\n3.  2 阶 + 1 阶\n```\n\n### 思路\n\n1. 最简单的思路, 用递归的思想解决. 爬3层楼梯可以看成爬2层+1层问题的方法集合, 终止条件就是当n计算到1\n2. 因为存在大量重复计算, 所以可以用HashMap或者数组存储中间结果\n3. 当然也可以不用递归, 直接迭代计算\n\n### 代码实现\n\n```Java\npublic int climbStairs(int n) {\n    if(n <= 1) {\n        return 1;\n    }\n    if(n == 2) {\n        return 2;\n    }\n    return climbStairs(n - 1) + climbStairs(n-2);\n}\n```\n\n但是这种实现时间复杂度是O(n<sup>2</sup>), 有很多重复计算, 导致运行时间过长.\n所以考虑缓存中间运算结果, 用HashMap或者数组都可以, 在这里用了数组来保存.\n\n```Java\n public int climbStairs(int n) {\n        int[] cache = new int[n + 1];\n        return climbStairsWithCache(n, cache);\n    }\n\n    private int climbStairsWithCache(int n, int[] cache) {\n        if (cache[n] != 0) {\n            return cache[n];\n        }\n        if (n == 1) {\n            cache[n] = 1;\n            return 1;\n        }\n        if (n == 2) {\n            cache[n] = 2;\n            return 2;\n        }\n        int func2 = climbStairsWithCache(n - 2, cache);\n        cache[n - 2] = func2;\n        int func1 = climbStairsWithCache(n - 1, cache);\n        cache[n - 1] = func1;\n        return func2 + func1;\n    }\n```\n\n```java\n public int climbStairs(int n) {\n        int p = 0, q = 0, r = 1;\n        for (int i = 1; i <= n; ++i) {\n            p = q;\n            q = r;\n            r = p + q;\n        }\n        return r;\n    }\n```","source":"_posts/algorithm/爬楼梯.md","raw":"---\ntitle: 爬楼梯\ndate: 2020-06-17 22:08:57\ncategories: 算法日常练习\ntags:\n- 数据结构与算法\n- 递归\n- 动态规划\n---\n\n### 题目\n\n假设你正在爬楼梯。需要 n 阶你才能到达楼顶。\n\n每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？\n\n注意：给定 n 是一个正整数。\n\n示例 1：\n\n```\n输入： 2\n输出： 2\n解释： 有两种方法可以爬到楼顶。\n1.  1 阶 + 1 阶\n2.  2 阶\n```\n<!--more-->\n示例 2：\n\n```\n输入： 3\n输出： 3\n解释： 有三种方法可以爬到楼顶。\n1.  1 阶 + 1 阶 + 1 阶\n2.  1 阶 + 2 阶\n3.  2 阶 + 1 阶\n```\n\n### 思路\n\n1. 最简单的思路, 用递归的思想解决. 爬3层楼梯可以看成爬2层+1层问题的方法集合, 终止条件就是当n计算到1\n2. 因为存在大量重复计算, 所以可以用HashMap或者数组存储中间结果\n3. 当然也可以不用递归, 直接迭代计算\n\n### 代码实现\n\n```Java\npublic int climbStairs(int n) {\n    if(n <= 1) {\n        return 1;\n    }\n    if(n == 2) {\n        return 2;\n    }\n    return climbStairs(n - 1) + climbStairs(n-2);\n}\n```\n\n但是这种实现时间复杂度是O(n<sup>2</sup>), 有很多重复计算, 导致运行时间过长.\n所以考虑缓存中间运算结果, 用HashMap或者数组都可以, 在这里用了数组来保存.\n\n```Java\n public int climbStairs(int n) {\n        int[] cache = new int[n + 1];\n        return climbStairsWithCache(n, cache);\n    }\n\n    private int climbStairsWithCache(int n, int[] cache) {\n        if (cache[n] != 0) {\n            return cache[n];\n        }\n        if (n == 1) {\n            cache[n] = 1;\n            return 1;\n        }\n        if (n == 2) {\n            cache[n] = 2;\n            return 2;\n        }\n        int func2 = climbStairsWithCache(n - 2, cache);\n        cache[n - 2] = func2;\n        int func1 = climbStairsWithCache(n - 1, cache);\n        cache[n - 1] = func1;\n        return func2 + func1;\n    }\n```\n\n```java\n public int climbStairs(int n) {\n        int p = 0, q = 0, r = 1;\n        for (int i = 1; i <= n; ++i) {\n            p = q;\n            q = r;\n            r = p + q;\n        }\n        return r;\n    }\n```","slug":"algorithm/爬楼梯","published":1,"updated":"2020-10-27T08:08:15.931Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckio9dwe6002dk8neyoqbbi4f","content":"<h3 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h3><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p>\n<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>\n<p>注意：给定 n 是一个正整数。</p>\n<p>示例 1：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入： 2</span><br><span class=\"line\">输出： 2</span><br><span class=\"line\">解释： 有两种方法可以爬到楼顶。</span><br><span class=\"line\">1.  1 阶 + 1 阶</span><br><span class=\"line\">2.  2 阶</span><br></pre></td></tr></table></figure>\n\n<a id=\"more\"></a>\n<p>示例 2：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入： 3</span><br><span class=\"line\">输出： 3</span><br><span class=\"line\">解释： 有三种方法可以爬到楼顶。</span><br><span class=\"line\">1.  1 阶 + 1 阶 + 1 阶</span><br><span class=\"line\">2.  1 阶 + 2 阶</span><br><span class=\"line\">3.  2 阶 + 1 阶</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><ol>\n<li>最简单的思路, 用递归的思想解决. 爬3层楼梯可以看成爬2层+1层问题的方法集合, 终止条件就是当n计算到1</li>\n<li>因为存在大量重复计算, 所以可以用HashMap或者数组存储中间结果</li>\n<li>当然也可以不用递归, 直接迭代计算</li>\n</ol>\n<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">climbStairs</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> climbStairs(n - <span class=\"number\">1</span>) + climbStairs(n-<span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是这种实现时间复杂度是O(n<sup>2</sup>), 有很多重复计算, 导致运行时间过长.<br>所以考虑缓存中间运算结果, 用HashMap或者数组都可以, 在这里用了数组来保存.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">climbStairs</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">int</span>[] cache = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[n + <span class=\"number\">1</span>];</span><br><span class=\"line\">       <span class=\"keyword\">return</span> climbStairsWithCache(n, cache);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">climbStairsWithCache</span><span class=\"params\">(<span class=\"keyword\">int</span> n, <span class=\"keyword\">int</span>[] cache)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (cache[n] != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">return</span> cache[n];</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (n == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">           cache[n] = <span class=\"number\">1</span>;</span><br><span class=\"line\">           <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (n == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">           cache[n] = <span class=\"number\">2</span>;</span><br><span class=\"line\">           <span class=\"keyword\">return</span> <span class=\"number\">2</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">int</span> func2 = climbStairsWithCache(n - <span class=\"number\">2</span>, cache);</span><br><span class=\"line\">       cache[n - <span class=\"number\">2</span>] = func2;</span><br><span class=\"line\">       <span class=\"keyword\">int</span> func1 = climbStairsWithCache(n - <span class=\"number\">1</span>, cache);</span><br><span class=\"line\">       cache[n - <span class=\"number\">1</span>] = func1;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> func2 + func1;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">climbStairs</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">int</span> p = <span class=\"number\">0</span>, q = <span class=\"number\">0</span>, r = <span class=\"number\">1</span>;</span><br><span class=\"line\">       <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; ++i) &#123;</span><br><span class=\"line\">           p = q;</span><br><span class=\"line\">           q = r;</span><br><span class=\"line\">           r = p + q;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h3 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h3><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p>\n<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>\n<p>注意：给定 n 是一个正整数。</p>\n<p>示例 1：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入： 2</span><br><span class=\"line\">输出： 2</span><br><span class=\"line\">解释： 有两种方法可以爬到楼顶。</span><br><span class=\"line\">1.  1 阶 + 1 阶</span><br><span class=\"line\">2.  2 阶</span><br></pre></td></tr></table></figure>","more":"<p>示例 2：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入： 3</span><br><span class=\"line\">输出： 3</span><br><span class=\"line\">解释： 有三种方法可以爬到楼顶。</span><br><span class=\"line\">1.  1 阶 + 1 阶 + 1 阶</span><br><span class=\"line\">2.  1 阶 + 2 阶</span><br><span class=\"line\">3.  2 阶 + 1 阶</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><ol>\n<li>最简单的思路, 用递归的思想解决. 爬3层楼梯可以看成爬2层+1层问题的方法集合, 终止条件就是当n计算到1</li>\n<li>因为存在大量重复计算, 所以可以用HashMap或者数组存储中间结果</li>\n<li>当然也可以不用递归, 直接迭代计算</li>\n</ol>\n<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">climbStairs</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> climbStairs(n - <span class=\"number\">1</span>) + climbStairs(n-<span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是这种实现时间复杂度是O(n<sup>2</sup>), 有很多重复计算, 导致运行时间过长.<br>所以考虑缓存中间运算结果, 用HashMap或者数组都可以, 在这里用了数组来保存.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">climbStairs</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">int</span>[] cache = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[n + <span class=\"number\">1</span>];</span><br><span class=\"line\">       <span class=\"keyword\">return</span> climbStairsWithCache(n, cache);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">climbStairsWithCache</span><span class=\"params\">(<span class=\"keyword\">int</span> n, <span class=\"keyword\">int</span>[] cache)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (cache[n] != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">return</span> cache[n];</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (n == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">           cache[n] = <span class=\"number\">1</span>;</span><br><span class=\"line\">           <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (n == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">           cache[n] = <span class=\"number\">2</span>;</span><br><span class=\"line\">           <span class=\"keyword\">return</span> <span class=\"number\">2</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">int</span> func2 = climbStairsWithCache(n - <span class=\"number\">2</span>, cache);</span><br><span class=\"line\">       cache[n - <span class=\"number\">2</span>] = func2;</span><br><span class=\"line\">       <span class=\"keyword\">int</span> func1 = climbStairsWithCache(n - <span class=\"number\">1</span>, cache);</span><br><span class=\"line\">       cache[n - <span class=\"number\">1</span>] = func1;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> func2 + func1;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">climbStairs</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">int</span> p = <span class=\"number\">0</span>, q = <span class=\"number\">0</span>, r = <span class=\"number\">1</span>;</span><br><span class=\"line\">       <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; ++i) &#123;</span><br><span class=\"line\">           p = q;</span><br><span class=\"line\">           q = r;</span><br><span class=\"line\">           r = p + q;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>"},{"title":"猫狗队列","date":"2020-06-10T12:53:17.000Z","_content":"\n### 题目\n\n宠物、狗和猫的类如下:\n\n```java\npublic class Pet {\n    private String type;\n\n    public Pet(String type) {\n      this.type = type;\n    }\n\n    public String getPetType() {\n      return this.type;\n    }\n  }\n\n  public class Dog extends Pet {\n    public Dog() {\n      super(\"dog\");\n    }\n  }\n\n  public class Cat extends Pet {\n    public Cat() {\n      super(\"cat\");\n    }\n  }\n```\n\n实现一种猫狗队列的结构, 要求如下:\n<!--more-->\n* add, 将cat或dog类的实例放入队列中\n* pollAll, 将队列中所有实例按照入队先后顺序出队\n* pollDog, 将队列中dog类实例按入队顺序出队\n* pollCat, 同上\n* isEmpty, 检查队列中是否还有元素\n* isDogEmpty, 检查队列中是否有dog类实例\n* isCatEmpty, 检查队列中是否有cat类实例\n\n### 思路\n\n用三个队列, 一个cat队列只存放cat实例, 一个dog队列只存放dog实例, 再用总队列存放所有实例.\n\n\n* 但是这样移除元素的时候, 总队列怎么更新? 比如队列顺序是 {cat1, dog1, dog2}, 调用pollDog(), 无法维护\n  \n* 加一层封装尝试解决问题, 用一个容器类PetQueueItem来封装Pet及其子类, 同时增加count属性来表示全局入队顺序\n\n* 果然没有什么问题是加一层封装解决不了的QAQ\n\n### 代码实现\n\n```Java\npublic class DogCatQueue {\n  public class Pet {\n    private String type;\n\n    public Pet(String type) {\n      this.type = type;\n    }\n\n    public String getPetType() {\n      return this.type;\n    }\n  }\n\n  public class Dog extends Pet {\n    public Dog() {\n      super(\"dog\");\n    }\n  }\n\n  public class Cat extends Pet {\n    public Cat() {\n      super(\"cat\");\n    }\n  }\n\n  public class PetQueueItem {\n    private Pet pet;\n    private Long count;\n\n    public PetQueueItem(Pet pet, Long count) {\n      this.pet = pet;\n      this.count = count;\n    }\n\n    public Pet getPet() {\n      return this.pet;\n    }\n\n    public Long getCount() {\n      return this.count;\n    }\n\n    public String getPetType() {\n      return this.pet.getPetType();\n    }\n  }\n\n  private Queue<PetQueueItem> dogQueue;\n  private Queue<PetQueueItem> catQueue;\n  private Long count;\n\n  public DogCatQueue() {\n    this.dogQueue = new LinkedList<PetQueueItem>();\n    this.catQueue = new LinkedList<PetQueueItem>();\n    this.count = 0L;\n  }\n\n  public void add(Pet pet) {\n    if (pet.getPetType().equals(\"dog\")) {\n      this.dogQueue.add(new PetQueueItem(pet, count++));\n    } else if (pet.getPetType().equals(\"cat\")) {\n      this.catQueue.add(new PetQueueItem(pet, count++));\n    } else {\n      throw new RuntimeException(\"Pet must be dog or cat!\");\n    }\n  }\n\n  public Pet pollAll() {\n    if (isDogEmpty() && isCatEmpty()) {\n      throw new RuntimeException(\"Your queue is empty!\");\n    }\n    if (!isDogEmpty() && !isCatEmpty()) {\n      if (dogQueue.peek().getCount() < catQueue.peek().getCount()) {\n        return dogQueue.poll().getPet();\n      } else {\n        return catQueue.poll().getPet();\n      }\n    }\n    if (!isDogEmpty()) {\n      return dogQueue.poll().getPet();\n    }\n    return catQueue.poll().getPet();\n  }\n\n  public Dog pollDog() {\n    if (isDogEmpty()) {\n      throw new RuntimeException(\"Your dog queue is empty!\");\n    }\n    return (Dog) dogQueue.poll().getPet();\n  }\n\n  public Cat pollCat() {\n    if (isCatEmpty()) {\n      throw new RuntimeException(\"Your cat queue is empty!\");\n    }\n    return (Cat) dogQueue.poll().getPet();\n  }\n\n  public Boolean isEmpty() {\n    return isDogEmpty() && isCatEmpty();\n  }\n\n  public Boolean isDogEmpty() {\n    return dogQueue.isEmpty();\n  }\n\n  public Boolean isCatEmpty() {\n    return catQueue.isEmpty();\n  }\n\n}\n```","source":"_posts/algorithm/猫狗队列.md","raw":"---\ntitle: 猫狗队列\ndate: 2020-06-10 20:53:17\ncategories: 算法日常练习\ntags:\n- 数据结构与算法\n- 队列\n---\n\n### 题目\n\n宠物、狗和猫的类如下:\n\n```java\npublic class Pet {\n    private String type;\n\n    public Pet(String type) {\n      this.type = type;\n    }\n\n    public String getPetType() {\n      return this.type;\n    }\n  }\n\n  public class Dog extends Pet {\n    public Dog() {\n      super(\"dog\");\n    }\n  }\n\n  public class Cat extends Pet {\n    public Cat() {\n      super(\"cat\");\n    }\n  }\n```\n\n实现一种猫狗队列的结构, 要求如下:\n<!--more-->\n* add, 将cat或dog类的实例放入队列中\n* pollAll, 将队列中所有实例按照入队先后顺序出队\n* pollDog, 将队列中dog类实例按入队顺序出队\n* pollCat, 同上\n* isEmpty, 检查队列中是否还有元素\n* isDogEmpty, 检查队列中是否有dog类实例\n* isCatEmpty, 检查队列中是否有cat类实例\n\n### 思路\n\n用三个队列, 一个cat队列只存放cat实例, 一个dog队列只存放dog实例, 再用总队列存放所有实例.\n\n\n* 但是这样移除元素的时候, 总队列怎么更新? 比如队列顺序是 {cat1, dog1, dog2}, 调用pollDog(), 无法维护\n  \n* 加一层封装尝试解决问题, 用一个容器类PetQueueItem来封装Pet及其子类, 同时增加count属性来表示全局入队顺序\n\n* 果然没有什么问题是加一层封装解决不了的QAQ\n\n### 代码实现\n\n```Java\npublic class DogCatQueue {\n  public class Pet {\n    private String type;\n\n    public Pet(String type) {\n      this.type = type;\n    }\n\n    public String getPetType() {\n      return this.type;\n    }\n  }\n\n  public class Dog extends Pet {\n    public Dog() {\n      super(\"dog\");\n    }\n  }\n\n  public class Cat extends Pet {\n    public Cat() {\n      super(\"cat\");\n    }\n  }\n\n  public class PetQueueItem {\n    private Pet pet;\n    private Long count;\n\n    public PetQueueItem(Pet pet, Long count) {\n      this.pet = pet;\n      this.count = count;\n    }\n\n    public Pet getPet() {\n      return this.pet;\n    }\n\n    public Long getCount() {\n      return this.count;\n    }\n\n    public String getPetType() {\n      return this.pet.getPetType();\n    }\n  }\n\n  private Queue<PetQueueItem> dogQueue;\n  private Queue<PetQueueItem> catQueue;\n  private Long count;\n\n  public DogCatQueue() {\n    this.dogQueue = new LinkedList<PetQueueItem>();\n    this.catQueue = new LinkedList<PetQueueItem>();\n    this.count = 0L;\n  }\n\n  public void add(Pet pet) {\n    if (pet.getPetType().equals(\"dog\")) {\n      this.dogQueue.add(new PetQueueItem(pet, count++));\n    } else if (pet.getPetType().equals(\"cat\")) {\n      this.catQueue.add(new PetQueueItem(pet, count++));\n    } else {\n      throw new RuntimeException(\"Pet must be dog or cat!\");\n    }\n  }\n\n  public Pet pollAll() {\n    if (isDogEmpty() && isCatEmpty()) {\n      throw new RuntimeException(\"Your queue is empty!\");\n    }\n    if (!isDogEmpty() && !isCatEmpty()) {\n      if (dogQueue.peek().getCount() < catQueue.peek().getCount()) {\n        return dogQueue.poll().getPet();\n      } else {\n        return catQueue.poll().getPet();\n      }\n    }\n    if (!isDogEmpty()) {\n      return dogQueue.poll().getPet();\n    }\n    return catQueue.poll().getPet();\n  }\n\n  public Dog pollDog() {\n    if (isDogEmpty()) {\n      throw new RuntimeException(\"Your dog queue is empty!\");\n    }\n    return (Dog) dogQueue.poll().getPet();\n  }\n\n  public Cat pollCat() {\n    if (isCatEmpty()) {\n      throw new RuntimeException(\"Your cat queue is empty!\");\n    }\n    return (Cat) dogQueue.poll().getPet();\n  }\n\n  public Boolean isEmpty() {\n    return isDogEmpty() && isCatEmpty();\n  }\n\n  public Boolean isDogEmpty() {\n    return dogQueue.isEmpty();\n  }\n\n  public Boolean isCatEmpty() {\n    return catQueue.isEmpty();\n  }\n\n}\n```","slug":"algorithm/猫狗队列","published":1,"updated":"2020-10-27T08:08:15.931Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckio9dwe8002hk8neu8k50et5","content":"<h3 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h3><p>宠物、狗和猫的类如下:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Pet</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String type;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Pet</span><span class=\"params\">(String type)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.type = type;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getPetType</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.type;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dog</span> <span class=\"keyword\">extends</span> <span class=\"title\">Pet</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Dog</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">super</span>(<span class=\"string\">\"dog\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cat</span> <span class=\"keyword\">extends</span> <span class=\"title\">Pet</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Cat</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">super</span>(<span class=\"string\">\"cat\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>实现一种猫狗队列的结构, 要求如下:</p>\n<a id=\"more\"></a>\n<ul>\n<li>add, 将cat或dog类的实例放入队列中</li>\n<li>pollAll, 将队列中所有实例按照入队先后顺序出队</li>\n<li>pollDog, 将队列中dog类实例按入队顺序出队</li>\n<li>pollCat, 同上</li>\n<li>isEmpty, 检查队列中是否还有元素</li>\n<li>isDogEmpty, 检查队列中是否有dog类实例</li>\n<li>isCatEmpty, 检查队列中是否有cat类实例</li>\n</ul>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>用三个队列, 一个cat队列只存放cat实例, 一个dog队列只存放dog实例, 再用总队列存放所有实例.</p>\n<ul>\n<li><p>但是这样移除元素的时候, 总队列怎么更新? 比如队列顺序是 {cat1, dog1, dog2}, 调用pollDog(), 无法维护</p>\n</li>\n<li><p>加一层封装尝试解决问题, 用一个容器类PetQueueItem来封装Pet及其子类, 同时增加count属性来表示全局入队顺序</p>\n</li>\n<li><p>果然没有什么问题是加一层封装解决不了的QAQ</p>\n</li>\n</ul>\n<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DogCatQueue</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Pet</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String type;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Pet</span><span class=\"params\">(String type)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.type = type;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getPetType</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.type;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dog</span> <span class=\"keyword\">extends</span> <span class=\"title\">Pet</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Dog</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">super</span>(<span class=\"string\">\"dog\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cat</span> <span class=\"keyword\">extends</span> <span class=\"title\">Pet</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Cat</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">super</span>(<span class=\"string\">\"cat\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PetQueueItem</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Pet pet;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Long count;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">PetQueueItem</span><span class=\"params\">(Pet pet, Long count)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.pet = pet;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.count = count;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Pet <span class=\"title\">getPet</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.pet;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Long <span class=\"title\">getCount</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.count;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getPetType</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.pet.getPetType();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> Queue&lt;PetQueueItem&gt; dogQueue;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Queue&lt;PetQueueItem&gt; catQueue;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Long count;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DogCatQueue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.dogQueue = <span class=\"keyword\">new</span> LinkedList&lt;PetQueueItem&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.catQueue = <span class=\"keyword\">new</span> LinkedList&lt;PetQueueItem&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.count = <span class=\"number\">0L</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(Pet pet)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pet.getPetType().equals(<span class=\"string\">\"dog\"</span>)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.dogQueue.add(<span class=\"keyword\">new</span> PetQueueItem(pet, count++));</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (pet.getPetType().equals(<span class=\"string\">\"cat\"</span>)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.catQueue.add(<span class=\"keyword\">new</span> PetQueueItem(pet, count++));</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"Pet must be dog or cat!\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Pet <span class=\"title\">pollAll</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isDogEmpty() &amp;&amp; isCatEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"Your queue is empty!\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isDogEmpty() &amp;&amp; !isCatEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (dogQueue.peek().getCount() &lt; catQueue.peek().getCount()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dogQueue.poll().getPet();</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> catQueue.poll().getPet();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isDogEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> dogQueue.poll().getPet();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> catQueue.poll().getPet();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Dog <span class=\"title\">pollDog</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isDogEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"Your dog queue is empty!\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (Dog) dogQueue.poll().getPet();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Cat <span class=\"title\">pollCat</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isCatEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"Your cat queue is empty!\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (Cat) dogQueue.poll().getPet();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Boolean <span class=\"title\">isEmpty</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> isDogEmpty() &amp;&amp; isCatEmpty();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Boolean <span class=\"title\">isDogEmpty</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dogQueue.isEmpty();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Boolean <span class=\"title\">isCatEmpty</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> catQueue.isEmpty();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h3 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h3><p>宠物、狗和猫的类如下:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Pet</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String type;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Pet</span><span class=\"params\">(String type)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.type = type;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getPetType</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.type;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dog</span> <span class=\"keyword\">extends</span> <span class=\"title\">Pet</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Dog</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">super</span>(<span class=\"string\">\"dog\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cat</span> <span class=\"keyword\">extends</span> <span class=\"title\">Pet</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Cat</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">super</span>(<span class=\"string\">\"cat\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>实现一种猫狗队列的结构, 要求如下:</p>","more":"<ul>\n<li>add, 将cat或dog类的实例放入队列中</li>\n<li>pollAll, 将队列中所有实例按照入队先后顺序出队</li>\n<li>pollDog, 将队列中dog类实例按入队顺序出队</li>\n<li>pollCat, 同上</li>\n<li>isEmpty, 检查队列中是否还有元素</li>\n<li>isDogEmpty, 检查队列中是否有dog类实例</li>\n<li>isCatEmpty, 检查队列中是否有cat类实例</li>\n</ul>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>用三个队列, 一个cat队列只存放cat实例, 一个dog队列只存放dog实例, 再用总队列存放所有实例.</p>\n<ul>\n<li><p>但是这样移除元素的时候, 总队列怎么更新? 比如队列顺序是 {cat1, dog1, dog2}, 调用pollDog(), 无法维护</p>\n</li>\n<li><p>加一层封装尝试解决问题, 用一个容器类PetQueueItem来封装Pet及其子类, 同时增加count属性来表示全局入队顺序</p>\n</li>\n<li><p>果然没有什么问题是加一层封装解决不了的QAQ</p>\n</li>\n</ul>\n<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DogCatQueue</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Pet</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String type;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Pet</span><span class=\"params\">(String type)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.type = type;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getPetType</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.type;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dog</span> <span class=\"keyword\">extends</span> <span class=\"title\">Pet</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Dog</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">super</span>(<span class=\"string\">\"dog\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cat</span> <span class=\"keyword\">extends</span> <span class=\"title\">Pet</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Cat</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">super</span>(<span class=\"string\">\"cat\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PetQueueItem</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Pet pet;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Long count;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">PetQueueItem</span><span class=\"params\">(Pet pet, Long count)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.pet = pet;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.count = count;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Pet <span class=\"title\">getPet</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.pet;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Long <span class=\"title\">getCount</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.count;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getPetType</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.pet.getPetType();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> Queue&lt;PetQueueItem&gt; dogQueue;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Queue&lt;PetQueueItem&gt; catQueue;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Long count;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DogCatQueue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.dogQueue = <span class=\"keyword\">new</span> LinkedList&lt;PetQueueItem&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.catQueue = <span class=\"keyword\">new</span> LinkedList&lt;PetQueueItem&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.count = <span class=\"number\">0L</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(Pet pet)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pet.getPetType().equals(<span class=\"string\">\"dog\"</span>)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.dogQueue.add(<span class=\"keyword\">new</span> PetQueueItem(pet, count++));</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (pet.getPetType().equals(<span class=\"string\">\"cat\"</span>)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.catQueue.add(<span class=\"keyword\">new</span> PetQueueItem(pet, count++));</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"Pet must be dog or cat!\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Pet <span class=\"title\">pollAll</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isDogEmpty() &amp;&amp; isCatEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"Your queue is empty!\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isDogEmpty() &amp;&amp; !isCatEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (dogQueue.peek().getCount() &lt; catQueue.peek().getCount()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dogQueue.poll().getPet();</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> catQueue.poll().getPet();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isDogEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> dogQueue.poll().getPet();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> catQueue.poll().getPet();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Dog <span class=\"title\">pollDog</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isDogEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"Your dog queue is empty!\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (Dog) dogQueue.poll().getPet();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Cat <span class=\"title\">pollCat</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isCatEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"Your cat queue is empty!\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (Cat) dogQueue.poll().getPet();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Boolean <span class=\"title\">isEmpty</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> isDogEmpty() &amp;&amp; isCatEmpty();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Boolean <span class=\"title\">isDogEmpty</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dogQueue.isEmpty();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Boolean <span class=\"title\">isCatEmpty</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> catQueue.isEmpty();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"用一个栈实现另一个栈的排序","date":"2020-06-11T15:16:32.000Z","_content":"\n### 题目\n\n一个栈中的元素类型为整型, 现在想将栈从顶到底按从大到小的顺序排序, 只需申请一个栈.\n除此之外, 可以申请新的变量,但不能申请额外的数据结构, 如何完成排序?\n\n### 思路\n\n* 利用两个栈+临时变量, 通过比较, 使得辅助栈中元素有序\n申请一个辅助栈, 将原始栈的元素挨个取出, 通过比较最终**使得辅助栈内的元素顶->底, 小->大排序**.\n<!--more-->\n然后再将辅助栈的元素pop()并push()到原始栈中即可.\n\n* 实现比较\n假设原始栈stack, 辅助栈helpStack, 变量temp = stack.pop()\ntemp与辅助栈helpStack栈顶元素比较:\n  * 如果temp小, 则直接入help;\n  * **如果temp大, 将helpStack的栈顶元素存回stack中**, 直到temp <= helpStack.pop(), 再将temp入栈helpstack\n\n### 代码实现\n\n```java\npublic static void sortStackByStack(Stack<Integer> stack) {\n    Stack<Integer> helpStack = new Stack<Integer>();\n\n    while (!stack.isEmpty()) {\n      int temp = stack.pop();\n      while (!helpStack.isEmpty() && helpStack.peek() < temp) {\n        stack.push(helpStack.pop());\n      }\n      helpStack.push(temp);\n    }\n    while (!helpStack.isEmpty()) {\n      stack.push(helpStack.pop());\n    }\n  }\n```","source":"_posts/algorithm/用一个栈实现另一个栈的排序.md","raw":"---\ntitle: 用一个栈实现另一个栈的排序\ndate: 2020-06-11 23:16:32\ncategories: 算法日常练习\ntags:\n- 数据结构与算法\n- 栈\n---\n\n### 题目\n\n一个栈中的元素类型为整型, 现在想将栈从顶到底按从大到小的顺序排序, 只需申请一个栈.\n除此之外, 可以申请新的变量,但不能申请额外的数据结构, 如何完成排序?\n\n### 思路\n\n* 利用两个栈+临时变量, 通过比较, 使得辅助栈中元素有序\n申请一个辅助栈, 将原始栈的元素挨个取出, 通过比较最终**使得辅助栈内的元素顶->底, 小->大排序**.\n<!--more-->\n然后再将辅助栈的元素pop()并push()到原始栈中即可.\n\n* 实现比较\n假设原始栈stack, 辅助栈helpStack, 变量temp = stack.pop()\ntemp与辅助栈helpStack栈顶元素比较:\n  * 如果temp小, 则直接入help;\n  * **如果temp大, 将helpStack的栈顶元素存回stack中**, 直到temp <= helpStack.pop(), 再将temp入栈helpstack\n\n### 代码实现\n\n```java\npublic static void sortStackByStack(Stack<Integer> stack) {\n    Stack<Integer> helpStack = new Stack<Integer>();\n\n    while (!stack.isEmpty()) {\n      int temp = stack.pop();\n      while (!helpStack.isEmpty() && helpStack.peek() < temp) {\n        stack.push(helpStack.pop());\n      }\n      helpStack.push(temp);\n    }\n    while (!helpStack.isEmpty()) {\n      stack.push(helpStack.pop());\n    }\n  }\n```","slug":"algorithm/用一个栈实现另一个栈的排序","published":1,"updated":"2020-10-27T08:08:15.932Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckio9dwea002kk8negbnm0prs","content":"<h3 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h3><p>一个栈中的元素类型为整型, 现在想将栈从顶到底按从大到小的顺序排序, 只需申请一个栈.<br>除此之外, 可以申请新的变量,但不能申请额外的数据结构, 如何完成排序?</p>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><ul>\n<li><p>利用两个栈+临时变量, 通过比较, 使得辅助栈中元素有序<br>申请一个辅助栈, 将原始栈的元素挨个取出, 通过比较最终<strong>使得辅助栈内的元素顶-&gt;底, 小-&gt;大排序</strong>.</p>\n<a id=\"more\"></a>\n<p>然后再将辅助栈的元素pop()并push()到原始栈中即可.</p>\n</li>\n<li><p>实现比较<br>假设原始栈stack, 辅助栈helpStack, 变量temp = stack.pop()<br>temp与辅助栈helpStack栈顶元素比较:</p>\n<ul>\n<li>如果temp小, 则直接入help;</li>\n<li><strong>如果temp大, 将helpStack的栈顶元素存回stack中</strong>, 直到temp &lt;= helpStack.pop(), 再将temp入栈helpstack</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sortStackByStack</span><span class=\"params\">(Stack&lt;Integer&gt; stack)</span> </span>&#123;</span><br><span class=\"line\">    Stack&lt;Integer&gt; helpStack = <span class=\"keyword\">new</span> Stack&lt;Integer&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!stack.isEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">int</span> temp = stack.pop();</span><br><span class=\"line\">      <span class=\"keyword\">while</span> (!helpStack.isEmpty() &amp;&amp; helpStack.peek() &lt; temp) &#123;</span><br><span class=\"line\">        stack.push(helpStack.pop());</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      helpStack.push(temp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!helpStack.isEmpty()) &#123;</span><br><span class=\"line\">      stack.push(helpStack.pop());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h3 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h3><p>一个栈中的元素类型为整型, 现在想将栈从顶到底按从大到小的顺序排序, 只需申请一个栈.<br>除此之外, 可以申请新的变量,但不能申请额外的数据结构, 如何完成排序?</p>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><ul>\n<li><p>利用两个栈+临时变量, 通过比较, 使得辅助栈中元素有序<br>申请一个辅助栈, 将原始栈的元素挨个取出, 通过比较最终<strong>使得辅助栈内的元素顶-&gt;底, 小-&gt;大排序</strong>.</p>","more":"<p>然后再将辅助栈的元素pop()并push()到原始栈中即可.</p>\n</li>\n<li><p>实现比较<br>假设原始栈stack, 辅助栈helpStack, 变量temp = stack.pop()<br>temp与辅助栈helpStack栈顶元素比较:</p>\n<ul>\n<li>如果temp小, 则直接入help;</li>\n<li><strong>如果temp大, 将helpStack的栈顶元素存回stack中</strong>, 直到temp &lt;= helpStack.pop(), 再将temp入栈helpstack</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sortStackByStack</span><span class=\"params\">(Stack&lt;Integer&gt; stack)</span> </span>&#123;</span><br><span class=\"line\">    Stack&lt;Integer&gt; helpStack = <span class=\"keyword\">new</span> Stack&lt;Integer&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!stack.isEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">int</span> temp = stack.pop();</span><br><span class=\"line\">      <span class=\"keyword\">while</span> (!helpStack.isEmpty() &amp;&amp; helpStack.peek() &lt; temp) &#123;</span><br><span class=\"line\">        stack.push(helpStack.pop());</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      helpStack.push(temp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!helpStack.isEmpty()) &#123;</span><br><span class=\"line\">      stack.push(helpStack.pop());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>"},{"title":"由两个栈组成的队列","date":"2020-06-08T13:53:56.000Z","_content":"\n### 题目\n\n编写一个类, 用两个栈实现队列, 支持队列的基本操作(add, poll, peek).\n\n### 思路\n\n栈是FILO, 队列是FIFO.\n 一个栈stackPush按用户操作顺序存储, 提供入队操作.\n 另一个栈stackPop按照相反顺序存储, 提供出队操作.\n\n<!--more-->\n### 代码实现\n\n```java\npublic class TwoStacksQueue {\n  private Stack<Integer> stackPush;\n  private Stack<Integer> stackPop;\n\n  public TwoStacksQueue() {\n    stackPush = new Stack<Integer>();\n    stackPop = new Stack<Integer>();\n  }\n\n  /**\n   * 将stackPush的元素取出并放入stackPop\n   * <b>重点在于stackPop不为空， stackPush绝对不能向stackPop压入数据</b>\n   * */\n  private void pushToPop() {\n    if (stackPop.isEmpty()) {\n      while (!stackPush.isEmpty()) {\n        stackPop.push(stackPush.pop());\n      }\n    }\n  }\n\n  /**\n   * 入队\n   * */\n  public void add(int item) {\n    stackPush.push(item);\n    pushToPop();\n  }\n\n  /**\n   * 出队\n   * */\n  public int poll() {\n    if (stackPush.isEmpty() && stackPop.isEmpty()) {\n      throw new RuntimeException(\"Your queue is empty.\");\n    }\n    pushToPop();\n    return stackPop.pop();\n  }\n\n  /**\n   * 获取队首元素\n   * */\n  public int peek() {\n    if (stackPush.isEmpty() && stackPop.isEmpty()) {\n      throw new RuntimeException(\"Your queue is empty.\");\n    }\n    pushToPop();\n    return stackPop.peek();\n  }\n}\n```\n","source":"_posts/algorithm/由两个栈组成的队列.md","raw":"---\ntitle: 由两个栈组成的队列\ndate: 2020-06-08 21:53:56\ncategories: 算法日常练习\ntags:\n- 数据结构与算法\n- 栈\n---\n\n### 题目\n\n编写一个类, 用两个栈实现队列, 支持队列的基本操作(add, poll, peek).\n\n### 思路\n\n栈是FILO, 队列是FIFO.\n 一个栈stackPush按用户操作顺序存储, 提供入队操作.\n 另一个栈stackPop按照相反顺序存储, 提供出队操作.\n\n<!--more-->\n### 代码实现\n\n```java\npublic class TwoStacksQueue {\n  private Stack<Integer> stackPush;\n  private Stack<Integer> stackPop;\n\n  public TwoStacksQueue() {\n    stackPush = new Stack<Integer>();\n    stackPop = new Stack<Integer>();\n  }\n\n  /**\n   * 将stackPush的元素取出并放入stackPop\n   * <b>重点在于stackPop不为空， stackPush绝对不能向stackPop压入数据</b>\n   * */\n  private void pushToPop() {\n    if (stackPop.isEmpty()) {\n      while (!stackPush.isEmpty()) {\n        stackPop.push(stackPush.pop());\n      }\n    }\n  }\n\n  /**\n   * 入队\n   * */\n  public void add(int item) {\n    stackPush.push(item);\n    pushToPop();\n  }\n\n  /**\n   * 出队\n   * */\n  public int poll() {\n    if (stackPush.isEmpty() && stackPop.isEmpty()) {\n      throw new RuntimeException(\"Your queue is empty.\");\n    }\n    pushToPop();\n    return stackPop.pop();\n  }\n\n  /**\n   * 获取队首元素\n   * */\n  public int peek() {\n    if (stackPush.isEmpty() && stackPop.isEmpty()) {\n      throw new RuntimeException(\"Your queue is empty.\");\n    }\n    pushToPop();\n    return stackPop.peek();\n  }\n}\n```\n","slug":"algorithm/由两个栈组成的队列","published":1,"updated":"2020-10-27T08:08:15.932Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckio9dwec002ok8neab7a4oqw","content":"<h3 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h3><p>编写一个类, 用两个栈实现队列, 支持队列的基本操作(add, poll, peek).</p>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>栈是FILO, 队列是FIFO.<br> 一个栈stackPush按用户操作顺序存储, 提供入队操作.<br> 另一个栈stackPop按照相反顺序存储, 提供出队操作.</p>\n<a id=\"more\"></a>\n<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TwoStacksQueue</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Stack&lt;Integer&gt; stackPush;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Stack&lt;Integer&gt; stackPop;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TwoStacksQueue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    stackPush = <span class=\"keyword\">new</span> Stack&lt;Integer&gt;();</span><br><span class=\"line\">    stackPop = <span class=\"keyword\">new</span> Stack&lt;Integer&gt;();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 将stackPush的元素取出并放入stackPop</span></span><br><span class=\"line\"><span class=\"comment\">   * &lt;b&gt;重点在于stackPop不为空， stackPush绝对不能向stackPop压入数据&lt;/b&gt;</span></span><br><span class=\"line\"><span class=\"comment\">   * */</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">pushToPop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (stackPop.isEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">while</span> (!stackPush.isEmpty()) &#123;</span><br><span class=\"line\">        stackPop.push(stackPush.pop());</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 入队</span></span><br><span class=\"line\"><span class=\"comment\">   * */</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> item)</span> </span>&#123;</span><br><span class=\"line\">    stackPush.push(item);</span><br><span class=\"line\">    pushToPop();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 出队</span></span><br><span class=\"line\"><span class=\"comment\">   * */</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">poll</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (stackPush.isEmpty() &amp;&amp; stackPop.isEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"Your queue is empty.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    pushToPop();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> stackPop.pop();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 获取队首元素</span></span><br><span class=\"line\"><span class=\"comment\">   * */</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">peek</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (stackPush.isEmpty() &amp;&amp; stackPop.isEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"Your queue is empty.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    pushToPop();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> stackPop.peek();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<h3 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h3><p>编写一个类, 用两个栈实现队列, 支持队列的基本操作(add, poll, peek).</p>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>栈是FILO, 队列是FIFO.<br> 一个栈stackPush按用户操作顺序存储, 提供入队操作.<br> 另一个栈stackPop按照相反顺序存储, 提供出队操作.</p>","more":"<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TwoStacksQueue</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Stack&lt;Integer&gt; stackPush;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Stack&lt;Integer&gt; stackPop;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TwoStacksQueue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    stackPush = <span class=\"keyword\">new</span> Stack&lt;Integer&gt;();</span><br><span class=\"line\">    stackPop = <span class=\"keyword\">new</span> Stack&lt;Integer&gt;();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 将stackPush的元素取出并放入stackPop</span></span><br><span class=\"line\"><span class=\"comment\">   * &lt;b&gt;重点在于stackPop不为空， stackPush绝对不能向stackPop压入数据&lt;/b&gt;</span></span><br><span class=\"line\"><span class=\"comment\">   * */</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">pushToPop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (stackPop.isEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">while</span> (!stackPush.isEmpty()) &#123;</span><br><span class=\"line\">        stackPop.push(stackPush.pop());</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 入队</span></span><br><span class=\"line\"><span class=\"comment\">   * */</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> item)</span> </span>&#123;</span><br><span class=\"line\">    stackPush.push(item);</span><br><span class=\"line\">    pushToPop();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 出队</span></span><br><span class=\"line\"><span class=\"comment\">   * */</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">poll</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (stackPush.isEmpty() &amp;&amp; stackPop.isEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"Your queue is empty.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    pushToPop();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> stackPop.pop();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 获取队首元素</span></span><br><span class=\"line\"><span class=\"comment\">   * */</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">peek</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (stackPush.isEmpty() &amp;&amp; stackPop.isEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"Your queue is empty.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    pushToPop();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> stackPop.peek();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"移动零","date":"2020-06-15T13:51:21.000Z","_content":"\n### 题目\n\n给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。\n\n示例:\n\n输入: [0,1,0,3,12]\n输出: [1,3,12,0,0]\n说明:\n\n必须在原数组上操作，不能拷贝额外的数组.\n尽量减少操作次数.\n\n### 思路\n\n* 最初想法: \n  1. 遍历数组,  维护首尾两指针, 若当前元素为0, 则与尾指针指向的元素互换位置\n  2. 每次循环, 头指针加一, 尾指针指向元素若不为0则一直减一\n  3. 当头指针+1=尾指针, 循环结束.\n\n但是这样得到的数组并不能保证原来顺序.\n\n* 实现:\n  1. 遍历两次, 第一次获取到不为0的元素并按照顺序放到数组\n  2. 第二次将剩余置空\n\n### 代码实现\n\n```Java\npublic static void moveZeroes(int[] nums) {\n    if (nums == null || nums.length == 0) {\n      return;\n    }\n    int j = 0;\n    for (int i = 0; i < nums.length; i++) {\n        if (nums[i] != 0) {\n            nums[j++] = nums[i];\n        }\n    }\n    while (j < nums.length) {\n        nums[j++] = 0;\n    }\n}\n```","source":"_posts/algorithm/移动零.md","raw":"---\ntitle: 移动零\ndate: 2020-06-15 21:51:21\ncategories: 算法日常练习\ntags:\n- 数据结构与算法\n- 数组\n---\n\n### 题目\n\n给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。\n\n示例:\n\n输入: [0,1,0,3,12]\n输出: [1,3,12,0,0]\n说明:\n\n必须在原数组上操作，不能拷贝额外的数组.\n尽量减少操作次数.\n\n### 思路\n\n* 最初想法: \n  1. 遍历数组,  维护首尾两指针, 若当前元素为0, 则与尾指针指向的元素互换位置\n  2. 每次循环, 头指针加一, 尾指针指向元素若不为0则一直减一\n  3. 当头指针+1=尾指针, 循环结束.\n\n但是这样得到的数组并不能保证原来顺序.\n\n* 实现:\n  1. 遍历两次, 第一次获取到不为0的元素并按照顺序放到数组\n  2. 第二次将剩余置空\n\n### 代码实现\n\n```Java\npublic static void moveZeroes(int[] nums) {\n    if (nums == null || nums.length == 0) {\n      return;\n    }\n    int j = 0;\n    for (int i = 0; i < nums.length; i++) {\n        if (nums[i] != 0) {\n            nums[j++] = nums[i];\n        }\n    }\n    while (j < nums.length) {\n        nums[j++] = 0;\n    }\n}\n```","slug":"algorithm/移动零","published":1,"updated":"2020-10-27T08:08:15.933Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckio9dwed002rk8nec8vrqtu5","content":"<h3 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h3><p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p>\n<p>示例:</p>\n<p>输入: [0,1,0,3,12]<br>输出: [1,3,12,0,0]<br>说明:</p>\n<p>必须在原数组上操作，不能拷贝额外的数组.<br>尽量减少操作次数.</p>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><ul>\n<li>最初想法: <ol>\n<li>遍历数组,  维护首尾两指针, 若当前元素为0, 则与尾指针指向的元素互换位置</li>\n<li>每次循环, 头指针加一, 尾指针指向元素若不为0则一直减一</li>\n<li>当头指针+1=尾指针, 循环结束.</li>\n</ol>\n</li>\n</ul>\n<p>但是这样得到的数组并不能保证原来顺序.</p>\n<ul>\n<li>实现:<ol>\n<li>遍历两次, 第一次获取到不为0的元素并按照顺序放到数组</li>\n<li>第二次将剩余置空</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">moveZeroes</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nums == <span class=\"keyword\">null</span> || nums.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums[i] != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            nums[j++] = nums[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (j &lt; nums.length) &#123;</span><br><span class=\"line\">        nums[j++] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h3><p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p>\n<p>示例:</p>\n<p>输入: [0,1,0,3,12]<br>输出: [1,3,12,0,0]<br>说明:</p>\n<p>必须在原数组上操作，不能拷贝额外的数组.<br>尽量减少操作次数.</p>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><ul>\n<li>最初想法: <ol>\n<li>遍历数组,  维护首尾两指针, 若当前元素为0, 则与尾指针指向的元素互换位置</li>\n<li>每次循环, 头指针加一, 尾指针指向元素若不为0则一直减一</li>\n<li>当头指针+1=尾指针, 循环结束.</li>\n</ol>\n</li>\n</ul>\n<p>但是这样得到的数组并不能保证原来顺序.</p>\n<ul>\n<li>实现:<ol>\n<li>遍历两次, 第一次获取到不为0的元素并按照顺序放到数组</li>\n<li>第二次将剩余置空</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">moveZeroes</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nums == <span class=\"keyword\">null</span> || nums.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums[i] != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            nums[j++] = nums[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (j &lt; nums.length) &#123;</span><br><span class=\"line\">        nums[j++] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"设计模式0-开篇","date":"2020-06-17T03:59:10.000Z","_content":"\n### 为什么需要模式?\n\n不想重复造轮子!\n\n<!-- graph -->\n人类解决问题的思维过程是相似的: \n\n![问题解决的思维过程](/images/designpatterns/problemresolve.png)\n\n<!--more-->\n在生活中, 如果遇到问题, 我们往往根据已有的知识、经验来找到解决问题的方案、策略.\n\n在技术生活中, 我们也会遇到经常发生的、相似的问题, 慢慢前辈们通过反复`明确问题`-`提出假设`-`检验假设`的过程, 最终总结出了一些解决方案.\n\n对于解决常见问题的这些解决方案, 称为**设计模式**.\n\n### 常见设计模式\n\n下图是四人帮总结的常见设计模式的关系:\n\n![Design Pattern Relationships](/images/designpatterns/designPatterns0.png)\n\n### 设计模式分类\n\n在面向对象的程序中通常将设计模式分为以下三类:\n\n* 创建型\n* 结构型\n* 行为型\n  \n  下面我们简单解释下每种类型:\n\n#### 创建型模式\n\n与类如何构造对象有关. 乍看起来比我们平时“new一个对象”麻烦, 但是在后期维护、扩展过程中会有很大优势.\n所以创建型模式对我们程序中**封装对象创建的过程**提供了优秀的范式. \n\n    * Builder Pattern\n    * Prototype Pattern\n    * Singleton Pattern\n    * Abstract Factory Pattern\n\n#### 结构型模式\n\n与类的结构有关. 比如类的组成或构造方式.\n\n    * Adapter Pattern\n    * Bridge Pattern\n    * Composite Pattern\n    * Decorator Pattern\n    * Facade Pattern\n    * Flyweight Pattern\n    * Proxy Pattern\n\n#### 行为型模式\n\n规定了类和对象之间的交互以及责任的委派.\n\n    * Interpreter Pattern\n    * Template Pattern\n    * Chain of Responsibility Pattern\n    * Command Pattern\n    * Iterator Pattern\n    * Mediator Pattern\n    * Memento Pattern\n    * Observer Pattern\n    * State Pattern\n    * Strategy Pattern\n    * Visitor Pattern\n","source":"_posts/designpattern/设计模式0-开篇.md","raw":"---\ntitle: 设计模式0-开篇\ndate: 2020-06-17 11:59:10\ncategories: 设计模式\ntags:\n- 设计模式\n---\n\n### 为什么需要模式?\n\n不想重复造轮子!\n\n<!-- graph -->\n人类解决问题的思维过程是相似的: \n\n![问题解决的思维过程](/images/designpatterns/problemresolve.png)\n\n<!--more-->\n在生活中, 如果遇到问题, 我们往往根据已有的知识、经验来找到解决问题的方案、策略.\n\n在技术生活中, 我们也会遇到经常发生的、相似的问题, 慢慢前辈们通过反复`明确问题`-`提出假设`-`检验假设`的过程, 最终总结出了一些解决方案.\n\n对于解决常见问题的这些解决方案, 称为**设计模式**.\n\n### 常见设计模式\n\n下图是四人帮总结的常见设计模式的关系:\n\n![Design Pattern Relationships](/images/designpatterns/designPatterns0.png)\n\n### 设计模式分类\n\n在面向对象的程序中通常将设计模式分为以下三类:\n\n* 创建型\n* 结构型\n* 行为型\n  \n  下面我们简单解释下每种类型:\n\n#### 创建型模式\n\n与类如何构造对象有关. 乍看起来比我们平时“new一个对象”麻烦, 但是在后期维护、扩展过程中会有很大优势.\n所以创建型模式对我们程序中**封装对象创建的过程**提供了优秀的范式. \n\n    * Builder Pattern\n    * Prototype Pattern\n    * Singleton Pattern\n    * Abstract Factory Pattern\n\n#### 结构型模式\n\n与类的结构有关. 比如类的组成或构造方式.\n\n    * Adapter Pattern\n    * Bridge Pattern\n    * Composite Pattern\n    * Decorator Pattern\n    * Facade Pattern\n    * Flyweight Pattern\n    * Proxy Pattern\n\n#### 行为型模式\n\n规定了类和对象之间的交互以及责任的委派.\n\n    * Interpreter Pattern\n    * Template Pattern\n    * Chain of Responsibility Pattern\n    * Command Pattern\n    * Iterator Pattern\n    * Mediator Pattern\n    * Memento Pattern\n    * Observer Pattern\n    * State Pattern\n    * Strategy Pattern\n    * Visitor Pattern\n","slug":"designpattern/设计模式0-开篇","published":1,"updated":"2020-10-27T08:08:15.936Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckio9dwef002vk8nex4z9347f","content":"<h3 id=\"为什么需要模式\"><a href=\"#为什么需要模式\" class=\"headerlink\" title=\"为什么需要模式?\"></a>为什么需要模式?</h3><p>不想重复造轮子!</p>\n<!-- graph -->\n<p>人类解决问题的思维过程是相似的: </p>\n<p><img src=\"/images/designpatterns/problemresolve.png\" alt=\"问题解决的思维过程\"></p>\n<a id=\"more\"></a>\n<p>在生活中, 如果遇到问题, 我们往往根据已有的知识、经验来找到解决问题的方案、策略.</p>\n<p>在技术生活中, 我们也会遇到经常发生的、相似的问题, 慢慢前辈们通过反复<code>明确问题</code>-<code>提出假设</code>-<code>检验假设</code>的过程, 最终总结出了一些解决方案.</p>\n<p>对于解决常见问题的这些解决方案, 称为<strong>设计模式</strong>.</p>\n<h3 id=\"常见设计模式\"><a href=\"#常见设计模式\" class=\"headerlink\" title=\"常见设计模式\"></a>常见设计模式</h3><p>下图是四人帮总结的常见设计模式的关系:</p>\n<p><img src=\"/images/designpatterns/designPatterns0.png\" alt=\"Design Pattern Relationships\"></p>\n<h3 id=\"设计模式分类\"><a href=\"#设计模式分类\" class=\"headerlink\" title=\"设计模式分类\"></a>设计模式分类</h3><p>在面向对象的程序中通常将设计模式分为以下三类:</p>\n<ul>\n<li><p>创建型</p>\n</li>\n<li><p>结构型</p>\n</li>\n<li><p>行为型</p>\n<p>下面我们简单解释下每种类型:</p>\n</li>\n</ul>\n<h4 id=\"创建型模式\"><a href=\"#创建型模式\" class=\"headerlink\" title=\"创建型模式\"></a>创建型模式</h4><p>与类如何构造对象有关. 乍看起来比我们平时“new一个对象”麻烦, 但是在后期维护、扩展过程中会有很大优势.<br>所以创建型模式对我们程序中<strong>封装对象创建的过程</strong>提供了优秀的范式. </p>\n<pre><code>* Builder Pattern\n* Prototype Pattern\n* Singleton Pattern\n* Abstract Factory Pattern</code></pre><h4 id=\"结构型模式\"><a href=\"#结构型模式\" class=\"headerlink\" title=\"结构型模式\"></a>结构型模式</h4><p>与类的结构有关. 比如类的组成或构造方式.</p>\n<pre><code>* Adapter Pattern\n* Bridge Pattern\n* Composite Pattern\n* Decorator Pattern\n* Facade Pattern\n* Flyweight Pattern\n* Proxy Pattern</code></pre><h4 id=\"行为型模式\"><a href=\"#行为型模式\" class=\"headerlink\" title=\"行为型模式\"></a>行为型模式</h4><p>规定了类和对象之间的交互以及责任的委派.</p>\n<pre><code>* Interpreter Pattern\n* Template Pattern\n* Chain of Responsibility Pattern\n* Command Pattern\n* Iterator Pattern\n* Mediator Pattern\n* Memento Pattern\n* Observer Pattern\n* State Pattern\n* Strategy Pattern\n* Visitor Pattern</code></pre>","site":{"data":{}},"excerpt":"<h3 id=\"为什么需要模式\"><a href=\"#为什么需要模式\" class=\"headerlink\" title=\"为什么需要模式?\"></a>为什么需要模式?</h3><p>不想重复造轮子!</p>\n<!-- graph -->\n<p>人类解决问题的思维过程是相似的: </p>\n<p><img src=\"/images/designpatterns/problemresolve.png\" alt=\"问题解决的思维过程\"></p>","more":"<p>在生活中, 如果遇到问题, 我们往往根据已有的知识、经验来找到解决问题的方案、策略.</p>\n<p>在技术生活中, 我们也会遇到经常发生的、相似的问题, 慢慢前辈们通过反复<code>明确问题</code>-<code>提出假设</code>-<code>检验假设</code>的过程, 最终总结出了一些解决方案.</p>\n<p>对于解决常见问题的这些解决方案, 称为<strong>设计模式</strong>.</p>\n<h3 id=\"常见设计模式\"><a href=\"#常见设计模式\" class=\"headerlink\" title=\"常见设计模式\"></a>常见设计模式</h3><p>下图是四人帮总结的常见设计模式的关系:</p>\n<p><img src=\"/images/designpatterns/designPatterns0.png\" alt=\"Design Pattern Relationships\"></p>\n<h3 id=\"设计模式分类\"><a href=\"#设计模式分类\" class=\"headerlink\" title=\"设计模式分类\"></a>设计模式分类</h3><p>在面向对象的程序中通常将设计模式分为以下三类:</p>\n<ul>\n<li><p>创建型</p>\n</li>\n<li><p>结构型</p>\n</li>\n<li><p>行为型</p>\n<p>下面我们简单解释下每种类型:</p>\n</li>\n</ul>\n<h4 id=\"创建型模式\"><a href=\"#创建型模式\" class=\"headerlink\" title=\"创建型模式\"></a>创建型模式</h4><p>与类如何构造对象有关. 乍看起来比我们平时“new一个对象”麻烦, 但是在后期维护、扩展过程中会有很大优势.<br>所以创建型模式对我们程序中<strong>封装对象创建的过程</strong>提供了优秀的范式. </p>\n<pre><code>* Builder Pattern\n* Prototype Pattern\n* Singleton Pattern\n* Abstract Factory Pattern</code></pre><h4 id=\"结构型模式\"><a href=\"#结构型模式\" class=\"headerlink\" title=\"结构型模式\"></a>结构型模式</h4><p>与类的结构有关. 比如类的组成或构造方式.</p>\n<pre><code>* Adapter Pattern\n* Bridge Pattern\n* Composite Pattern\n* Decorator Pattern\n* Facade Pattern\n* Flyweight Pattern\n* Proxy Pattern</code></pre><h4 id=\"行为型模式\"><a href=\"#行为型模式\" class=\"headerlink\" title=\"行为型模式\"></a>行为型模式</h4><p>规定了类和对象之间的交互以及责任的委派.</p>\n<pre><code>* Interpreter Pattern\n* Template Pattern\n* Chain of Responsibility Pattern\n* Command Pattern\n* Iterator Pattern\n* Mediator Pattern\n* Memento Pattern\n* Observer Pattern\n* State Pattern\n* Strategy Pattern\n* Visitor Pattern</code></pre>"},{"title":"设计一个有getMin功能的栈","date":"2020-06-07T13:05:00.000Z","_content":"\n### 题目\n\n实现一个特殊的栈, 在实现栈的基本功能的基础上, 再实现返回栈中最小元素的操作.\n\n### 要求\n\n1. pop, push, getMin操作的时间复杂度都是O(1)\n2. 设计的栈类型可以使用现有的栈结构\n\n### 思路\n\n先考虑下getMin的特殊情况\n\n1. 应该有一个数据结构能存储,并在入栈和出栈时都要维护当前最小值\n2. 可以用另一个栈来存储当前的最小值.\n<!--more-->\n### 代码实现\n\n两种方案都用了stackMin栈来保存stackData中每一步的最小值.\n\n共同点: 空间复杂度都是O(n), 时间复杂度都是O(1).\n\n区别: 最小栈在方案二中, 冗余存储了每一步的最小值.优点在于出栈无需额外判断, 缺点是入栈时做额外判断.\n\n```java\npublic class MyStack1 {\n    private Stack<Integer> stackData;\n    private Stack<Integer> stackMin;\n\n    public MyStack1() {\n      this.stackData = new Stack<Integer>();\n      this.stackMin = new Stack<Integer>();\n    }\n\n    public void push(int newNum) {\n      if (this.stackMin.isEmpty()) {\n        this.stackMin.push(newNum);\n      } else if (newNum <= this.getMin()) {\n        this.stackMin.push(newNum);\n      }\n      this.stackData.push(newNum);\n    }\n\n    public int pop() {\n      if (this.stackData.isEmpty()) {\n        throw new RuntimeException(\"Your stack is empty.\");\n      }\n      int value = this.stackData.pop();\n      if (value == this.getMin()) {\n        this.stackMin.pop();\n      }\n      return value;\n    }\n\n    public int getMin() {\n      if (this.stackData.isEmpty()) {\n        throw new RuntimeException(\"Your stack is empty.\");\n      }\n      return this.stackMin.peek();\n    }\n  }\n```\n\n```java\npublic class MyStack2 {\n    private Stack<Integer> stackData;\n    private Stack<Integer> stackMin;\n\n    public MyStack2() {\n      this.stackData = new Stack<Integer>();\n      this.stackMin = new Stack<Integer>();\n    }\n\n    public void push(int newNum) {\n      if (this.stackMin.isEmpty()) {\n        this.stackMin.push(newNum);\n      }else if (newNum < this.getMin()) {\n        this.stackMin.push(newNum);\n      }else {\n        this.stackMin.push(this.getMin());\n      }\n      this.stackData.push(newNum);\n    }\n\n    public int pop() {\n      if (this.stackData.isEmpty()) {\n        throw new RuntimeException(\"Your stack is empty\");\n      }\n      this.stackMin.pop();\n      return this.stackData.pop();\n    }\n\n    public int getMin() {\n      if (this.stackMin.isEmpty()) {\n        throw new RuntimeException(\"Your stack is empty\");\n      }\n      return this.stackMin.peek();\n    }\n  }\n```\n","source":"_posts/algorithm/设计一个有getMin功能的栈.md","raw":"---\ntitle: 设计一个有getMin功能的栈\ndate: 2020-06-07 21:05:00\ncategories: 算法日常练习\ntags:\n- 数据结构与算法\n- 栈\n---\n\n### 题目\n\n实现一个特殊的栈, 在实现栈的基本功能的基础上, 再实现返回栈中最小元素的操作.\n\n### 要求\n\n1. pop, push, getMin操作的时间复杂度都是O(1)\n2. 设计的栈类型可以使用现有的栈结构\n\n### 思路\n\n先考虑下getMin的特殊情况\n\n1. 应该有一个数据结构能存储,并在入栈和出栈时都要维护当前最小值\n2. 可以用另一个栈来存储当前的最小值.\n<!--more-->\n### 代码实现\n\n两种方案都用了stackMin栈来保存stackData中每一步的最小值.\n\n共同点: 空间复杂度都是O(n), 时间复杂度都是O(1).\n\n区别: 最小栈在方案二中, 冗余存储了每一步的最小值.优点在于出栈无需额外判断, 缺点是入栈时做额外判断.\n\n```java\npublic class MyStack1 {\n    private Stack<Integer> stackData;\n    private Stack<Integer> stackMin;\n\n    public MyStack1() {\n      this.stackData = new Stack<Integer>();\n      this.stackMin = new Stack<Integer>();\n    }\n\n    public void push(int newNum) {\n      if (this.stackMin.isEmpty()) {\n        this.stackMin.push(newNum);\n      } else if (newNum <= this.getMin()) {\n        this.stackMin.push(newNum);\n      }\n      this.stackData.push(newNum);\n    }\n\n    public int pop() {\n      if (this.stackData.isEmpty()) {\n        throw new RuntimeException(\"Your stack is empty.\");\n      }\n      int value = this.stackData.pop();\n      if (value == this.getMin()) {\n        this.stackMin.pop();\n      }\n      return value;\n    }\n\n    public int getMin() {\n      if (this.stackData.isEmpty()) {\n        throw new RuntimeException(\"Your stack is empty.\");\n      }\n      return this.stackMin.peek();\n    }\n  }\n```\n\n```java\npublic class MyStack2 {\n    private Stack<Integer> stackData;\n    private Stack<Integer> stackMin;\n\n    public MyStack2() {\n      this.stackData = new Stack<Integer>();\n      this.stackMin = new Stack<Integer>();\n    }\n\n    public void push(int newNum) {\n      if (this.stackMin.isEmpty()) {\n        this.stackMin.push(newNum);\n      }else if (newNum < this.getMin()) {\n        this.stackMin.push(newNum);\n      }else {\n        this.stackMin.push(this.getMin());\n      }\n      this.stackData.push(newNum);\n    }\n\n    public int pop() {\n      if (this.stackData.isEmpty()) {\n        throw new RuntimeException(\"Your stack is empty\");\n      }\n      this.stackMin.pop();\n      return this.stackData.pop();\n    }\n\n    public int getMin() {\n      if (this.stackMin.isEmpty()) {\n        throw new RuntimeException(\"Your stack is empty\");\n      }\n      return this.stackMin.peek();\n    }\n  }\n```\n","slug":"algorithm/设计一个有getMin功能的栈","published":1,"updated":"2020-10-27T08:08:15.933Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckio9dweg002yk8nef2lr37sh","content":"<h3 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h3><p>实现一个特殊的栈, 在实现栈的基本功能的基础上, 再实现返回栈中最小元素的操作.</p>\n<h3 id=\"要求\"><a href=\"#要求\" class=\"headerlink\" title=\"要求\"></a>要求</h3><ol>\n<li>pop, push, getMin操作的时间复杂度都是O(1)</li>\n<li>设计的栈类型可以使用现有的栈结构</li>\n</ol>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>先考虑下getMin的特殊情况</p>\n<ol>\n<li>应该有一个数据结构能存储,并在入栈和出栈时都要维护当前最小值</li>\n<li>可以用另一个栈来存储当前的最小值.<a id=\"more\"></a>\n<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3></li>\n</ol>\n<p>两种方案都用了stackMin栈来保存stackData中每一步的最小值.</p>\n<p>共同点: 空间复杂度都是O(n), 时间复杂度都是O(1).</p>\n<p>区别: 最小栈在方案二中, 冗余存储了每一步的最小值.优点在于出栈无需额外判断, 缺点是入栈时做额外判断.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyStack1</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Stack&lt;Integer&gt; stackData;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Stack&lt;Integer&gt; stackMin;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyStack1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.stackData = <span class=\"keyword\">new</span> Stack&lt;Integer&gt;();</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.stackMin = <span class=\"keyword\">new</span> Stack&lt;Integer&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">push</span><span class=\"params\">(<span class=\"keyword\">int</span> newNum)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.stackMin.isEmpty()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.stackMin.push(newNum);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (newNum &lt;= <span class=\"keyword\">this</span>.getMin()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.stackMin.push(newNum);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.stackData.push(newNum);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">pop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.stackData.isEmpty()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"Your stack is empty.\"</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">int</span> value = <span class=\"keyword\">this</span>.stackData.pop();</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (value == <span class=\"keyword\">this</span>.getMin()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.stackMin.pop();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getMin</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.stackData.isEmpty()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"Your stack is empty.\"</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.stackMin.peek();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyStack2</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Stack&lt;Integer&gt; stackData;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Stack&lt;Integer&gt; stackMin;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyStack2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.stackData = <span class=\"keyword\">new</span> Stack&lt;Integer&gt;();</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.stackMin = <span class=\"keyword\">new</span> Stack&lt;Integer&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">push</span><span class=\"params\">(<span class=\"keyword\">int</span> newNum)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.stackMin.isEmpty()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.stackMin.push(newNum);</span><br><span class=\"line\">      &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (newNum &lt; <span class=\"keyword\">this</span>.getMin()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.stackMin.push(newNum);</span><br><span class=\"line\">      &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.stackMin.push(<span class=\"keyword\">this</span>.getMin());</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.stackData.push(newNum);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">pop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.stackData.isEmpty()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"Your stack is empty\"</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.stackMin.pop();</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.stackData.pop();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getMin</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.stackMin.isEmpty()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"Your stack is empty\"</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.stackMin.peek();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<h3 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h3><p>实现一个特殊的栈, 在实现栈的基本功能的基础上, 再实现返回栈中最小元素的操作.</p>\n<h3 id=\"要求\"><a href=\"#要求\" class=\"headerlink\" title=\"要求\"></a>要求</h3><ol>\n<li>pop, push, getMin操作的时间复杂度都是O(1)</li>\n<li>设计的栈类型可以使用现有的栈结构</li>\n</ol>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>先考虑下getMin的特殊情况</p>\n<ol>\n<li>应该有一个数据结构能存储,并在入栈和出栈时都要维护当前最小值</li>\n<li>可以用另一个栈来存储当前的最小值.","more":"<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3></li>\n</ol>\n<p>两种方案都用了stackMin栈来保存stackData中每一步的最小值.</p>\n<p>共同点: 空间复杂度都是O(n), 时间复杂度都是O(1).</p>\n<p>区别: 最小栈在方案二中, 冗余存储了每一步的最小值.优点在于出栈无需额外判断, 缺点是入栈时做额外判断.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyStack1</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Stack&lt;Integer&gt; stackData;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Stack&lt;Integer&gt; stackMin;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyStack1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.stackData = <span class=\"keyword\">new</span> Stack&lt;Integer&gt;();</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.stackMin = <span class=\"keyword\">new</span> Stack&lt;Integer&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">push</span><span class=\"params\">(<span class=\"keyword\">int</span> newNum)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.stackMin.isEmpty()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.stackMin.push(newNum);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (newNum &lt;= <span class=\"keyword\">this</span>.getMin()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.stackMin.push(newNum);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.stackData.push(newNum);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">pop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.stackData.isEmpty()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"Your stack is empty.\"</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">int</span> value = <span class=\"keyword\">this</span>.stackData.pop();</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (value == <span class=\"keyword\">this</span>.getMin()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.stackMin.pop();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getMin</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.stackData.isEmpty()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"Your stack is empty.\"</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.stackMin.peek();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyStack2</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Stack&lt;Integer&gt; stackData;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Stack&lt;Integer&gt; stackMin;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyStack2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.stackData = <span class=\"keyword\">new</span> Stack&lt;Integer&gt;();</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.stackMin = <span class=\"keyword\">new</span> Stack&lt;Integer&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">push</span><span class=\"params\">(<span class=\"keyword\">int</span> newNum)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.stackMin.isEmpty()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.stackMin.push(newNum);</span><br><span class=\"line\">      &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (newNum &lt; <span class=\"keyword\">this</span>.getMin()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.stackMin.push(newNum);</span><br><span class=\"line\">      &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.stackMin.push(<span class=\"keyword\">this</span>.getMin());</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.stackData.push(newNum);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">pop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.stackData.isEmpty()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"Your stack is empty\"</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.stackMin.pop();</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.stackData.pop();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getMin</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.stackMin.isEmpty()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"Your stack is empty\"</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.stackMin.peek();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>"},{"title":"设计模式1-软件设计原则","date":"2020-06-18T13:38:25.000Z","_content":"\n1. 开闭原则(Open-Closed Principle, OCP)\n\n    对扩展开放, 对修改关闭.  强调用抽象构建框架, 用实现扩展细节.\n\n2. 单一职责原则(Simple Responsebility Principle, SRP)\n\n    一个类、接口、方法只做一件事.\n    假设我们有一个 Class 负责两个职责，一旦发生需求变更，修改其中一个职责的逻辑代码，有可能会导致另一个职责的功能发生故障.\n    最好的方式给两个职责分别用两个 Class 来实现, 降低类的复杂度，提高类的 可读性，提高系统的可维护性，降低变更引起的风险.\n\n3. 依赖倒置原则(Dependence Inversion Principle, DIP)\n\n    设计代码结构时, 高层模块不应该依赖于底层模块, 二者都应该**依赖其抽象**.\n<!--more-->\n    以抽象为基准比以细节为基准搭建起来的架构要稳定得多.通过抽象使得各个类或者模块不相互影响, 实现松耦合\n\n4. 接口隔离原则(Interface Segreation Principle, ISP)\n\n   用多个专门的接口，而不使 用单一的总接口，客户端不应该依赖它不需要的接口.\n\n\n5. 迪米特法则(Law of Demeter, LOD), 又叫最少知道原则(Least Knowledge Principle,LKP)\n\n    不要和陌生人说话!\n    一个对象应该对其他对象保持最少的了解, 尽量降低类与类之间的耦合.\n\n6. 里氏替换原则(Liskov Substitution Principle,LSP)\n\n    子类可以扩展父类的功能但不能改变父类原有的功能:\n\n       * 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法.\n       * 子类中可以增加自己特有的方法.\n       * 当子类的方法重载父类的方法时，方法的前置条件(即方法的输入/入参)要比父类 方法的输入参数更宽松.\n       * 当子类的方法实现父类的方法时(重写/重载或实现抽象方法)，方法的后置条件(即 方法的输出/返回值)要比父类更严格或相等\n\n7. 合成复用原则(Composite/Aggregate Reuse Principle,CARP)\n\n    尽量使用对象组合(has-a)、聚合(contains-a)，而不使用继承关系达到代码复用的目的\n","source":"_posts/designpattern/设计模式1-软件设计原则.md","raw":"---\ntitle: 设计模式1-软件设计原则\ndate: 2020-06-18 21:38:25\ncategories: 设计模式\ntags:\n- 设计模式\n- 软件设计原则\n---\n\n1. 开闭原则(Open-Closed Principle, OCP)\n\n    对扩展开放, 对修改关闭.  强调用抽象构建框架, 用实现扩展细节.\n\n2. 单一职责原则(Simple Responsebility Principle, SRP)\n\n    一个类、接口、方法只做一件事.\n    假设我们有一个 Class 负责两个职责，一旦发生需求变更，修改其中一个职责的逻辑代码，有可能会导致另一个职责的功能发生故障.\n    最好的方式给两个职责分别用两个 Class 来实现, 降低类的复杂度，提高类的 可读性，提高系统的可维护性，降低变更引起的风险.\n\n3. 依赖倒置原则(Dependence Inversion Principle, DIP)\n\n    设计代码结构时, 高层模块不应该依赖于底层模块, 二者都应该**依赖其抽象**.\n<!--more-->\n    以抽象为基准比以细节为基准搭建起来的架构要稳定得多.通过抽象使得各个类或者模块不相互影响, 实现松耦合\n\n4. 接口隔离原则(Interface Segreation Principle, ISP)\n\n   用多个专门的接口，而不使 用单一的总接口，客户端不应该依赖它不需要的接口.\n\n\n5. 迪米特法则(Law of Demeter, LOD), 又叫最少知道原则(Least Knowledge Principle,LKP)\n\n    不要和陌生人说话!\n    一个对象应该对其他对象保持最少的了解, 尽量降低类与类之间的耦合.\n\n6. 里氏替换原则(Liskov Substitution Principle,LSP)\n\n    子类可以扩展父类的功能但不能改变父类原有的功能:\n\n       * 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法.\n       * 子类中可以增加自己特有的方法.\n       * 当子类的方法重载父类的方法时，方法的前置条件(即方法的输入/入参)要比父类 方法的输入参数更宽松.\n       * 当子类的方法实现父类的方法时(重写/重载或实现抽象方法)，方法的后置条件(即 方法的输出/返回值)要比父类更严格或相等\n\n7. 合成复用原则(Composite/Aggregate Reuse Principle,CARP)\n\n    尽量使用对象组合(has-a)、聚合(contains-a)，而不使用继承关系达到代码复用的目的\n","slug":"designpattern/设计模式1-软件设计原则","published":1,"updated":"2020-10-27T08:08:15.937Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckio9dwej0033k8nejxn78ih7","content":"<ol>\n<li><p>开闭原则(Open-Closed Principle, OCP)</p>\n<p> 对扩展开放, 对修改关闭.  强调用抽象构建框架, 用实现扩展细节.</p>\n</li>\n<li><p>单一职责原则(Simple Responsebility Principle, SRP)</p>\n<p> 一个类、接口、方法只做一件事.<br> 假设我们有一个 Class 负责两个职责，一旦发生需求变更，修改其中一个职责的逻辑代码，有可能会导致另一个职责的功能发生故障.<br> 最好的方式给两个职责分别用两个 Class 来实现, 降低类的复杂度，提高类的 可读性，提高系统的可维护性，降低变更引起的风险.</p>\n</li>\n<li><p>依赖倒置原则(Dependence Inversion Principle, DIP)</p>\n<p> 设计代码结构时, 高层模块不应该依赖于底层模块, 二者都应该<strong>依赖其抽象</strong>.</p>\n<a id=\"more\"></a>\n<p> 以抽象为基准比以细节为基准搭建起来的架构要稳定得多.通过抽象使得各个类或者模块不相互影响, 实现松耦合</p>\n</li>\n<li><p>接口隔离原则(Interface Segreation Principle, ISP)</p>\n<p>用多个专门的接口，而不使 用单一的总接口，客户端不应该依赖它不需要的接口.</p>\n</li>\n</ol>\n<ol start=\"5\">\n<li><p>迪米特法则(Law of Demeter, LOD), 又叫最少知道原则(Least Knowledge Principle,LKP)</p>\n<p> 不要和陌生人说话!<br> 一个对象应该对其他对象保持最少的了解, 尽量降低类与类之间的耦合.</p>\n</li>\n<li><p>里氏替换原则(Liskov Substitution Principle,LSP)</p>\n<p> 子类可以扩展父类的功能但不能改变父类原有的功能:</p>\n<pre><code>* 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法.\n* 子类中可以增加自己特有的方法.\n* 当子类的方法重载父类的方法时，方法的前置条件(即方法的输入/入参)要比父类 方法的输入参数更宽松.\n* 当子类的方法实现父类的方法时(重写/重载或实现抽象方法)，方法的后置条件(即 方法的输出/返回值)要比父类更严格或相等</code></pre></li>\n<li><p>合成复用原则(Composite/Aggregate Reuse Principle,CARP)</p>\n<p> 尽量使用对象组合(has-a)、聚合(contains-a)，而不使用继承关系达到代码复用的目的</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<ol>\n<li><p>开闭原则(Open-Closed Principle, OCP)</p>\n<p> 对扩展开放, 对修改关闭.  强调用抽象构建框架, 用实现扩展细节.</p>\n</li>\n<li><p>单一职责原则(Simple Responsebility Principle, SRP)</p>\n<p> 一个类、接口、方法只做一件事.<br> 假设我们有一个 Class 负责两个职责，一旦发生需求变更，修改其中一个职责的逻辑代码，有可能会导致另一个职责的功能发生故障.<br> 最好的方式给两个职责分别用两个 Class 来实现, 降低类的复杂度，提高类的 可读性，提高系统的可维护性，降低变更引起的风险.</p>\n</li>\n<li><p>依赖倒置原则(Dependence Inversion Principle, DIP)</p>\n<p> 设计代码结构时, 高层模块不应该依赖于底层模块, 二者都应该<strong>依赖其抽象</strong>.</p>","more":"<p> 以抽象为基准比以细节为基准搭建起来的架构要稳定得多.通过抽象使得各个类或者模块不相互影响, 实现松耦合</p>\n</li>\n<li><p>接口隔离原则(Interface Segreation Principle, ISP)</p>\n<p>用多个专门的接口，而不使 用单一的总接口，客户端不应该依赖它不需要的接口.</p>\n</li>\n</ol>\n<ol start=\"5\">\n<li><p>迪米特法则(Law of Demeter, LOD), 又叫最少知道原则(Least Knowledge Principle,LKP)</p>\n<p> 不要和陌生人说话!<br> 一个对象应该对其他对象保持最少的了解, 尽量降低类与类之间的耦合.</p>\n</li>\n<li><p>里氏替换原则(Liskov Substitution Principle,LSP)</p>\n<p> 子类可以扩展父类的功能但不能改变父类原有的功能:</p>\n<pre><code>* 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法.\n* 子类中可以增加自己特有的方法.\n* 当子类的方法重载父类的方法时，方法的前置条件(即方法的输入/入参)要比父类 方法的输入参数更宽松.\n* 当子类的方法实现父类的方法时(重写/重载或实现抽象方法)，方法的后置条件(即 方法的输出/返回值)要比父类更严格或相等</code></pre></li>\n<li><p>合成复用原则(Composite/Aggregate Reuse Principle,CARP)</p>\n<p> 尽量使用对象组合(has-a)、聚合(contains-a)，而不使用继承关系达到代码复用的目的</p>\n</li>\n</ol>"},{"title":"Designing Data-Intensive Applications 7 - 事务","date":"2020-05-03T13:33:03.000Z","_content":"\n\n# 深入理解事务 \n\n## ACID的含义 \n\n### 原子性（Atomicity） \n\n#### 在出错时中止事务， 并将部分完成的写入全部丢弃 \n\n#### 可中止性。简化了排错过程，事务如果中止， 应用可以安全地重试 \n\n### 一致性(Consistency) \n\n#### 对数据有特定的预期状态， 任何数据更改必须满足这些状态约束（或者恒等条件） \n\n#### 本质上要求应用层来维护一致 \n\n#### 应用程序可能借助数据库提供的原子性和隔离性， 以达到一致性， 但一致性本身并不源于数据库 \n<!--more-->\n#### 数据库只能完成针对某些特定类型的恒等约束条件，例如外健约束或唯一性约束 \n\n### 持久性(Durability) \n\n#### 一旦事务提交成功， 即使存在硬件故障或数据库崩溃，事务所写入的任何数据不会消失 \n\n#### 没有哪一项技术可以提供绝对的持久性保证， 应该组合使用 \n\n#### 数据写入硬盘， 使用预写日志， 复制 \n\n### 隔离性(Isolation) \n\n#### 并发执行的多个事务相互隔离， 不能互相交叉 \n\n#### 由于串行化隔离的性能原因，常用的是更弱级别的隔离 \n\n## 单对象与多对象事务操作 \n\n### 单对象写入 \n\n#### 原子性 \n\n#### 基于日志恢复（Btree） \n\n#### 原子自增 \n\n#### 原子比较-设置 （compare-and-set） \n\n### 多对象事务的必要性 \n\n#### 通常意义上的事务针对的是多个对象， 将多个操作聚合为一个逻辑执行单元 \n\n#### 关系数据库的外健 \n\n#### 文档数据模型，可能更新多个文档 \n\n#### 图数据库的顶点和边 \n\n#### 带有二级索引的数据库， 更新值时同步更新索引 \n\n### 处理错误与中止 \n\n#### 中止后不撤销：某些无主节点复制的数据存储，遇到错误， 不会撤销已完成的操作 \n\n#### 中止后撤销但不重试：Rails ActiveRecord， Django在事务异常时简单地抛出堆栈信息， 不会重试 \n\n#### 理念：支持安全的重试机制才是中止流程的重点 \n\n#### 重试的局限性 \n\n#### 执行成功，但返回客户端时网络意外， 重试可能导致重复执行， 需要额外应用级重复数据删除 \n\n#### 设置重试次数：系统超负荷时， 一直重试会加重负担 \n\n#### 重试仅对临时性故障有意义，出现永久故障时无意义 \n\n#### 两阶段提交，避免副作用。比如每次事务中国呢调用其它系统，发送邮件等 \n\n#### 客户端重试时失败， 待写入数据可能丢失 \n\n## 事务的意义 \n\n### 事务是一个抽象层，提供安全性保证，简化应用层的编程模型 \n\n### NoSQL的兴起，很多新一代数据库完全放弃事务支持，或者替换为更弱的保证 \n\n### 事务有优势，也有局限性，需要权衡 \n\n# 弱隔离级别\n\n## 读提交 \n\n### 防止脏读 \n\n#### 读数据库时，只能看到已成功提交的数据。不会看到部分更新或会被回滚的数据 \n\n#### 实现：对于待更新对象， 维护旧值和当前持锁事务要设置的新值两个版本。事务提交前读旧值， 提交后切换到新值 \n\n### 防止脏写 \n\n#### 写数据库时，只会覆盖已成功提交的数据。避免不同事务的写入混杂 \n\n#### 实现： 行级锁。数据库自动完成 \n\n### 不可重复读/读倾斜(时间异常) \n\n#### 备份场景 \n\n#### 分析查询和完整性检查场景 \n\n#### 有些场景不能容忍这种暂时的不一致状态 \n\n## 快照级别隔离与重复读 \n\n### 实现快照级别隔离 \n\n#### MVCC \n\n### 一致性快照的可见性原则 \n\n#### 1. 进行中的其它事务，不可见 \n\n#### 2. 所有中止事务所做的修改，不可见 \n\n#### 3. 较晚事务ID所做任何修改， 无论是否提交，不可见 \n\n#### 4. 除上述之外的所有写入都对应用查询可见 \n\n#### 4.1 事务开始时， 创建该对象的事务已经完成提交 \n\n#### 4.2 对象没有标记为删除，或者标记了，但删除事务在当前事务开始前未完成提交 \n\n### 快照级别隔离如何支持索引 \n\n#### 方案1(PostgreSQL将同对象的不同版本放在一个内存页面上)： 索引指向对象的所有版本， 过滤当前事务不可见的那些版本。后台垃圾回收进程删除旧对象版本时，同时删除对应索引 \n\n#### 方案2（CouchDB,Datomic,LMDB）： B-tree，追加/写时复制。更新时，每个写入事务创建新的B-tree root,代表该时刻数据库的一致性快照 \n\n### 可重复读与命名混淆 \n\n#### 命名混淆：快照隔离技术， Oracle称为可串行化， PostgreSQL和MySQL称为可重复读 \n\n#### 原因： SQL标准只定义了可重复读， 未定义快照级别隔离 \n\n## 防止更新丢失（写事务并发） \n\n### 原子写操作（数据库） \n\n#### 许多数据库提供了原子更新操作 eg: update counters set value = value + 1 where key = \\'foo\\'; \n\n#### 实现1： 对读取对象加独占锁，更新提交前不会有其它事务可读它（游标稳定性） \n\n#### 实现2： 强制所有的原子操作都在单线程上执行 \n\n### 显式加锁（应用层） \n\n#### 应用程序显式锁定待更新的对象，然后执行\\\"读-修改-写回\\\" \n\n### 自动检测更新丢失（借助快照级别隔离来高效执行） \n\n#### 原子操作和锁都是强制\\\"读-修改-写回\\\"操作序列串行执行 \n\n#### 换个思路： 先让他们并发执行， 如果事务管理器检测到了更新丢失风险， 中止当前事务， 强制回退到安全的\\\"读-修改-写回\\\" \n\n#### PostgreSQL的可重复读， Oracle的可串行化，SQL Server的快照级别隔离都支持 \n\n#### MySQL InnoDB的可重复读不支持 \n\n### 原子比较和设置（无事务支持） \n\n#### 先执行CAS，如果不成功则回退到\\\"读-修改-写回\\\" \n\n#### 注意： 如果where语句运行在旧快照上，可能无法防止另一个并发写入。所以要仔细检查CAS操作的安全运行条件 \n\n### 冲突解决与复制（多副本） \n\n#### 保留多个冲突版本，由应用层逻辑或依靠特定的数据结构来解决 \n\n#### 如果操作顺序无关，则原子操作可行 \n\n#### LWW，容易丢失更新，但是目前许多多副本数据库的默认配置 \n\n## 写倾斜与幻读 \n\n### 定义写倾斜/幻读 \n\n#### 一个事务的写入改变了另一个事务查询结果 \n\n#### 更新丢失问题。如果两个事务读取相同的一组对象，然后更新其中一部分 \n\n#### 写倾斜：不同的事务可能更新不同的对象 \n\n#### 脏写、更新丢失： 不同的事务更新的是同一个对象 \n\n#### 之前可选方案的可行性 \n\n#### 原子操作，不可行，因为涉及到多个对象 \n\n#### 定义数据库约束条件，然后数据库代为检查、执行约束， 不可行， 大多数场景的类型约束数据库不支持 \n\n#### 自动检测更新丢失，不可行，目前都不支持自动检测写倾斜（需要真正的可串行化隔离） \n\n#### 对事务依赖的行来显式加锁，可行， FOR UPDATE \n\n### 更多写倾斜的案例 \n\n### 为何产生写倾斜 \n\n### 实体化冲突 \n\n#### 把幻读问题 转变为 针对数据库中一组具体行的锁冲突问题 \n\n#### 并发控制机制 降级为 数据模型 \n\n# 串行化\n\n## 实际串行执行 \n\n### 采用存储过程封装事务 \n\n#### 避免等待IO（用户交互，应用程序与数据库间多次网络通信） \n\n### 存储过程的优缺点 \n\n#### 数据库厂商的存储过程语言大多语义丑陋，过时（最新的存储过程使用现有通用语言： VoltDB使用Java或Groovy,Datomic使用Java或Clojure，Redis使用Lua） \n\n#### 数据库中运行代码难以管理（调试，版本控制，部署，测试，监控） \n\n#### 设计不好，所有应用程序都受影响 \n\n### 分区 \n\n#### 高写入需求下，单线程事务处理容易成为瓶颈 \n\n#### 分区，扩展到多个CPU核和多节点 \n\n#### 跨分区事务由额外的协调开销，所以适合大量键值数据，不适合带有多个二级索引的数据 \n\n### 串行执行小结 \n\n### 为什么现在能实现，为什么以前都要靠多线程并发来提升性能 \n\n#### 内存越来越便宜， 事务所需数据都可加载到内存中 \n\n#### OLTP事务通常执行很快 \n\n#### Redis, VoltDB/H-store, Datomic等采用串行， 避免锁开销， 吞吐量上限为单个CPU核的吞吐量 \n\n## 两阶段加锁（two-phase locking, 2PL） \n\n### 实现2PL \n\n#### 多个事务可以同时读取同一对象，但只要出现任何写操作，则必须加锁以独占访问（读写也会互斥） \n\n#### 1. 每个对象都有一个读写锁来隔离读写操作 \n\n#### 2. 事务要读取对象，必须先获得读锁，可以有多个事务同时获得一个对象的读锁 \n\n#### 3. 如果某个事务已经获得对象的写锁， 其它事务必须等待 \n\n#### 5. 如果事务先读取，然后尝试写入，必须先把读锁升级为写锁 \n\n#### 4. 事务要修改对象， 必须先获取写锁，如果已被加写锁，必须等待 \n\n#### 6. 事务获得锁后， 一直持有到事务结束。第一阶段即事务执行之前要获取锁，第二阶段即事务结束时要释放锁。 \n\n#### 容易死锁，数据库自动检测死锁， 强行中止其中一个 \n\n### 2PL的性能 \n\n#### 锁的获取和释放本身开销 \n\n#### 数据库访问延迟具有非常大的不确定性 \n\n#### 降低了事务的并发性 \n\n#### 死锁更为频繁，如果由于死锁而被强行中止，应用层必须从头重试 \n\n### 谓词锁 \n\n#### 可串行化隔离也要防止幻读问题 \n\n#### 作用于某些搜索条件的所有查询对象 \n\n#### 谓词锁可以保护那些上不存在但可能马上会被插入的对象 \n\n#### 两阶段加锁+谓词锁，可以防止所有竞争条件，隔离变得真正可串行化 \n\n### 索引区间锁 \n\n#### 对谓词锁的简化，因为谓词锁性能不佳 \n\n#### 将保护的对象扩大化，不像谓词锁那么精确，但是开销低 \n\n#### 如果没有合适的索引，可以回退到对整个表施加共享锁 \n\n## 可串行化的快照隔离（SSI） \n\n### 悲观与乐观的并发控制 \n\n#### 2PL是悲观并发控制机制 \n\n#### SSI是乐观并发控制： 如果可能发生潜在冲突，事务继续执行而不中止；事务提交时检查是否冲突，是的话再中止并重试。 \n\n#### 缺点： 如果冲突很多，则性能不佳； 如果系统已接近最大吞吐量，反复重试会使情况更糟 \n\n#### 优点： 如果系统有足够的性能提升空间，且事务竞争不大， 乐观并发控制会高效很多 \n\n### 基于过期的条件做决定 \n\n#### 数据库必须检测事务是否会修改其他事务的查询结果 \n\n#### 1. 检测是否读取了（即将）过期的MVCC对象，即读取前已经有未提交的写入 \n\n#### 2.检测写是否影响了之前的读，即读取后，又有新的写入 \n\n### 可串行化快照隔离的性能 \n\n#### 优点：事务不需要等待其它事务所持有的锁，只读查询不需要任何锁 \n\n#### 可以突破单个CPU核的限制，FoundationDB将冲突检测分区，事务分区 \n\n#### 事务中止的比例会显著影响SSI的性能表现 \n\n# 边界条件小结 \n\n## 脏读 \n\n## 脏写 \n\n## 读倾斜（不可重复读） \n\n## 更新丢失 \n\n## 写倾斜 \n\n## 幻读 ","source":"_posts/bigdata/Designing-Data-Intensive-Applications-7-事务.md","raw":"---\ntitle: Designing Data-Intensive Applications 7 - 事务\ndate: 2020-05-03 21:33:03\ncategories: 读书笔记\ntags:\n- 笔记\n- 事务\n---\n\n\n# 深入理解事务 \n\n## ACID的含义 \n\n### 原子性（Atomicity） \n\n#### 在出错时中止事务， 并将部分完成的写入全部丢弃 \n\n#### 可中止性。简化了排错过程，事务如果中止， 应用可以安全地重试 \n\n### 一致性(Consistency) \n\n#### 对数据有特定的预期状态， 任何数据更改必须满足这些状态约束（或者恒等条件） \n\n#### 本质上要求应用层来维护一致 \n\n#### 应用程序可能借助数据库提供的原子性和隔离性， 以达到一致性， 但一致性本身并不源于数据库 \n<!--more-->\n#### 数据库只能完成针对某些特定类型的恒等约束条件，例如外健约束或唯一性约束 \n\n### 持久性(Durability) \n\n#### 一旦事务提交成功， 即使存在硬件故障或数据库崩溃，事务所写入的任何数据不会消失 \n\n#### 没有哪一项技术可以提供绝对的持久性保证， 应该组合使用 \n\n#### 数据写入硬盘， 使用预写日志， 复制 \n\n### 隔离性(Isolation) \n\n#### 并发执行的多个事务相互隔离， 不能互相交叉 \n\n#### 由于串行化隔离的性能原因，常用的是更弱级别的隔离 \n\n## 单对象与多对象事务操作 \n\n### 单对象写入 \n\n#### 原子性 \n\n#### 基于日志恢复（Btree） \n\n#### 原子自增 \n\n#### 原子比较-设置 （compare-and-set） \n\n### 多对象事务的必要性 \n\n#### 通常意义上的事务针对的是多个对象， 将多个操作聚合为一个逻辑执行单元 \n\n#### 关系数据库的外健 \n\n#### 文档数据模型，可能更新多个文档 \n\n#### 图数据库的顶点和边 \n\n#### 带有二级索引的数据库， 更新值时同步更新索引 \n\n### 处理错误与中止 \n\n#### 中止后不撤销：某些无主节点复制的数据存储，遇到错误， 不会撤销已完成的操作 \n\n#### 中止后撤销但不重试：Rails ActiveRecord， Django在事务异常时简单地抛出堆栈信息， 不会重试 \n\n#### 理念：支持安全的重试机制才是中止流程的重点 \n\n#### 重试的局限性 \n\n#### 执行成功，但返回客户端时网络意外， 重试可能导致重复执行， 需要额外应用级重复数据删除 \n\n#### 设置重试次数：系统超负荷时， 一直重试会加重负担 \n\n#### 重试仅对临时性故障有意义，出现永久故障时无意义 \n\n#### 两阶段提交，避免副作用。比如每次事务中国呢调用其它系统，发送邮件等 \n\n#### 客户端重试时失败， 待写入数据可能丢失 \n\n## 事务的意义 \n\n### 事务是一个抽象层，提供安全性保证，简化应用层的编程模型 \n\n### NoSQL的兴起，很多新一代数据库完全放弃事务支持，或者替换为更弱的保证 \n\n### 事务有优势，也有局限性，需要权衡 \n\n# 弱隔离级别\n\n## 读提交 \n\n### 防止脏读 \n\n#### 读数据库时，只能看到已成功提交的数据。不会看到部分更新或会被回滚的数据 \n\n#### 实现：对于待更新对象， 维护旧值和当前持锁事务要设置的新值两个版本。事务提交前读旧值， 提交后切换到新值 \n\n### 防止脏写 \n\n#### 写数据库时，只会覆盖已成功提交的数据。避免不同事务的写入混杂 \n\n#### 实现： 行级锁。数据库自动完成 \n\n### 不可重复读/读倾斜(时间异常) \n\n#### 备份场景 \n\n#### 分析查询和完整性检查场景 \n\n#### 有些场景不能容忍这种暂时的不一致状态 \n\n## 快照级别隔离与重复读 \n\n### 实现快照级别隔离 \n\n#### MVCC \n\n### 一致性快照的可见性原则 \n\n#### 1. 进行中的其它事务，不可见 \n\n#### 2. 所有中止事务所做的修改，不可见 \n\n#### 3. 较晚事务ID所做任何修改， 无论是否提交，不可见 \n\n#### 4. 除上述之外的所有写入都对应用查询可见 \n\n#### 4.1 事务开始时， 创建该对象的事务已经完成提交 \n\n#### 4.2 对象没有标记为删除，或者标记了，但删除事务在当前事务开始前未完成提交 \n\n### 快照级别隔离如何支持索引 \n\n#### 方案1(PostgreSQL将同对象的不同版本放在一个内存页面上)： 索引指向对象的所有版本， 过滤当前事务不可见的那些版本。后台垃圾回收进程删除旧对象版本时，同时删除对应索引 \n\n#### 方案2（CouchDB,Datomic,LMDB）： B-tree，追加/写时复制。更新时，每个写入事务创建新的B-tree root,代表该时刻数据库的一致性快照 \n\n### 可重复读与命名混淆 \n\n#### 命名混淆：快照隔离技术， Oracle称为可串行化， PostgreSQL和MySQL称为可重复读 \n\n#### 原因： SQL标准只定义了可重复读， 未定义快照级别隔离 \n\n## 防止更新丢失（写事务并发） \n\n### 原子写操作（数据库） \n\n#### 许多数据库提供了原子更新操作 eg: update counters set value = value + 1 where key = \\'foo\\'; \n\n#### 实现1： 对读取对象加独占锁，更新提交前不会有其它事务可读它（游标稳定性） \n\n#### 实现2： 强制所有的原子操作都在单线程上执行 \n\n### 显式加锁（应用层） \n\n#### 应用程序显式锁定待更新的对象，然后执行\\\"读-修改-写回\\\" \n\n### 自动检测更新丢失（借助快照级别隔离来高效执行） \n\n#### 原子操作和锁都是强制\\\"读-修改-写回\\\"操作序列串行执行 \n\n#### 换个思路： 先让他们并发执行， 如果事务管理器检测到了更新丢失风险， 中止当前事务， 强制回退到安全的\\\"读-修改-写回\\\" \n\n#### PostgreSQL的可重复读， Oracle的可串行化，SQL Server的快照级别隔离都支持 \n\n#### MySQL InnoDB的可重复读不支持 \n\n### 原子比较和设置（无事务支持） \n\n#### 先执行CAS，如果不成功则回退到\\\"读-修改-写回\\\" \n\n#### 注意： 如果where语句运行在旧快照上，可能无法防止另一个并发写入。所以要仔细检查CAS操作的安全运行条件 \n\n### 冲突解决与复制（多副本） \n\n#### 保留多个冲突版本，由应用层逻辑或依靠特定的数据结构来解决 \n\n#### 如果操作顺序无关，则原子操作可行 \n\n#### LWW，容易丢失更新，但是目前许多多副本数据库的默认配置 \n\n## 写倾斜与幻读 \n\n### 定义写倾斜/幻读 \n\n#### 一个事务的写入改变了另一个事务查询结果 \n\n#### 更新丢失问题。如果两个事务读取相同的一组对象，然后更新其中一部分 \n\n#### 写倾斜：不同的事务可能更新不同的对象 \n\n#### 脏写、更新丢失： 不同的事务更新的是同一个对象 \n\n#### 之前可选方案的可行性 \n\n#### 原子操作，不可行，因为涉及到多个对象 \n\n#### 定义数据库约束条件，然后数据库代为检查、执行约束， 不可行， 大多数场景的类型约束数据库不支持 \n\n#### 自动检测更新丢失，不可行，目前都不支持自动检测写倾斜（需要真正的可串行化隔离） \n\n#### 对事务依赖的行来显式加锁，可行， FOR UPDATE \n\n### 更多写倾斜的案例 \n\n### 为何产生写倾斜 \n\n### 实体化冲突 \n\n#### 把幻读问题 转变为 针对数据库中一组具体行的锁冲突问题 \n\n#### 并发控制机制 降级为 数据模型 \n\n# 串行化\n\n## 实际串行执行 \n\n### 采用存储过程封装事务 \n\n#### 避免等待IO（用户交互，应用程序与数据库间多次网络通信） \n\n### 存储过程的优缺点 \n\n#### 数据库厂商的存储过程语言大多语义丑陋，过时（最新的存储过程使用现有通用语言： VoltDB使用Java或Groovy,Datomic使用Java或Clojure，Redis使用Lua） \n\n#### 数据库中运行代码难以管理（调试，版本控制，部署，测试，监控） \n\n#### 设计不好，所有应用程序都受影响 \n\n### 分区 \n\n#### 高写入需求下，单线程事务处理容易成为瓶颈 \n\n#### 分区，扩展到多个CPU核和多节点 \n\n#### 跨分区事务由额外的协调开销，所以适合大量键值数据，不适合带有多个二级索引的数据 \n\n### 串行执行小结 \n\n### 为什么现在能实现，为什么以前都要靠多线程并发来提升性能 \n\n#### 内存越来越便宜， 事务所需数据都可加载到内存中 \n\n#### OLTP事务通常执行很快 \n\n#### Redis, VoltDB/H-store, Datomic等采用串行， 避免锁开销， 吞吐量上限为单个CPU核的吞吐量 \n\n## 两阶段加锁（two-phase locking, 2PL） \n\n### 实现2PL \n\n#### 多个事务可以同时读取同一对象，但只要出现任何写操作，则必须加锁以独占访问（读写也会互斥） \n\n#### 1. 每个对象都有一个读写锁来隔离读写操作 \n\n#### 2. 事务要读取对象，必须先获得读锁，可以有多个事务同时获得一个对象的读锁 \n\n#### 3. 如果某个事务已经获得对象的写锁， 其它事务必须等待 \n\n#### 5. 如果事务先读取，然后尝试写入，必须先把读锁升级为写锁 \n\n#### 4. 事务要修改对象， 必须先获取写锁，如果已被加写锁，必须等待 \n\n#### 6. 事务获得锁后， 一直持有到事务结束。第一阶段即事务执行之前要获取锁，第二阶段即事务结束时要释放锁。 \n\n#### 容易死锁，数据库自动检测死锁， 强行中止其中一个 \n\n### 2PL的性能 \n\n#### 锁的获取和释放本身开销 \n\n#### 数据库访问延迟具有非常大的不确定性 \n\n#### 降低了事务的并发性 \n\n#### 死锁更为频繁，如果由于死锁而被强行中止，应用层必须从头重试 \n\n### 谓词锁 \n\n#### 可串行化隔离也要防止幻读问题 \n\n#### 作用于某些搜索条件的所有查询对象 \n\n#### 谓词锁可以保护那些上不存在但可能马上会被插入的对象 \n\n#### 两阶段加锁+谓词锁，可以防止所有竞争条件，隔离变得真正可串行化 \n\n### 索引区间锁 \n\n#### 对谓词锁的简化，因为谓词锁性能不佳 \n\n#### 将保护的对象扩大化，不像谓词锁那么精确，但是开销低 \n\n#### 如果没有合适的索引，可以回退到对整个表施加共享锁 \n\n## 可串行化的快照隔离（SSI） \n\n### 悲观与乐观的并发控制 \n\n#### 2PL是悲观并发控制机制 \n\n#### SSI是乐观并发控制： 如果可能发生潜在冲突，事务继续执行而不中止；事务提交时检查是否冲突，是的话再中止并重试。 \n\n#### 缺点： 如果冲突很多，则性能不佳； 如果系统已接近最大吞吐量，反复重试会使情况更糟 \n\n#### 优点： 如果系统有足够的性能提升空间，且事务竞争不大， 乐观并发控制会高效很多 \n\n### 基于过期的条件做决定 \n\n#### 数据库必须检测事务是否会修改其他事务的查询结果 \n\n#### 1. 检测是否读取了（即将）过期的MVCC对象，即读取前已经有未提交的写入 \n\n#### 2.检测写是否影响了之前的读，即读取后，又有新的写入 \n\n### 可串行化快照隔离的性能 \n\n#### 优点：事务不需要等待其它事务所持有的锁，只读查询不需要任何锁 \n\n#### 可以突破单个CPU核的限制，FoundationDB将冲突检测分区，事务分区 \n\n#### 事务中止的比例会显著影响SSI的性能表现 \n\n# 边界条件小结 \n\n## 脏读 \n\n## 脏写 \n\n## 读倾斜（不可重复读） \n\n## 更新丢失 \n\n## 写倾斜 \n\n## 幻读 ","slug":"bigdata/Designing-Data-Intensive-Applications-7-事务","published":1,"updated":"2020-10-27T08:08:15.934Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckio9dwel0036k8neuin665oc","content":"<h1 id=\"深入理解事务\"><a href=\"#深入理解事务\" class=\"headerlink\" title=\"深入理解事务\"></a>深入理解事务</h1><h2 id=\"ACID的含义\"><a href=\"#ACID的含义\" class=\"headerlink\" title=\"ACID的含义\"></a>ACID的含义</h2><h3 id=\"原子性（Atomicity）\"><a href=\"#原子性（Atomicity）\" class=\"headerlink\" title=\"原子性（Atomicity）\"></a>原子性（Atomicity）</h3><h4 id=\"在出错时中止事务，-并将部分完成的写入全部丢弃\"><a href=\"#在出错时中止事务，-并将部分完成的写入全部丢弃\" class=\"headerlink\" title=\"在出错时中止事务， 并将部分完成的写入全部丢弃\"></a>在出错时中止事务， 并将部分完成的写入全部丢弃</h4><h4 id=\"可中止性。简化了排错过程，事务如果中止，-应用可以安全地重试\"><a href=\"#可中止性。简化了排错过程，事务如果中止，-应用可以安全地重试\" class=\"headerlink\" title=\"可中止性。简化了排错过程，事务如果中止， 应用可以安全地重试\"></a>可中止性。简化了排错过程，事务如果中止， 应用可以安全地重试</h4><h3 id=\"一致性-Consistency\"><a href=\"#一致性-Consistency\" class=\"headerlink\" title=\"一致性(Consistency)\"></a>一致性(Consistency)</h3><h4 id=\"对数据有特定的预期状态，-任何数据更改必须满足这些状态约束（或者恒等条件）\"><a href=\"#对数据有特定的预期状态，-任何数据更改必须满足这些状态约束（或者恒等条件）\" class=\"headerlink\" title=\"对数据有特定的预期状态， 任何数据更改必须满足这些状态约束（或者恒等条件）\"></a>对数据有特定的预期状态， 任何数据更改必须满足这些状态约束（或者恒等条件）</h4><h4 id=\"本质上要求应用层来维护一致\"><a href=\"#本质上要求应用层来维护一致\" class=\"headerlink\" title=\"本质上要求应用层来维护一致\"></a>本质上要求应用层来维护一致</h4><h4 id=\"应用程序可能借助数据库提供的原子性和隔离性，-以达到一致性，-但一致性本身并不源于数据库\"><a href=\"#应用程序可能借助数据库提供的原子性和隔离性，-以达到一致性，-但一致性本身并不源于数据库\" class=\"headerlink\" title=\"应用程序可能借助数据库提供的原子性和隔离性， 以达到一致性， 但一致性本身并不源于数据库\"></a>应用程序可能借助数据库提供的原子性和隔离性， 以达到一致性， 但一致性本身并不源于数据库</h4><a id=\"more\"></a>\n<h4 id=\"数据库只能完成针对某些特定类型的恒等约束条件，例如外健约束或唯一性约束\"><a href=\"#数据库只能完成针对某些特定类型的恒等约束条件，例如外健约束或唯一性约束\" class=\"headerlink\" title=\"数据库只能完成针对某些特定类型的恒等约束条件，例如外健约束或唯一性约束\"></a>数据库只能完成针对某些特定类型的恒等约束条件，例如外健约束或唯一性约束</h4><h3 id=\"持久性-Durability\"><a href=\"#持久性-Durability\" class=\"headerlink\" title=\"持久性(Durability)\"></a>持久性(Durability)</h3><h4 id=\"一旦事务提交成功，-即使存在硬件故障或数据库崩溃，事务所写入的任何数据不会消失\"><a href=\"#一旦事务提交成功，-即使存在硬件故障或数据库崩溃，事务所写入的任何数据不会消失\" class=\"headerlink\" title=\"一旦事务提交成功， 即使存在硬件故障或数据库崩溃，事务所写入的任何数据不会消失\"></a>一旦事务提交成功， 即使存在硬件故障或数据库崩溃，事务所写入的任何数据不会消失</h4><h4 id=\"没有哪一项技术可以提供绝对的持久性保证，-应该组合使用\"><a href=\"#没有哪一项技术可以提供绝对的持久性保证，-应该组合使用\" class=\"headerlink\" title=\"没有哪一项技术可以提供绝对的持久性保证， 应该组合使用\"></a>没有哪一项技术可以提供绝对的持久性保证， 应该组合使用</h4><h4 id=\"数据写入硬盘，-使用预写日志，-复制\"><a href=\"#数据写入硬盘，-使用预写日志，-复制\" class=\"headerlink\" title=\"数据写入硬盘， 使用预写日志， 复制\"></a>数据写入硬盘， 使用预写日志， 复制</h4><h3 id=\"隔离性-Isolation\"><a href=\"#隔离性-Isolation\" class=\"headerlink\" title=\"隔离性(Isolation)\"></a>隔离性(Isolation)</h3><h4 id=\"并发执行的多个事务相互隔离，-不能互相交叉\"><a href=\"#并发执行的多个事务相互隔离，-不能互相交叉\" class=\"headerlink\" title=\"并发执行的多个事务相互隔离， 不能互相交叉\"></a>并发执行的多个事务相互隔离， 不能互相交叉</h4><h4 id=\"由于串行化隔离的性能原因，常用的是更弱级别的隔离\"><a href=\"#由于串行化隔离的性能原因，常用的是更弱级别的隔离\" class=\"headerlink\" title=\"由于串行化隔离的性能原因，常用的是更弱级别的隔离\"></a>由于串行化隔离的性能原因，常用的是更弱级别的隔离</h4><h2 id=\"单对象与多对象事务操作\"><a href=\"#单对象与多对象事务操作\" class=\"headerlink\" title=\"单对象与多对象事务操作\"></a>单对象与多对象事务操作</h2><h3 id=\"单对象写入\"><a href=\"#单对象写入\" class=\"headerlink\" title=\"单对象写入\"></a>单对象写入</h3><h4 id=\"原子性\"><a href=\"#原子性\" class=\"headerlink\" title=\"原子性\"></a>原子性</h4><h4 id=\"基于日志恢复（Btree）\"><a href=\"#基于日志恢复（Btree）\" class=\"headerlink\" title=\"基于日志恢复（Btree）\"></a>基于日志恢复（Btree）</h4><h4 id=\"原子自增\"><a href=\"#原子自增\" class=\"headerlink\" title=\"原子自增\"></a>原子自增</h4><h4 id=\"原子比较-设置-（compare-and-set）\"><a href=\"#原子比较-设置-（compare-and-set）\" class=\"headerlink\" title=\"原子比较-设置 （compare-and-set）\"></a>原子比较-设置 （compare-and-set）</h4><h3 id=\"多对象事务的必要性\"><a href=\"#多对象事务的必要性\" class=\"headerlink\" title=\"多对象事务的必要性\"></a>多对象事务的必要性</h3><h4 id=\"通常意义上的事务针对的是多个对象，-将多个操作聚合为一个逻辑执行单元\"><a href=\"#通常意义上的事务针对的是多个对象，-将多个操作聚合为一个逻辑执行单元\" class=\"headerlink\" title=\"通常意义上的事务针对的是多个对象， 将多个操作聚合为一个逻辑执行单元\"></a>通常意义上的事务针对的是多个对象， 将多个操作聚合为一个逻辑执行单元</h4><h4 id=\"关系数据库的外健\"><a href=\"#关系数据库的外健\" class=\"headerlink\" title=\"关系数据库的外健\"></a>关系数据库的外健</h4><h4 id=\"文档数据模型，可能更新多个文档\"><a href=\"#文档数据模型，可能更新多个文档\" class=\"headerlink\" title=\"文档数据模型，可能更新多个文档\"></a>文档数据模型，可能更新多个文档</h4><h4 id=\"图数据库的顶点和边\"><a href=\"#图数据库的顶点和边\" class=\"headerlink\" title=\"图数据库的顶点和边\"></a>图数据库的顶点和边</h4><h4 id=\"带有二级索引的数据库，-更新值时同步更新索引\"><a href=\"#带有二级索引的数据库，-更新值时同步更新索引\" class=\"headerlink\" title=\"带有二级索引的数据库， 更新值时同步更新索引\"></a>带有二级索引的数据库， 更新值时同步更新索引</h4><h3 id=\"处理错误与中止\"><a href=\"#处理错误与中止\" class=\"headerlink\" title=\"处理错误与中止\"></a>处理错误与中止</h3><h4 id=\"中止后不撤销：某些无主节点复制的数据存储，遇到错误，-不会撤销已完成的操作\"><a href=\"#中止后不撤销：某些无主节点复制的数据存储，遇到错误，-不会撤销已完成的操作\" class=\"headerlink\" title=\"中止后不撤销：某些无主节点复制的数据存储，遇到错误， 不会撤销已完成的操作\"></a>中止后不撤销：某些无主节点复制的数据存储，遇到错误， 不会撤销已完成的操作</h4><h4 id=\"中止后撤销但不重试：Rails-ActiveRecord，-Django在事务异常时简单地抛出堆栈信息，-不会重试\"><a href=\"#中止后撤销但不重试：Rails-ActiveRecord，-Django在事务异常时简单地抛出堆栈信息，-不会重试\" class=\"headerlink\" title=\"中止后撤销但不重试：Rails ActiveRecord， Django在事务异常时简单地抛出堆栈信息， 不会重试\"></a>中止后撤销但不重试：Rails ActiveRecord， Django在事务异常时简单地抛出堆栈信息， 不会重试</h4><h4 id=\"理念：支持安全的重试机制才是中止流程的重点\"><a href=\"#理念：支持安全的重试机制才是中止流程的重点\" class=\"headerlink\" title=\"理念：支持安全的重试机制才是中止流程的重点\"></a>理念：支持安全的重试机制才是中止流程的重点</h4><h4 id=\"重试的局限性\"><a href=\"#重试的局限性\" class=\"headerlink\" title=\"重试的局限性\"></a>重试的局限性</h4><h4 id=\"执行成功，但返回客户端时网络意外，-重试可能导致重复执行，-需要额外应用级重复数据删除\"><a href=\"#执行成功，但返回客户端时网络意外，-重试可能导致重复执行，-需要额外应用级重复数据删除\" class=\"headerlink\" title=\"执行成功，但返回客户端时网络意外， 重试可能导致重复执行， 需要额外应用级重复数据删除\"></a>执行成功，但返回客户端时网络意外， 重试可能导致重复执行， 需要额外应用级重复数据删除</h4><h4 id=\"设置重试次数：系统超负荷时，-一直重试会加重负担\"><a href=\"#设置重试次数：系统超负荷时，-一直重试会加重负担\" class=\"headerlink\" title=\"设置重试次数：系统超负荷时， 一直重试会加重负担\"></a>设置重试次数：系统超负荷时， 一直重试会加重负担</h4><h4 id=\"重试仅对临时性故障有意义，出现永久故障时无意义\"><a href=\"#重试仅对临时性故障有意义，出现永久故障时无意义\" class=\"headerlink\" title=\"重试仅对临时性故障有意义，出现永久故障时无意义\"></a>重试仅对临时性故障有意义，出现永久故障时无意义</h4><h4 id=\"两阶段提交，避免副作用。比如每次事务中国呢调用其它系统，发送邮件等\"><a href=\"#两阶段提交，避免副作用。比如每次事务中国呢调用其它系统，发送邮件等\" class=\"headerlink\" title=\"两阶段提交，避免副作用。比如每次事务中国呢调用其它系统，发送邮件等\"></a>两阶段提交，避免副作用。比如每次事务中国呢调用其它系统，发送邮件等</h4><h4 id=\"客户端重试时失败，-待写入数据可能丢失\"><a href=\"#客户端重试时失败，-待写入数据可能丢失\" class=\"headerlink\" title=\"客户端重试时失败， 待写入数据可能丢失\"></a>客户端重试时失败， 待写入数据可能丢失</h4><h2 id=\"事务的意义\"><a href=\"#事务的意义\" class=\"headerlink\" title=\"事务的意义\"></a>事务的意义</h2><h3 id=\"事务是一个抽象层，提供安全性保证，简化应用层的编程模型\"><a href=\"#事务是一个抽象层，提供安全性保证，简化应用层的编程模型\" class=\"headerlink\" title=\"事务是一个抽象层，提供安全性保证，简化应用层的编程模型\"></a>事务是一个抽象层，提供安全性保证，简化应用层的编程模型</h3><h3 id=\"NoSQL的兴起，很多新一代数据库完全放弃事务支持，或者替换为更弱的保证\"><a href=\"#NoSQL的兴起，很多新一代数据库完全放弃事务支持，或者替换为更弱的保证\" class=\"headerlink\" title=\"NoSQL的兴起，很多新一代数据库完全放弃事务支持，或者替换为更弱的保证\"></a>NoSQL的兴起，很多新一代数据库完全放弃事务支持，或者替换为更弱的保证</h3><h3 id=\"事务有优势，也有局限性，需要权衡\"><a href=\"#事务有优势，也有局限性，需要权衡\" class=\"headerlink\" title=\"事务有优势，也有局限性，需要权衡\"></a>事务有优势，也有局限性，需要权衡</h3><h1 id=\"弱隔离级别\"><a href=\"#弱隔离级别\" class=\"headerlink\" title=\"弱隔离级别\"></a>弱隔离级别</h1><h2 id=\"读提交\"><a href=\"#读提交\" class=\"headerlink\" title=\"读提交\"></a>读提交</h2><h3 id=\"防止脏读\"><a href=\"#防止脏读\" class=\"headerlink\" title=\"防止脏读\"></a>防止脏读</h3><h4 id=\"读数据库时，只能看到已成功提交的数据。不会看到部分更新或会被回滚的数据\"><a href=\"#读数据库时，只能看到已成功提交的数据。不会看到部分更新或会被回滚的数据\" class=\"headerlink\" title=\"读数据库时，只能看到已成功提交的数据。不会看到部分更新或会被回滚的数据\"></a>读数据库时，只能看到已成功提交的数据。不会看到部分更新或会被回滚的数据</h4><h4 id=\"实现：对于待更新对象，-维护旧值和当前持锁事务要设置的新值两个版本。事务提交前读旧值，-提交后切换到新值\"><a href=\"#实现：对于待更新对象，-维护旧值和当前持锁事务要设置的新值两个版本。事务提交前读旧值，-提交后切换到新值\" class=\"headerlink\" title=\"实现：对于待更新对象， 维护旧值和当前持锁事务要设置的新值两个版本。事务提交前读旧值， 提交后切换到新值\"></a>实现：对于待更新对象， 维护旧值和当前持锁事务要设置的新值两个版本。事务提交前读旧值， 提交后切换到新值</h4><h3 id=\"防止脏写\"><a href=\"#防止脏写\" class=\"headerlink\" title=\"防止脏写\"></a>防止脏写</h3><h4 id=\"写数据库时，只会覆盖已成功提交的数据。避免不同事务的写入混杂\"><a href=\"#写数据库时，只会覆盖已成功提交的数据。避免不同事务的写入混杂\" class=\"headerlink\" title=\"写数据库时，只会覆盖已成功提交的数据。避免不同事务的写入混杂\"></a>写数据库时，只会覆盖已成功提交的数据。避免不同事务的写入混杂</h4><h4 id=\"实现：-行级锁。数据库自动完成\"><a href=\"#实现：-行级锁。数据库自动完成\" class=\"headerlink\" title=\"实现： 行级锁。数据库自动完成\"></a>实现： 行级锁。数据库自动完成</h4><h3 id=\"不可重复读-读倾斜-时间异常\"><a href=\"#不可重复读-读倾斜-时间异常\" class=\"headerlink\" title=\"不可重复读/读倾斜(时间异常)\"></a>不可重复读/读倾斜(时间异常)</h3><h4 id=\"备份场景\"><a href=\"#备份场景\" class=\"headerlink\" title=\"备份场景\"></a>备份场景</h4><h4 id=\"分析查询和完整性检查场景\"><a href=\"#分析查询和完整性检查场景\" class=\"headerlink\" title=\"分析查询和完整性检查场景\"></a>分析查询和完整性检查场景</h4><h4 id=\"有些场景不能容忍这种暂时的不一致状态\"><a href=\"#有些场景不能容忍这种暂时的不一致状态\" class=\"headerlink\" title=\"有些场景不能容忍这种暂时的不一致状态\"></a>有些场景不能容忍这种暂时的不一致状态</h4><h2 id=\"快照级别隔离与重复读\"><a href=\"#快照级别隔离与重复读\" class=\"headerlink\" title=\"快照级别隔离与重复读\"></a>快照级别隔离与重复读</h2><h3 id=\"实现快照级别隔离\"><a href=\"#实现快照级别隔离\" class=\"headerlink\" title=\"实现快照级别隔离\"></a>实现快照级别隔离</h3><h4 id=\"MVCC\"><a href=\"#MVCC\" class=\"headerlink\" title=\"MVCC\"></a>MVCC</h4><h3 id=\"一致性快照的可见性原则\"><a href=\"#一致性快照的可见性原则\" class=\"headerlink\" title=\"一致性快照的可见性原则\"></a>一致性快照的可见性原则</h3><h4 id=\"1-进行中的其它事务，不可见\"><a href=\"#1-进行中的其它事务，不可见\" class=\"headerlink\" title=\"1. 进行中的其它事务，不可见\"></a>1. 进行中的其它事务，不可见</h4><h4 id=\"2-所有中止事务所做的修改，不可见\"><a href=\"#2-所有中止事务所做的修改，不可见\" class=\"headerlink\" title=\"2. 所有中止事务所做的修改，不可见\"></a>2. 所有中止事务所做的修改，不可见</h4><h4 id=\"3-较晚事务ID所做任何修改，-无论是否提交，不可见\"><a href=\"#3-较晚事务ID所做任何修改，-无论是否提交，不可见\" class=\"headerlink\" title=\"3. 较晚事务ID所做任何修改， 无论是否提交，不可见\"></a>3. 较晚事务ID所做任何修改， 无论是否提交，不可见</h4><h4 id=\"4-除上述之外的所有写入都对应用查询可见\"><a href=\"#4-除上述之外的所有写入都对应用查询可见\" class=\"headerlink\" title=\"4. 除上述之外的所有写入都对应用查询可见\"></a>4. 除上述之外的所有写入都对应用查询可见</h4><h4 id=\"4-1-事务开始时，-创建该对象的事务已经完成提交\"><a href=\"#4-1-事务开始时，-创建该对象的事务已经完成提交\" class=\"headerlink\" title=\"4.1 事务开始时， 创建该对象的事务已经完成提交\"></a>4.1 事务开始时， 创建该对象的事务已经完成提交</h4><h4 id=\"4-2-对象没有标记为删除，或者标记了，但删除事务在当前事务开始前未完成提交\"><a href=\"#4-2-对象没有标记为删除，或者标记了，但删除事务在当前事务开始前未完成提交\" class=\"headerlink\" title=\"4.2 对象没有标记为删除，或者标记了，但删除事务在当前事务开始前未完成提交\"></a>4.2 对象没有标记为删除，或者标记了，但删除事务在当前事务开始前未完成提交</h4><h3 id=\"快照级别隔离如何支持索引\"><a href=\"#快照级别隔离如何支持索引\" class=\"headerlink\" title=\"快照级别隔离如何支持索引\"></a>快照级别隔离如何支持索引</h3><h4 id=\"方案1-PostgreSQL将同对象的不同版本放在一个内存页面上-：-索引指向对象的所有版本，-过滤当前事务不可见的那些版本。后台垃圾回收进程删除旧对象版本时，同时删除对应索引\"><a href=\"#方案1-PostgreSQL将同对象的不同版本放在一个内存页面上-：-索引指向对象的所有版本，-过滤当前事务不可见的那些版本。后台垃圾回收进程删除旧对象版本时，同时删除对应索引\" class=\"headerlink\" title=\"方案1(PostgreSQL将同对象的不同版本放在一个内存页面上)： 索引指向对象的所有版本， 过滤当前事务不可见的那些版本。后台垃圾回收进程删除旧对象版本时，同时删除对应索引\"></a>方案1(PostgreSQL将同对象的不同版本放在一个内存页面上)： 索引指向对象的所有版本， 过滤当前事务不可见的那些版本。后台垃圾回收进程删除旧对象版本时，同时删除对应索引</h4><h4 id=\"方案2（CouchDB-Datomic-LMDB）：-B-tree，追加-写时复制。更新时，每个写入事务创建新的B-tree-root-代表该时刻数据库的一致性快照\"><a href=\"#方案2（CouchDB-Datomic-LMDB）：-B-tree，追加-写时复制。更新时，每个写入事务创建新的B-tree-root-代表该时刻数据库的一致性快照\" class=\"headerlink\" title=\"方案2（CouchDB,Datomic,LMDB）： B-tree，追加/写时复制。更新时，每个写入事务创建新的B-tree root,代表该时刻数据库的一致性快照\"></a>方案2（CouchDB,Datomic,LMDB）： B-tree，追加/写时复制。更新时，每个写入事务创建新的B-tree root,代表该时刻数据库的一致性快照</h4><h3 id=\"可重复读与命名混淆\"><a href=\"#可重复读与命名混淆\" class=\"headerlink\" title=\"可重复读与命名混淆\"></a>可重复读与命名混淆</h3><h4 id=\"命名混淆：快照隔离技术，-Oracle称为可串行化，-PostgreSQL和MySQL称为可重复读\"><a href=\"#命名混淆：快照隔离技术，-Oracle称为可串行化，-PostgreSQL和MySQL称为可重复读\" class=\"headerlink\" title=\"命名混淆：快照隔离技术， Oracle称为可串行化， PostgreSQL和MySQL称为可重复读\"></a>命名混淆：快照隔离技术， Oracle称为可串行化， PostgreSQL和MySQL称为可重复读</h4><h4 id=\"原因：-SQL标准只定义了可重复读，-未定义快照级别隔离\"><a href=\"#原因：-SQL标准只定义了可重复读，-未定义快照级别隔离\" class=\"headerlink\" title=\"原因： SQL标准只定义了可重复读， 未定义快照级别隔离\"></a>原因： SQL标准只定义了可重复读， 未定义快照级别隔离</h4><h2 id=\"防止更新丢失（写事务并发）\"><a href=\"#防止更新丢失（写事务并发）\" class=\"headerlink\" title=\"防止更新丢失（写事务并发）\"></a>防止更新丢失（写事务并发）</h2><h3 id=\"原子写操作（数据库）\"><a href=\"#原子写操作（数据库）\" class=\"headerlink\" title=\"原子写操作（数据库）\"></a>原子写操作（数据库）</h3><h4 id=\"许多数据库提供了原子更新操作-eg-update-counters-set-value-value-1-where-key-39-foo-39\"><a href=\"#许多数据库提供了原子更新操作-eg-update-counters-set-value-value-1-where-key-39-foo-39\" class=\"headerlink\" title=\"许多数据库提供了原子更新操作 eg: update counters set value = value + 1 where key = &#39;foo&#39;;\"></a>许多数据库提供了原子更新操作 eg: update counters set value = value + 1 where key = &#39;foo&#39;;</h4><h4 id=\"实现1：-对读取对象加独占锁，更新提交前不会有其它事务可读它（游标稳定性）\"><a href=\"#实现1：-对读取对象加独占锁，更新提交前不会有其它事务可读它（游标稳定性）\" class=\"headerlink\" title=\"实现1： 对读取对象加独占锁，更新提交前不会有其它事务可读它（游标稳定性）\"></a>实现1： 对读取对象加独占锁，更新提交前不会有其它事务可读它（游标稳定性）</h4><h4 id=\"实现2：-强制所有的原子操作都在单线程上执行\"><a href=\"#实现2：-强制所有的原子操作都在单线程上执行\" class=\"headerlink\" title=\"实现2： 强制所有的原子操作都在单线程上执行\"></a>实现2： 强制所有的原子操作都在单线程上执行</h4><h3 id=\"显式加锁（应用层）\"><a href=\"#显式加锁（应用层）\" class=\"headerlink\" title=\"显式加锁（应用层）\"></a>显式加锁（应用层）</h3><h4 id=\"应用程序显式锁定待更新的对象，然后执行-quot-读-修改-写回-quot\"><a href=\"#应用程序显式锁定待更新的对象，然后执行-quot-读-修改-写回-quot\" class=\"headerlink\" title=\"应用程序显式锁定待更新的对象，然后执行&quot;读-修改-写回&quot;\"></a>应用程序显式锁定待更新的对象，然后执行&quot;读-修改-写回&quot;</h4><h3 id=\"自动检测更新丢失（借助快照级别隔离来高效执行）\"><a href=\"#自动检测更新丢失（借助快照级别隔离来高效执行）\" class=\"headerlink\" title=\"自动检测更新丢失（借助快照级别隔离来高效执行）\"></a>自动检测更新丢失（借助快照级别隔离来高效执行）</h3><h4 id=\"原子操作和锁都是强制-quot-读-修改-写回-quot-操作序列串行执行\"><a href=\"#原子操作和锁都是强制-quot-读-修改-写回-quot-操作序列串行执行\" class=\"headerlink\" title=\"原子操作和锁都是强制&quot;读-修改-写回&quot;操作序列串行执行\"></a>原子操作和锁都是强制&quot;读-修改-写回&quot;操作序列串行执行</h4><h4 id=\"换个思路：-先让他们并发执行，-如果事务管理器检测到了更新丢失风险，-中止当前事务，-强制回退到安全的-quot-读-修改-写回-quot\"><a href=\"#换个思路：-先让他们并发执行，-如果事务管理器检测到了更新丢失风险，-中止当前事务，-强制回退到安全的-quot-读-修改-写回-quot\" class=\"headerlink\" title=\"换个思路： 先让他们并发执行， 如果事务管理器检测到了更新丢失风险， 中止当前事务， 强制回退到安全的&quot;读-修改-写回&quot;\"></a>换个思路： 先让他们并发执行， 如果事务管理器检测到了更新丢失风险， 中止当前事务， 强制回退到安全的&quot;读-修改-写回&quot;</h4><h4 id=\"PostgreSQL的可重复读，-Oracle的可串行化，SQL-Server的快照级别隔离都支持\"><a href=\"#PostgreSQL的可重复读，-Oracle的可串行化，SQL-Server的快照级别隔离都支持\" class=\"headerlink\" title=\"PostgreSQL的可重复读， Oracle的可串行化，SQL Server的快照级别隔离都支持\"></a>PostgreSQL的可重复读， Oracle的可串行化，SQL Server的快照级别隔离都支持</h4><h4 id=\"MySQL-InnoDB的可重复读不支持\"><a href=\"#MySQL-InnoDB的可重复读不支持\" class=\"headerlink\" title=\"MySQL InnoDB的可重复读不支持\"></a>MySQL InnoDB的可重复读不支持</h4><h3 id=\"原子比较和设置（无事务支持）\"><a href=\"#原子比较和设置（无事务支持）\" class=\"headerlink\" title=\"原子比较和设置（无事务支持）\"></a>原子比较和设置（无事务支持）</h3><h4 id=\"先执行CAS，如果不成功则回退到-quot-读-修改-写回-quot\"><a href=\"#先执行CAS，如果不成功则回退到-quot-读-修改-写回-quot\" class=\"headerlink\" title=\"先执行CAS，如果不成功则回退到&quot;读-修改-写回&quot;\"></a>先执行CAS，如果不成功则回退到&quot;读-修改-写回&quot;</h4><h4 id=\"注意：-如果where语句运行在旧快照上，可能无法防止另一个并发写入。所以要仔细检查CAS操作的安全运行条件\"><a href=\"#注意：-如果where语句运行在旧快照上，可能无法防止另一个并发写入。所以要仔细检查CAS操作的安全运行条件\" class=\"headerlink\" title=\"注意： 如果where语句运行在旧快照上，可能无法防止另一个并发写入。所以要仔细检查CAS操作的安全运行条件\"></a>注意： 如果where语句运行在旧快照上，可能无法防止另一个并发写入。所以要仔细检查CAS操作的安全运行条件</h4><h3 id=\"冲突解决与复制（多副本）\"><a href=\"#冲突解决与复制（多副本）\" class=\"headerlink\" title=\"冲突解决与复制（多副本）\"></a>冲突解决与复制（多副本）</h3><h4 id=\"保留多个冲突版本，由应用层逻辑或依靠特定的数据结构来解决\"><a href=\"#保留多个冲突版本，由应用层逻辑或依靠特定的数据结构来解决\" class=\"headerlink\" title=\"保留多个冲突版本，由应用层逻辑或依靠特定的数据结构来解决\"></a>保留多个冲突版本，由应用层逻辑或依靠特定的数据结构来解决</h4><h4 id=\"如果操作顺序无关，则原子操作可行\"><a href=\"#如果操作顺序无关，则原子操作可行\" class=\"headerlink\" title=\"如果操作顺序无关，则原子操作可行\"></a>如果操作顺序无关，则原子操作可行</h4><h4 id=\"LWW，容易丢失更新，但是目前许多多副本数据库的默认配置\"><a href=\"#LWW，容易丢失更新，但是目前许多多副本数据库的默认配置\" class=\"headerlink\" title=\"LWW，容易丢失更新，但是目前许多多副本数据库的默认配置\"></a>LWW，容易丢失更新，但是目前许多多副本数据库的默认配置</h4><h2 id=\"写倾斜与幻读\"><a href=\"#写倾斜与幻读\" class=\"headerlink\" title=\"写倾斜与幻读\"></a>写倾斜与幻读</h2><h3 id=\"定义写倾斜-幻读\"><a href=\"#定义写倾斜-幻读\" class=\"headerlink\" title=\"定义写倾斜/幻读\"></a>定义写倾斜/幻读</h3><h4 id=\"一个事务的写入改变了另一个事务查询结果\"><a href=\"#一个事务的写入改变了另一个事务查询结果\" class=\"headerlink\" title=\"一个事务的写入改变了另一个事务查询结果\"></a>一个事务的写入改变了另一个事务查询结果</h4><h4 id=\"更新丢失问题。如果两个事务读取相同的一组对象，然后更新其中一部分\"><a href=\"#更新丢失问题。如果两个事务读取相同的一组对象，然后更新其中一部分\" class=\"headerlink\" title=\"更新丢失问题。如果两个事务读取相同的一组对象，然后更新其中一部分\"></a>更新丢失问题。如果两个事务读取相同的一组对象，然后更新其中一部分</h4><h4 id=\"写倾斜：不同的事务可能更新不同的对象\"><a href=\"#写倾斜：不同的事务可能更新不同的对象\" class=\"headerlink\" title=\"写倾斜：不同的事务可能更新不同的对象\"></a>写倾斜：不同的事务可能更新不同的对象</h4><h4 id=\"脏写、更新丢失：-不同的事务更新的是同一个对象\"><a href=\"#脏写、更新丢失：-不同的事务更新的是同一个对象\" class=\"headerlink\" title=\"脏写、更新丢失： 不同的事务更新的是同一个对象\"></a>脏写、更新丢失： 不同的事务更新的是同一个对象</h4><h4 id=\"之前可选方案的可行性\"><a href=\"#之前可选方案的可行性\" class=\"headerlink\" title=\"之前可选方案的可行性\"></a>之前可选方案的可行性</h4><h4 id=\"原子操作，不可行，因为涉及到多个对象\"><a href=\"#原子操作，不可行，因为涉及到多个对象\" class=\"headerlink\" title=\"原子操作，不可行，因为涉及到多个对象\"></a>原子操作，不可行，因为涉及到多个对象</h4><h4 id=\"定义数据库约束条件，然后数据库代为检查、执行约束，-不可行，-大多数场景的类型约束数据库不支持\"><a href=\"#定义数据库约束条件，然后数据库代为检查、执行约束，-不可行，-大多数场景的类型约束数据库不支持\" class=\"headerlink\" title=\"定义数据库约束条件，然后数据库代为检查、执行约束， 不可行， 大多数场景的类型约束数据库不支持\"></a>定义数据库约束条件，然后数据库代为检查、执行约束， 不可行， 大多数场景的类型约束数据库不支持</h4><h4 id=\"自动检测更新丢失，不可行，目前都不支持自动检测写倾斜（需要真正的可串行化隔离）\"><a href=\"#自动检测更新丢失，不可行，目前都不支持自动检测写倾斜（需要真正的可串行化隔离）\" class=\"headerlink\" title=\"自动检测更新丢失，不可行，目前都不支持自动检测写倾斜（需要真正的可串行化隔离）\"></a>自动检测更新丢失，不可行，目前都不支持自动检测写倾斜（需要真正的可串行化隔离）</h4><h4 id=\"对事务依赖的行来显式加锁，可行，-FOR-UPDATE\"><a href=\"#对事务依赖的行来显式加锁，可行，-FOR-UPDATE\" class=\"headerlink\" title=\"对事务依赖的行来显式加锁，可行， FOR UPDATE\"></a>对事务依赖的行来显式加锁，可行， FOR UPDATE</h4><h3 id=\"更多写倾斜的案例\"><a href=\"#更多写倾斜的案例\" class=\"headerlink\" title=\"更多写倾斜的案例\"></a>更多写倾斜的案例</h3><h3 id=\"为何产生写倾斜\"><a href=\"#为何产生写倾斜\" class=\"headerlink\" title=\"为何产生写倾斜\"></a>为何产生写倾斜</h3><h3 id=\"实体化冲突\"><a href=\"#实体化冲突\" class=\"headerlink\" title=\"实体化冲突\"></a>实体化冲突</h3><h4 id=\"把幻读问题-转变为-针对数据库中一组具体行的锁冲突问题\"><a href=\"#把幻读问题-转变为-针对数据库中一组具体行的锁冲突问题\" class=\"headerlink\" title=\"把幻读问题 转变为 针对数据库中一组具体行的锁冲突问题\"></a>把幻读问题 转变为 针对数据库中一组具体行的锁冲突问题</h4><h4 id=\"并发控制机制-降级为-数据模型\"><a href=\"#并发控制机制-降级为-数据模型\" class=\"headerlink\" title=\"并发控制机制 降级为 数据模型\"></a>并发控制机制 降级为 数据模型</h4><h1 id=\"串行化\"><a href=\"#串行化\" class=\"headerlink\" title=\"串行化\"></a>串行化</h1><h2 id=\"实际串行执行\"><a href=\"#实际串行执行\" class=\"headerlink\" title=\"实际串行执行\"></a>实际串行执行</h2><h3 id=\"采用存储过程封装事务\"><a href=\"#采用存储过程封装事务\" class=\"headerlink\" title=\"采用存储过程封装事务\"></a>采用存储过程封装事务</h3><h4 id=\"避免等待IO（用户交互，应用程序与数据库间多次网络通信）\"><a href=\"#避免等待IO（用户交互，应用程序与数据库间多次网络通信）\" class=\"headerlink\" title=\"避免等待IO（用户交互，应用程序与数据库间多次网络通信）\"></a>避免等待IO（用户交互，应用程序与数据库间多次网络通信）</h4><h3 id=\"存储过程的优缺点\"><a href=\"#存储过程的优缺点\" class=\"headerlink\" title=\"存储过程的优缺点\"></a>存储过程的优缺点</h3><h4 id=\"数据库厂商的存储过程语言大多语义丑陋，过时（最新的存储过程使用现有通用语言：-VoltDB使用Java或Groovy-Datomic使用Java或Clojure，Redis使用Lua）\"><a href=\"#数据库厂商的存储过程语言大多语义丑陋，过时（最新的存储过程使用现有通用语言：-VoltDB使用Java或Groovy-Datomic使用Java或Clojure，Redis使用Lua）\" class=\"headerlink\" title=\"数据库厂商的存储过程语言大多语义丑陋，过时（最新的存储过程使用现有通用语言： VoltDB使用Java或Groovy,Datomic使用Java或Clojure，Redis使用Lua）\"></a>数据库厂商的存储过程语言大多语义丑陋，过时（最新的存储过程使用现有通用语言： VoltDB使用Java或Groovy,Datomic使用Java或Clojure，Redis使用Lua）</h4><h4 id=\"数据库中运行代码难以管理（调试，版本控制，部署，测试，监控）\"><a href=\"#数据库中运行代码难以管理（调试，版本控制，部署，测试，监控）\" class=\"headerlink\" title=\"数据库中运行代码难以管理（调试，版本控制，部署，测试，监控）\"></a>数据库中运行代码难以管理（调试，版本控制，部署，测试，监控）</h4><h4 id=\"设计不好，所有应用程序都受影响\"><a href=\"#设计不好，所有应用程序都受影响\" class=\"headerlink\" title=\"设计不好，所有应用程序都受影响\"></a>设计不好，所有应用程序都受影响</h4><h3 id=\"分区\"><a href=\"#分区\" class=\"headerlink\" title=\"分区\"></a>分区</h3><h4 id=\"高写入需求下，单线程事务处理容易成为瓶颈\"><a href=\"#高写入需求下，单线程事务处理容易成为瓶颈\" class=\"headerlink\" title=\"高写入需求下，单线程事务处理容易成为瓶颈\"></a>高写入需求下，单线程事务处理容易成为瓶颈</h4><h4 id=\"分区，扩展到多个CPU核和多节点\"><a href=\"#分区，扩展到多个CPU核和多节点\" class=\"headerlink\" title=\"分区，扩展到多个CPU核和多节点\"></a>分区，扩展到多个CPU核和多节点</h4><h4 id=\"跨分区事务由额外的协调开销，所以适合大量键值数据，不适合带有多个二级索引的数据\"><a href=\"#跨分区事务由额外的协调开销，所以适合大量键值数据，不适合带有多个二级索引的数据\" class=\"headerlink\" title=\"跨分区事务由额外的协调开销，所以适合大量键值数据，不适合带有多个二级索引的数据\"></a>跨分区事务由额外的协调开销，所以适合大量键值数据，不适合带有多个二级索引的数据</h4><h3 id=\"串行执行小结\"><a href=\"#串行执行小结\" class=\"headerlink\" title=\"串行执行小结\"></a>串行执行小结</h3><h3 id=\"为什么现在能实现，为什么以前都要靠多线程并发来提升性能\"><a href=\"#为什么现在能实现，为什么以前都要靠多线程并发来提升性能\" class=\"headerlink\" title=\"为什么现在能实现，为什么以前都要靠多线程并发来提升性能\"></a>为什么现在能实现，为什么以前都要靠多线程并发来提升性能</h3><h4 id=\"内存越来越便宜，-事务所需数据都可加载到内存中\"><a href=\"#内存越来越便宜，-事务所需数据都可加载到内存中\" class=\"headerlink\" title=\"内存越来越便宜， 事务所需数据都可加载到内存中\"></a>内存越来越便宜， 事务所需数据都可加载到内存中</h4><h4 id=\"OLTP事务通常执行很快\"><a href=\"#OLTP事务通常执行很快\" class=\"headerlink\" title=\"OLTP事务通常执行很快\"></a>OLTP事务通常执行很快</h4><h4 id=\"Redis-VoltDB-H-store-Datomic等采用串行，-避免锁开销，-吞吐量上限为单个CPU核的吞吐量\"><a href=\"#Redis-VoltDB-H-store-Datomic等采用串行，-避免锁开销，-吞吐量上限为单个CPU核的吞吐量\" class=\"headerlink\" title=\"Redis, VoltDB/H-store, Datomic等采用串行， 避免锁开销， 吞吐量上限为单个CPU核的吞吐量\"></a>Redis, VoltDB/H-store, Datomic等采用串行， 避免锁开销， 吞吐量上限为单个CPU核的吞吐量</h4><h2 id=\"两阶段加锁（two-phase-locking-2PL）\"><a href=\"#两阶段加锁（two-phase-locking-2PL）\" class=\"headerlink\" title=\"两阶段加锁（two-phase locking, 2PL）\"></a>两阶段加锁（two-phase locking, 2PL）</h2><h3 id=\"实现2PL\"><a href=\"#实现2PL\" class=\"headerlink\" title=\"实现2PL\"></a>实现2PL</h3><h4 id=\"多个事务可以同时读取同一对象，但只要出现任何写操作，则必须加锁以独占访问（读写也会互斥）\"><a href=\"#多个事务可以同时读取同一对象，但只要出现任何写操作，则必须加锁以独占访问（读写也会互斥）\" class=\"headerlink\" title=\"多个事务可以同时读取同一对象，但只要出现任何写操作，则必须加锁以独占访问（读写也会互斥）\"></a>多个事务可以同时读取同一对象，但只要出现任何写操作，则必须加锁以独占访问（读写也会互斥）</h4><h4 id=\"1-每个对象都有一个读写锁来隔离读写操作\"><a href=\"#1-每个对象都有一个读写锁来隔离读写操作\" class=\"headerlink\" title=\"1. 每个对象都有一个读写锁来隔离读写操作\"></a>1. 每个对象都有一个读写锁来隔离读写操作</h4><h4 id=\"2-事务要读取对象，必须先获得读锁，可以有多个事务同时获得一个对象的读锁\"><a href=\"#2-事务要读取对象，必须先获得读锁，可以有多个事务同时获得一个对象的读锁\" class=\"headerlink\" title=\"2. 事务要读取对象，必须先获得读锁，可以有多个事务同时获得一个对象的读锁\"></a>2. 事务要读取对象，必须先获得读锁，可以有多个事务同时获得一个对象的读锁</h4><h4 id=\"3-如果某个事务已经获得对象的写锁，-其它事务必须等待\"><a href=\"#3-如果某个事务已经获得对象的写锁，-其它事务必须等待\" class=\"headerlink\" title=\"3. 如果某个事务已经获得对象的写锁， 其它事务必须等待\"></a>3. 如果某个事务已经获得对象的写锁， 其它事务必须等待</h4><h4 id=\"5-如果事务先读取，然后尝试写入，必须先把读锁升级为写锁\"><a href=\"#5-如果事务先读取，然后尝试写入，必须先把读锁升级为写锁\" class=\"headerlink\" title=\"5. 如果事务先读取，然后尝试写入，必须先把读锁升级为写锁\"></a>5. 如果事务先读取，然后尝试写入，必须先把读锁升级为写锁</h4><h4 id=\"4-事务要修改对象，-必须先获取写锁，如果已被加写锁，必须等待\"><a href=\"#4-事务要修改对象，-必须先获取写锁，如果已被加写锁，必须等待\" class=\"headerlink\" title=\"4. 事务要修改对象， 必须先获取写锁，如果已被加写锁，必须等待\"></a>4. 事务要修改对象， 必须先获取写锁，如果已被加写锁，必须等待</h4><h4 id=\"6-事务获得锁后，-一直持有到事务结束。第一阶段即事务执行之前要获取锁，第二阶段即事务结束时要释放锁。\"><a href=\"#6-事务获得锁后，-一直持有到事务结束。第一阶段即事务执行之前要获取锁，第二阶段即事务结束时要释放锁。\" class=\"headerlink\" title=\"6. 事务获得锁后， 一直持有到事务结束。第一阶段即事务执行之前要获取锁，第二阶段即事务结束时要释放锁。\"></a>6. 事务获得锁后， 一直持有到事务结束。第一阶段即事务执行之前要获取锁，第二阶段即事务结束时要释放锁。</h4><h4 id=\"容易死锁，数据库自动检测死锁，-强行中止其中一个\"><a href=\"#容易死锁，数据库自动检测死锁，-强行中止其中一个\" class=\"headerlink\" title=\"容易死锁，数据库自动检测死锁， 强行中止其中一个\"></a>容易死锁，数据库自动检测死锁， 强行中止其中一个</h4><h3 id=\"2PL的性能\"><a href=\"#2PL的性能\" class=\"headerlink\" title=\"2PL的性能\"></a>2PL的性能</h3><h4 id=\"锁的获取和释放本身开销\"><a href=\"#锁的获取和释放本身开销\" class=\"headerlink\" title=\"锁的获取和释放本身开销\"></a>锁的获取和释放本身开销</h4><h4 id=\"数据库访问延迟具有非常大的不确定性\"><a href=\"#数据库访问延迟具有非常大的不确定性\" class=\"headerlink\" title=\"数据库访问延迟具有非常大的不确定性\"></a>数据库访问延迟具有非常大的不确定性</h4><h4 id=\"降低了事务的并发性\"><a href=\"#降低了事务的并发性\" class=\"headerlink\" title=\"降低了事务的并发性\"></a>降低了事务的并发性</h4><h4 id=\"死锁更为频繁，如果由于死锁而被强行中止，应用层必须从头重试\"><a href=\"#死锁更为频繁，如果由于死锁而被强行中止，应用层必须从头重试\" class=\"headerlink\" title=\"死锁更为频繁，如果由于死锁而被强行中止，应用层必须从头重试\"></a>死锁更为频繁，如果由于死锁而被强行中止，应用层必须从头重试</h4><h3 id=\"谓词锁\"><a href=\"#谓词锁\" class=\"headerlink\" title=\"谓词锁\"></a>谓词锁</h3><h4 id=\"可串行化隔离也要防止幻读问题\"><a href=\"#可串行化隔离也要防止幻读问题\" class=\"headerlink\" title=\"可串行化隔离也要防止幻读问题\"></a>可串行化隔离也要防止幻读问题</h4><h4 id=\"作用于某些搜索条件的所有查询对象\"><a href=\"#作用于某些搜索条件的所有查询对象\" class=\"headerlink\" title=\"作用于某些搜索条件的所有查询对象\"></a>作用于某些搜索条件的所有查询对象</h4><h4 id=\"谓词锁可以保护那些上不存在但可能马上会被插入的对象\"><a href=\"#谓词锁可以保护那些上不存在但可能马上会被插入的对象\" class=\"headerlink\" title=\"谓词锁可以保护那些上不存在但可能马上会被插入的对象\"></a>谓词锁可以保护那些上不存在但可能马上会被插入的对象</h4><h4 id=\"两阶段加锁-谓词锁，可以防止所有竞争条件，隔离变得真正可串行化\"><a href=\"#两阶段加锁-谓词锁，可以防止所有竞争条件，隔离变得真正可串行化\" class=\"headerlink\" title=\"两阶段加锁+谓词锁，可以防止所有竞争条件，隔离变得真正可串行化\"></a>两阶段加锁+谓词锁，可以防止所有竞争条件，隔离变得真正可串行化</h4><h3 id=\"索引区间锁\"><a href=\"#索引区间锁\" class=\"headerlink\" title=\"索引区间锁\"></a>索引区间锁</h3><h4 id=\"对谓词锁的简化，因为谓词锁性能不佳\"><a href=\"#对谓词锁的简化，因为谓词锁性能不佳\" class=\"headerlink\" title=\"对谓词锁的简化，因为谓词锁性能不佳\"></a>对谓词锁的简化，因为谓词锁性能不佳</h4><h4 id=\"将保护的对象扩大化，不像谓词锁那么精确，但是开销低\"><a href=\"#将保护的对象扩大化，不像谓词锁那么精确，但是开销低\" class=\"headerlink\" title=\"将保护的对象扩大化，不像谓词锁那么精确，但是开销低\"></a>将保护的对象扩大化，不像谓词锁那么精确，但是开销低</h4><h4 id=\"如果没有合适的索引，可以回退到对整个表施加共享锁\"><a href=\"#如果没有合适的索引，可以回退到对整个表施加共享锁\" class=\"headerlink\" title=\"如果没有合适的索引，可以回退到对整个表施加共享锁\"></a>如果没有合适的索引，可以回退到对整个表施加共享锁</h4><h2 id=\"可串行化的快照隔离（SSI）\"><a href=\"#可串行化的快照隔离（SSI）\" class=\"headerlink\" title=\"可串行化的快照隔离（SSI）\"></a>可串行化的快照隔离（SSI）</h2><h3 id=\"悲观与乐观的并发控制\"><a href=\"#悲观与乐观的并发控制\" class=\"headerlink\" title=\"悲观与乐观的并发控制\"></a>悲观与乐观的并发控制</h3><h4 id=\"2PL是悲观并发控制机制\"><a href=\"#2PL是悲观并发控制机制\" class=\"headerlink\" title=\"2PL是悲观并发控制机制\"></a>2PL是悲观并发控制机制</h4><h4 id=\"SSI是乐观并发控制：-如果可能发生潜在冲突，事务继续执行而不中止；事务提交时检查是否冲突，是的话再中止并重试。\"><a href=\"#SSI是乐观并发控制：-如果可能发生潜在冲突，事务继续执行而不中止；事务提交时检查是否冲突，是的话再中止并重试。\" class=\"headerlink\" title=\"SSI是乐观并发控制： 如果可能发生潜在冲突，事务继续执行而不中止；事务提交时检查是否冲突，是的话再中止并重试。\"></a>SSI是乐观并发控制： 如果可能发生潜在冲突，事务继续执行而不中止；事务提交时检查是否冲突，是的话再中止并重试。</h4><h4 id=\"缺点：-如果冲突很多，则性能不佳；-如果系统已接近最大吞吐量，反复重试会使情况更糟\"><a href=\"#缺点：-如果冲突很多，则性能不佳；-如果系统已接近最大吞吐量，反复重试会使情况更糟\" class=\"headerlink\" title=\"缺点： 如果冲突很多，则性能不佳； 如果系统已接近最大吞吐量，反复重试会使情况更糟\"></a>缺点： 如果冲突很多，则性能不佳； 如果系统已接近最大吞吐量，反复重试会使情况更糟</h4><h4 id=\"优点：-如果系统有足够的性能提升空间，且事务竞争不大，-乐观并发控制会高效很多\"><a href=\"#优点：-如果系统有足够的性能提升空间，且事务竞争不大，-乐观并发控制会高效很多\" class=\"headerlink\" title=\"优点： 如果系统有足够的性能提升空间，且事务竞争不大， 乐观并发控制会高效很多\"></a>优点： 如果系统有足够的性能提升空间，且事务竞争不大， 乐观并发控制会高效很多</h4><h3 id=\"基于过期的条件做决定\"><a href=\"#基于过期的条件做决定\" class=\"headerlink\" title=\"基于过期的条件做决定\"></a>基于过期的条件做决定</h3><h4 id=\"数据库必须检测事务是否会修改其他事务的查询结果\"><a href=\"#数据库必须检测事务是否会修改其他事务的查询结果\" class=\"headerlink\" title=\"数据库必须检测事务是否会修改其他事务的查询结果\"></a>数据库必须检测事务是否会修改其他事务的查询结果</h4><h4 id=\"1-检测是否读取了（即将）过期的MVCC对象，即读取前已经有未提交的写入\"><a href=\"#1-检测是否读取了（即将）过期的MVCC对象，即读取前已经有未提交的写入\" class=\"headerlink\" title=\"1. 检测是否读取了（即将）过期的MVCC对象，即读取前已经有未提交的写入\"></a>1. 检测是否读取了（即将）过期的MVCC对象，即读取前已经有未提交的写入</h4><h4 id=\"2-检测写是否影响了之前的读，即读取后，又有新的写入\"><a href=\"#2-检测写是否影响了之前的读，即读取后，又有新的写入\" class=\"headerlink\" title=\"2.检测写是否影响了之前的读，即读取后，又有新的写入\"></a>2.检测写是否影响了之前的读，即读取后，又有新的写入</h4><h3 id=\"可串行化快照隔离的性能\"><a href=\"#可串行化快照隔离的性能\" class=\"headerlink\" title=\"可串行化快照隔离的性能\"></a>可串行化快照隔离的性能</h3><h4 id=\"优点：事务不需要等待其它事务所持有的锁，只读查询不需要任何锁\"><a href=\"#优点：事务不需要等待其它事务所持有的锁，只读查询不需要任何锁\" class=\"headerlink\" title=\"优点：事务不需要等待其它事务所持有的锁，只读查询不需要任何锁\"></a>优点：事务不需要等待其它事务所持有的锁，只读查询不需要任何锁</h4><h4 id=\"可以突破单个CPU核的限制，FoundationDB将冲突检测分区，事务分区\"><a href=\"#可以突破单个CPU核的限制，FoundationDB将冲突检测分区，事务分区\" class=\"headerlink\" title=\"可以突破单个CPU核的限制，FoundationDB将冲突检测分区，事务分区\"></a>可以突破单个CPU核的限制，FoundationDB将冲突检测分区，事务分区</h4><h4 id=\"事务中止的比例会显著影响SSI的性能表现\"><a href=\"#事务中止的比例会显著影响SSI的性能表现\" class=\"headerlink\" title=\"事务中止的比例会显著影响SSI的性能表现\"></a>事务中止的比例会显著影响SSI的性能表现</h4><h1 id=\"边界条件小结\"><a href=\"#边界条件小结\" class=\"headerlink\" title=\"边界条件小结\"></a>边界条件小结</h1><h2 id=\"脏读\"><a href=\"#脏读\" class=\"headerlink\" title=\"脏读\"></a>脏读</h2><h2 id=\"脏写\"><a href=\"#脏写\" class=\"headerlink\" title=\"脏写\"></a>脏写</h2><h2 id=\"读倾斜（不可重复读）\"><a href=\"#读倾斜（不可重复读）\" class=\"headerlink\" title=\"读倾斜（不可重复读）\"></a>读倾斜（不可重复读）</h2><h2 id=\"更新丢失\"><a href=\"#更新丢失\" class=\"headerlink\" title=\"更新丢失\"></a>更新丢失</h2><h2 id=\"写倾斜\"><a href=\"#写倾斜\" class=\"headerlink\" title=\"写倾斜\"></a>写倾斜</h2><h2 id=\"幻读\"><a href=\"#幻读\" class=\"headerlink\" title=\"幻读\"></a>幻读</h2>","site":{"data":{}},"excerpt":"<h1 id=\"深入理解事务\"><a href=\"#深入理解事务\" class=\"headerlink\" title=\"深入理解事务\"></a>深入理解事务</h1><h2 id=\"ACID的含义\"><a href=\"#ACID的含义\" class=\"headerlink\" title=\"ACID的含义\"></a>ACID的含义</h2><h3 id=\"原子性（Atomicity）\"><a href=\"#原子性（Atomicity）\" class=\"headerlink\" title=\"原子性（Atomicity）\"></a>原子性（Atomicity）</h3><h4 id=\"在出错时中止事务，-并将部分完成的写入全部丢弃\"><a href=\"#在出错时中止事务，-并将部分完成的写入全部丢弃\" class=\"headerlink\" title=\"在出错时中止事务， 并将部分完成的写入全部丢弃\"></a>在出错时中止事务， 并将部分完成的写入全部丢弃</h4><h4 id=\"可中止性。简化了排错过程，事务如果中止，-应用可以安全地重试\"><a href=\"#可中止性。简化了排错过程，事务如果中止，-应用可以安全地重试\" class=\"headerlink\" title=\"可中止性。简化了排错过程，事务如果中止， 应用可以安全地重试\"></a>可中止性。简化了排错过程，事务如果中止， 应用可以安全地重试</h4><h3 id=\"一致性-Consistency\"><a href=\"#一致性-Consistency\" class=\"headerlink\" title=\"一致性(Consistency)\"></a>一致性(Consistency)</h3><h4 id=\"对数据有特定的预期状态，-任何数据更改必须满足这些状态约束（或者恒等条件）\"><a href=\"#对数据有特定的预期状态，-任何数据更改必须满足这些状态约束（或者恒等条件）\" class=\"headerlink\" title=\"对数据有特定的预期状态， 任何数据更改必须满足这些状态约束（或者恒等条件）\"></a>对数据有特定的预期状态， 任何数据更改必须满足这些状态约束（或者恒等条件）</h4><h4 id=\"本质上要求应用层来维护一致\"><a href=\"#本质上要求应用层来维护一致\" class=\"headerlink\" title=\"本质上要求应用层来维护一致\"></a>本质上要求应用层来维护一致</h4><h4 id=\"应用程序可能借助数据库提供的原子性和隔离性，-以达到一致性，-但一致性本身并不源于数据库\"><a href=\"#应用程序可能借助数据库提供的原子性和隔离性，-以达到一致性，-但一致性本身并不源于数据库\" class=\"headerlink\" title=\"应用程序可能借助数据库提供的原子性和隔离性， 以达到一致性， 但一致性本身并不源于数据库\"></a>应用程序可能借助数据库提供的原子性和隔离性， 以达到一致性， 但一致性本身并不源于数据库</h4>","more":"<h4 id=\"数据库只能完成针对某些特定类型的恒等约束条件，例如外健约束或唯一性约束\"><a href=\"#数据库只能完成针对某些特定类型的恒等约束条件，例如外健约束或唯一性约束\" class=\"headerlink\" title=\"数据库只能完成针对某些特定类型的恒等约束条件，例如外健约束或唯一性约束\"></a>数据库只能完成针对某些特定类型的恒等约束条件，例如外健约束或唯一性约束</h4><h3 id=\"持久性-Durability\"><a href=\"#持久性-Durability\" class=\"headerlink\" title=\"持久性(Durability)\"></a>持久性(Durability)</h3><h4 id=\"一旦事务提交成功，-即使存在硬件故障或数据库崩溃，事务所写入的任何数据不会消失\"><a href=\"#一旦事务提交成功，-即使存在硬件故障或数据库崩溃，事务所写入的任何数据不会消失\" class=\"headerlink\" title=\"一旦事务提交成功， 即使存在硬件故障或数据库崩溃，事务所写入的任何数据不会消失\"></a>一旦事务提交成功， 即使存在硬件故障或数据库崩溃，事务所写入的任何数据不会消失</h4><h4 id=\"没有哪一项技术可以提供绝对的持久性保证，-应该组合使用\"><a href=\"#没有哪一项技术可以提供绝对的持久性保证，-应该组合使用\" class=\"headerlink\" title=\"没有哪一项技术可以提供绝对的持久性保证， 应该组合使用\"></a>没有哪一项技术可以提供绝对的持久性保证， 应该组合使用</h4><h4 id=\"数据写入硬盘，-使用预写日志，-复制\"><a href=\"#数据写入硬盘，-使用预写日志，-复制\" class=\"headerlink\" title=\"数据写入硬盘， 使用预写日志， 复制\"></a>数据写入硬盘， 使用预写日志， 复制</h4><h3 id=\"隔离性-Isolation\"><a href=\"#隔离性-Isolation\" class=\"headerlink\" title=\"隔离性(Isolation)\"></a>隔离性(Isolation)</h3><h4 id=\"并发执行的多个事务相互隔离，-不能互相交叉\"><a href=\"#并发执行的多个事务相互隔离，-不能互相交叉\" class=\"headerlink\" title=\"并发执行的多个事务相互隔离， 不能互相交叉\"></a>并发执行的多个事务相互隔离， 不能互相交叉</h4><h4 id=\"由于串行化隔离的性能原因，常用的是更弱级别的隔离\"><a href=\"#由于串行化隔离的性能原因，常用的是更弱级别的隔离\" class=\"headerlink\" title=\"由于串行化隔离的性能原因，常用的是更弱级别的隔离\"></a>由于串行化隔离的性能原因，常用的是更弱级别的隔离</h4><h2 id=\"单对象与多对象事务操作\"><a href=\"#单对象与多对象事务操作\" class=\"headerlink\" title=\"单对象与多对象事务操作\"></a>单对象与多对象事务操作</h2><h3 id=\"单对象写入\"><a href=\"#单对象写入\" class=\"headerlink\" title=\"单对象写入\"></a>单对象写入</h3><h4 id=\"原子性\"><a href=\"#原子性\" class=\"headerlink\" title=\"原子性\"></a>原子性</h4><h4 id=\"基于日志恢复（Btree）\"><a href=\"#基于日志恢复（Btree）\" class=\"headerlink\" title=\"基于日志恢复（Btree）\"></a>基于日志恢复（Btree）</h4><h4 id=\"原子自增\"><a href=\"#原子自增\" class=\"headerlink\" title=\"原子自增\"></a>原子自增</h4><h4 id=\"原子比较-设置-（compare-and-set）\"><a href=\"#原子比较-设置-（compare-and-set）\" class=\"headerlink\" title=\"原子比较-设置 （compare-and-set）\"></a>原子比较-设置 （compare-and-set）</h4><h3 id=\"多对象事务的必要性\"><a href=\"#多对象事务的必要性\" class=\"headerlink\" title=\"多对象事务的必要性\"></a>多对象事务的必要性</h3><h4 id=\"通常意义上的事务针对的是多个对象，-将多个操作聚合为一个逻辑执行单元\"><a href=\"#通常意义上的事务针对的是多个对象，-将多个操作聚合为一个逻辑执行单元\" class=\"headerlink\" title=\"通常意义上的事务针对的是多个对象， 将多个操作聚合为一个逻辑执行单元\"></a>通常意义上的事务针对的是多个对象， 将多个操作聚合为一个逻辑执行单元</h4><h4 id=\"关系数据库的外健\"><a href=\"#关系数据库的外健\" class=\"headerlink\" title=\"关系数据库的外健\"></a>关系数据库的外健</h4><h4 id=\"文档数据模型，可能更新多个文档\"><a href=\"#文档数据模型，可能更新多个文档\" class=\"headerlink\" title=\"文档数据模型，可能更新多个文档\"></a>文档数据模型，可能更新多个文档</h4><h4 id=\"图数据库的顶点和边\"><a href=\"#图数据库的顶点和边\" class=\"headerlink\" title=\"图数据库的顶点和边\"></a>图数据库的顶点和边</h4><h4 id=\"带有二级索引的数据库，-更新值时同步更新索引\"><a href=\"#带有二级索引的数据库，-更新值时同步更新索引\" class=\"headerlink\" title=\"带有二级索引的数据库， 更新值时同步更新索引\"></a>带有二级索引的数据库， 更新值时同步更新索引</h4><h3 id=\"处理错误与中止\"><a href=\"#处理错误与中止\" class=\"headerlink\" title=\"处理错误与中止\"></a>处理错误与中止</h3><h4 id=\"中止后不撤销：某些无主节点复制的数据存储，遇到错误，-不会撤销已完成的操作\"><a href=\"#中止后不撤销：某些无主节点复制的数据存储，遇到错误，-不会撤销已完成的操作\" class=\"headerlink\" title=\"中止后不撤销：某些无主节点复制的数据存储，遇到错误， 不会撤销已完成的操作\"></a>中止后不撤销：某些无主节点复制的数据存储，遇到错误， 不会撤销已完成的操作</h4><h4 id=\"中止后撤销但不重试：Rails-ActiveRecord，-Django在事务异常时简单地抛出堆栈信息，-不会重试\"><a href=\"#中止后撤销但不重试：Rails-ActiveRecord，-Django在事务异常时简单地抛出堆栈信息，-不会重试\" class=\"headerlink\" title=\"中止后撤销但不重试：Rails ActiveRecord， Django在事务异常时简单地抛出堆栈信息， 不会重试\"></a>中止后撤销但不重试：Rails ActiveRecord， Django在事务异常时简单地抛出堆栈信息， 不会重试</h4><h4 id=\"理念：支持安全的重试机制才是中止流程的重点\"><a href=\"#理念：支持安全的重试机制才是中止流程的重点\" class=\"headerlink\" title=\"理念：支持安全的重试机制才是中止流程的重点\"></a>理念：支持安全的重试机制才是中止流程的重点</h4><h4 id=\"重试的局限性\"><a href=\"#重试的局限性\" class=\"headerlink\" title=\"重试的局限性\"></a>重试的局限性</h4><h4 id=\"执行成功，但返回客户端时网络意外，-重试可能导致重复执行，-需要额外应用级重复数据删除\"><a href=\"#执行成功，但返回客户端时网络意外，-重试可能导致重复执行，-需要额外应用级重复数据删除\" class=\"headerlink\" title=\"执行成功，但返回客户端时网络意外， 重试可能导致重复执行， 需要额外应用级重复数据删除\"></a>执行成功，但返回客户端时网络意外， 重试可能导致重复执行， 需要额外应用级重复数据删除</h4><h4 id=\"设置重试次数：系统超负荷时，-一直重试会加重负担\"><a href=\"#设置重试次数：系统超负荷时，-一直重试会加重负担\" class=\"headerlink\" title=\"设置重试次数：系统超负荷时， 一直重试会加重负担\"></a>设置重试次数：系统超负荷时， 一直重试会加重负担</h4><h4 id=\"重试仅对临时性故障有意义，出现永久故障时无意义\"><a href=\"#重试仅对临时性故障有意义，出现永久故障时无意义\" class=\"headerlink\" title=\"重试仅对临时性故障有意义，出现永久故障时无意义\"></a>重试仅对临时性故障有意义，出现永久故障时无意义</h4><h4 id=\"两阶段提交，避免副作用。比如每次事务中国呢调用其它系统，发送邮件等\"><a href=\"#两阶段提交，避免副作用。比如每次事务中国呢调用其它系统，发送邮件等\" class=\"headerlink\" title=\"两阶段提交，避免副作用。比如每次事务中国呢调用其它系统，发送邮件等\"></a>两阶段提交，避免副作用。比如每次事务中国呢调用其它系统，发送邮件等</h4><h4 id=\"客户端重试时失败，-待写入数据可能丢失\"><a href=\"#客户端重试时失败，-待写入数据可能丢失\" class=\"headerlink\" title=\"客户端重试时失败， 待写入数据可能丢失\"></a>客户端重试时失败， 待写入数据可能丢失</h4><h2 id=\"事务的意义\"><a href=\"#事务的意义\" class=\"headerlink\" title=\"事务的意义\"></a>事务的意义</h2><h3 id=\"事务是一个抽象层，提供安全性保证，简化应用层的编程模型\"><a href=\"#事务是一个抽象层，提供安全性保证，简化应用层的编程模型\" class=\"headerlink\" title=\"事务是一个抽象层，提供安全性保证，简化应用层的编程模型\"></a>事务是一个抽象层，提供安全性保证，简化应用层的编程模型</h3><h3 id=\"NoSQL的兴起，很多新一代数据库完全放弃事务支持，或者替换为更弱的保证\"><a href=\"#NoSQL的兴起，很多新一代数据库完全放弃事务支持，或者替换为更弱的保证\" class=\"headerlink\" title=\"NoSQL的兴起，很多新一代数据库完全放弃事务支持，或者替换为更弱的保证\"></a>NoSQL的兴起，很多新一代数据库完全放弃事务支持，或者替换为更弱的保证</h3><h3 id=\"事务有优势，也有局限性，需要权衡\"><a href=\"#事务有优势，也有局限性，需要权衡\" class=\"headerlink\" title=\"事务有优势，也有局限性，需要权衡\"></a>事务有优势，也有局限性，需要权衡</h3><h1 id=\"弱隔离级别\"><a href=\"#弱隔离级别\" class=\"headerlink\" title=\"弱隔离级别\"></a>弱隔离级别</h1><h2 id=\"读提交\"><a href=\"#读提交\" class=\"headerlink\" title=\"读提交\"></a>读提交</h2><h3 id=\"防止脏读\"><a href=\"#防止脏读\" class=\"headerlink\" title=\"防止脏读\"></a>防止脏读</h3><h4 id=\"读数据库时，只能看到已成功提交的数据。不会看到部分更新或会被回滚的数据\"><a href=\"#读数据库时，只能看到已成功提交的数据。不会看到部分更新或会被回滚的数据\" class=\"headerlink\" title=\"读数据库时，只能看到已成功提交的数据。不会看到部分更新或会被回滚的数据\"></a>读数据库时，只能看到已成功提交的数据。不会看到部分更新或会被回滚的数据</h4><h4 id=\"实现：对于待更新对象，-维护旧值和当前持锁事务要设置的新值两个版本。事务提交前读旧值，-提交后切换到新值\"><a href=\"#实现：对于待更新对象，-维护旧值和当前持锁事务要设置的新值两个版本。事务提交前读旧值，-提交后切换到新值\" class=\"headerlink\" title=\"实现：对于待更新对象， 维护旧值和当前持锁事务要设置的新值两个版本。事务提交前读旧值， 提交后切换到新值\"></a>实现：对于待更新对象， 维护旧值和当前持锁事务要设置的新值两个版本。事务提交前读旧值， 提交后切换到新值</h4><h3 id=\"防止脏写\"><a href=\"#防止脏写\" class=\"headerlink\" title=\"防止脏写\"></a>防止脏写</h3><h4 id=\"写数据库时，只会覆盖已成功提交的数据。避免不同事务的写入混杂\"><a href=\"#写数据库时，只会覆盖已成功提交的数据。避免不同事务的写入混杂\" class=\"headerlink\" title=\"写数据库时，只会覆盖已成功提交的数据。避免不同事务的写入混杂\"></a>写数据库时，只会覆盖已成功提交的数据。避免不同事务的写入混杂</h4><h4 id=\"实现：-行级锁。数据库自动完成\"><a href=\"#实现：-行级锁。数据库自动完成\" class=\"headerlink\" title=\"实现： 行级锁。数据库自动完成\"></a>实现： 行级锁。数据库自动完成</h4><h3 id=\"不可重复读-读倾斜-时间异常\"><a href=\"#不可重复读-读倾斜-时间异常\" class=\"headerlink\" title=\"不可重复读/读倾斜(时间异常)\"></a>不可重复读/读倾斜(时间异常)</h3><h4 id=\"备份场景\"><a href=\"#备份场景\" class=\"headerlink\" title=\"备份场景\"></a>备份场景</h4><h4 id=\"分析查询和完整性检查场景\"><a href=\"#分析查询和完整性检查场景\" class=\"headerlink\" title=\"分析查询和完整性检查场景\"></a>分析查询和完整性检查场景</h4><h4 id=\"有些场景不能容忍这种暂时的不一致状态\"><a href=\"#有些场景不能容忍这种暂时的不一致状态\" class=\"headerlink\" title=\"有些场景不能容忍这种暂时的不一致状态\"></a>有些场景不能容忍这种暂时的不一致状态</h4><h2 id=\"快照级别隔离与重复读\"><a href=\"#快照级别隔离与重复读\" class=\"headerlink\" title=\"快照级别隔离与重复读\"></a>快照级别隔离与重复读</h2><h3 id=\"实现快照级别隔离\"><a href=\"#实现快照级别隔离\" class=\"headerlink\" title=\"实现快照级别隔离\"></a>实现快照级别隔离</h3><h4 id=\"MVCC\"><a href=\"#MVCC\" class=\"headerlink\" title=\"MVCC\"></a>MVCC</h4><h3 id=\"一致性快照的可见性原则\"><a href=\"#一致性快照的可见性原则\" class=\"headerlink\" title=\"一致性快照的可见性原则\"></a>一致性快照的可见性原则</h3><h4 id=\"1-进行中的其它事务，不可见\"><a href=\"#1-进行中的其它事务，不可见\" class=\"headerlink\" title=\"1. 进行中的其它事务，不可见\"></a>1. 进行中的其它事务，不可见</h4><h4 id=\"2-所有中止事务所做的修改，不可见\"><a href=\"#2-所有中止事务所做的修改，不可见\" class=\"headerlink\" title=\"2. 所有中止事务所做的修改，不可见\"></a>2. 所有中止事务所做的修改，不可见</h4><h4 id=\"3-较晚事务ID所做任何修改，-无论是否提交，不可见\"><a href=\"#3-较晚事务ID所做任何修改，-无论是否提交，不可见\" class=\"headerlink\" title=\"3. 较晚事务ID所做任何修改， 无论是否提交，不可见\"></a>3. 较晚事务ID所做任何修改， 无论是否提交，不可见</h4><h4 id=\"4-除上述之外的所有写入都对应用查询可见\"><a href=\"#4-除上述之外的所有写入都对应用查询可见\" class=\"headerlink\" title=\"4. 除上述之外的所有写入都对应用查询可见\"></a>4. 除上述之外的所有写入都对应用查询可见</h4><h4 id=\"4-1-事务开始时，-创建该对象的事务已经完成提交\"><a href=\"#4-1-事务开始时，-创建该对象的事务已经完成提交\" class=\"headerlink\" title=\"4.1 事务开始时， 创建该对象的事务已经完成提交\"></a>4.1 事务开始时， 创建该对象的事务已经完成提交</h4><h4 id=\"4-2-对象没有标记为删除，或者标记了，但删除事务在当前事务开始前未完成提交\"><a href=\"#4-2-对象没有标记为删除，或者标记了，但删除事务在当前事务开始前未完成提交\" class=\"headerlink\" title=\"4.2 对象没有标记为删除，或者标记了，但删除事务在当前事务开始前未完成提交\"></a>4.2 对象没有标记为删除，或者标记了，但删除事务在当前事务开始前未完成提交</h4><h3 id=\"快照级别隔离如何支持索引\"><a href=\"#快照级别隔离如何支持索引\" class=\"headerlink\" title=\"快照级别隔离如何支持索引\"></a>快照级别隔离如何支持索引</h3><h4 id=\"方案1-PostgreSQL将同对象的不同版本放在一个内存页面上-：-索引指向对象的所有版本，-过滤当前事务不可见的那些版本。后台垃圾回收进程删除旧对象版本时，同时删除对应索引\"><a href=\"#方案1-PostgreSQL将同对象的不同版本放在一个内存页面上-：-索引指向对象的所有版本，-过滤当前事务不可见的那些版本。后台垃圾回收进程删除旧对象版本时，同时删除对应索引\" class=\"headerlink\" title=\"方案1(PostgreSQL将同对象的不同版本放在一个内存页面上)： 索引指向对象的所有版本， 过滤当前事务不可见的那些版本。后台垃圾回收进程删除旧对象版本时，同时删除对应索引\"></a>方案1(PostgreSQL将同对象的不同版本放在一个内存页面上)： 索引指向对象的所有版本， 过滤当前事务不可见的那些版本。后台垃圾回收进程删除旧对象版本时，同时删除对应索引</h4><h4 id=\"方案2（CouchDB-Datomic-LMDB）：-B-tree，追加-写时复制。更新时，每个写入事务创建新的B-tree-root-代表该时刻数据库的一致性快照\"><a href=\"#方案2（CouchDB-Datomic-LMDB）：-B-tree，追加-写时复制。更新时，每个写入事务创建新的B-tree-root-代表该时刻数据库的一致性快照\" class=\"headerlink\" title=\"方案2（CouchDB,Datomic,LMDB）： B-tree，追加/写时复制。更新时，每个写入事务创建新的B-tree root,代表该时刻数据库的一致性快照\"></a>方案2（CouchDB,Datomic,LMDB）： B-tree，追加/写时复制。更新时，每个写入事务创建新的B-tree root,代表该时刻数据库的一致性快照</h4><h3 id=\"可重复读与命名混淆\"><a href=\"#可重复读与命名混淆\" class=\"headerlink\" title=\"可重复读与命名混淆\"></a>可重复读与命名混淆</h3><h4 id=\"命名混淆：快照隔离技术，-Oracle称为可串行化，-PostgreSQL和MySQL称为可重复读\"><a href=\"#命名混淆：快照隔离技术，-Oracle称为可串行化，-PostgreSQL和MySQL称为可重复读\" class=\"headerlink\" title=\"命名混淆：快照隔离技术， Oracle称为可串行化， PostgreSQL和MySQL称为可重复读\"></a>命名混淆：快照隔离技术， Oracle称为可串行化， PostgreSQL和MySQL称为可重复读</h4><h4 id=\"原因：-SQL标准只定义了可重复读，-未定义快照级别隔离\"><a href=\"#原因：-SQL标准只定义了可重复读，-未定义快照级别隔离\" class=\"headerlink\" title=\"原因： SQL标准只定义了可重复读， 未定义快照级别隔离\"></a>原因： SQL标准只定义了可重复读， 未定义快照级别隔离</h4><h2 id=\"防止更新丢失（写事务并发）\"><a href=\"#防止更新丢失（写事务并发）\" class=\"headerlink\" title=\"防止更新丢失（写事务并发）\"></a>防止更新丢失（写事务并发）</h2><h3 id=\"原子写操作（数据库）\"><a href=\"#原子写操作（数据库）\" class=\"headerlink\" title=\"原子写操作（数据库）\"></a>原子写操作（数据库）</h3><h4 id=\"许多数据库提供了原子更新操作-eg-update-counters-set-value-value-1-where-key-39-foo-39\"><a href=\"#许多数据库提供了原子更新操作-eg-update-counters-set-value-value-1-where-key-39-foo-39\" class=\"headerlink\" title=\"许多数据库提供了原子更新操作 eg: update counters set value = value + 1 where key = &#39;foo&#39;;\"></a>许多数据库提供了原子更新操作 eg: update counters set value = value + 1 where key = &#39;foo&#39;;</h4><h4 id=\"实现1：-对读取对象加独占锁，更新提交前不会有其它事务可读它（游标稳定性）\"><a href=\"#实现1：-对读取对象加独占锁，更新提交前不会有其它事务可读它（游标稳定性）\" class=\"headerlink\" title=\"实现1： 对读取对象加独占锁，更新提交前不会有其它事务可读它（游标稳定性）\"></a>实现1： 对读取对象加独占锁，更新提交前不会有其它事务可读它（游标稳定性）</h4><h4 id=\"实现2：-强制所有的原子操作都在单线程上执行\"><a href=\"#实现2：-强制所有的原子操作都在单线程上执行\" class=\"headerlink\" title=\"实现2： 强制所有的原子操作都在单线程上执行\"></a>实现2： 强制所有的原子操作都在单线程上执行</h4><h3 id=\"显式加锁（应用层）\"><a href=\"#显式加锁（应用层）\" class=\"headerlink\" title=\"显式加锁（应用层）\"></a>显式加锁（应用层）</h3><h4 id=\"应用程序显式锁定待更新的对象，然后执行-quot-读-修改-写回-quot\"><a href=\"#应用程序显式锁定待更新的对象，然后执行-quot-读-修改-写回-quot\" class=\"headerlink\" title=\"应用程序显式锁定待更新的对象，然后执行&quot;读-修改-写回&quot;\"></a>应用程序显式锁定待更新的对象，然后执行&quot;读-修改-写回&quot;</h4><h3 id=\"自动检测更新丢失（借助快照级别隔离来高效执行）\"><a href=\"#自动检测更新丢失（借助快照级别隔离来高效执行）\" class=\"headerlink\" title=\"自动检测更新丢失（借助快照级别隔离来高效执行）\"></a>自动检测更新丢失（借助快照级别隔离来高效执行）</h3><h4 id=\"原子操作和锁都是强制-quot-读-修改-写回-quot-操作序列串行执行\"><a href=\"#原子操作和锁都是强制-quot-读-修改-写回-quot-操作序列串行执行\" class=\"headerlink\" title=\"原子操作和锁都是强制&quot;读-修改-写回&quot;操作序列串行执行\"></a>原子操作和锁都是强制&quot;读-修改-写回&quot;操作序列串行执行</h4><h4 id=\"换个思路：-先让他们并发执行，-如果事务管理器检测到了更新丢失风险，-中止当前事务，-强制回退到安全的-quot-读-修改-写回-quot\"><a href=\"#换个思路：-先让他们并发执行，-如果事务管理器检测到了更新丢失风险，-中止当前事务，-强制回退到安全的-quot-读-修改-写回-quot\" class=\"headerlink\" title=\"换个思路： 先让他们并发执行， 如果事务管理器检测到了更新丢失风险， 中止当前事务， 强制回退到安全的&quot;读-修改-写回&quot;\"></a>换个思路： 先让他们并发执行， 如果事务管理器检测到了更新丢失风险， 中止当前事务， 强制回退到安全的&quot;读-修改-写回&quot;</h4><h4 id=\"PostgreSQL的可重复读，-Oracle的可串行化，SQL-Server的快照级别隔离都支持\"><a href=\"#PostgreSQL的可重复读，-Oracle的可串行化，SQL-Server的快照级别隔离都支持\" class=\"headerlink\" title=\"PostgreSQL的可重复读， Oracle的可串行化，SQL Server的快照级别隔离都支持\"></a>PostgreSQL的可重复读， Oracle的可串行化，SQL Server的快照级别隔离都支持</h4><h4 id=\"MySQL-InnoDB的可重复读不支持\"><a href=\"#MySQL-InnoDB的可重复读不支持\" class=\"headerlink\" title=\"MySQL InnoDB的可重复读不支持\"></a>MySQL InnoDB的可重复读不支持</h4><h3 id=\"原子比较和设置（无事务支持）\"><a href=\"#原子比较和设置（无事务支持）\" class=\"headerlink\" title=\"原子比较和设置（无事务支持）\"></a>原子比较和设置（无事务支持）</h3><h4 id=\"先执行CAS，如果不成功则回退到-quot-读-修改-写回-quot\"><a href=\"#先执行CAS，如果不成功则回退到-quot-读-修改-写回-quot\" class=\"headerlink\" title=\"先执行CAS，如果不成功则回退到&quot;读-修改-写回&quot;\"></a>先执行CAS，如果不成功则回退到&quot;读-修改-写回&quot;</h4><h4 id=\"注意：-如果where语句运行在旧快照上，可能无法防止另一个并发写入。所以要仔细检查CAS操作的安全运行条件\"><a href=\"#注意：-如果where语句运行在旧快照上，可能无法防止另一个并发写入。所以要仔细检查CAS操作的安全运行条件\" class=\"headerlink\" title=\"注意： 如果where语句运行在旧快照上，可能无法防止另一个并发写入。所以要仔细检查CAS操作的安全运行条件\"></a>注意： 如果where语句运行在旧快照上，可能无法防止另一个并发写入。所以要仔细检查CAS操作的安全运行条件</h4><h3 id=\"冲突解决与复制（多副本）\"><a href=\"#冲突解决与复制（多副本）\" class=\"headerlink\" title=\"冲突解决与复制（多副本）\"></a>冲突解决与复制（多副本）</h3><h4 id=\"保留多个冲突版本，由应用层逻辑或依靠特定的数据结构来解决\"><a href=\"#保留多个冲突版本，由应用层逻辑或依靠特定的数据结构来解决\" class=\"headerlink\" title=\"保留多个冲突版本，由应用层逻辑或依靠特定的数据结构来解决\"></a>保留多个冲突版本，由应用层逻辑或依靠特定的数据结构来解决</h4><h4 id=\"如果操作顺序无关，则原子操作可行\"><a href=\"#如果操作顺序无关，则原子操作可行\" class=\"headerlink\" title=\"如果操作顺序无关，则原子操作可行\"></a>如果操作顺序无关，则原子操作可行</h4><h4 id=\"LWW，容易丢失更新，但是目前许多多副本数据库的默认配置\"><a href=\"#LWW，容易丢失更新，但是目前许多多副本数据库的默认配置\" class=\"headerlink\" title=\"LWW，容易丢失更新，但是目前许多多副本数据库的默认配置\"></a>LWW，容易丢失更新，但是目前许多多副本数据库的默认配置</h4><h2 id=\"写倾斜与幻读\"><a href=\"#写倾斜与幻读\" class=\"headerlink\" title=\"写倾斜与幻读\"></a>写倾斜与幻读</h2><h3 id=\"定义写倾斜-幻读\"><a href=\"#定义写倾斜-幻读\" class=\"headerlink\" title=\"定义写倾斜/幻读\"></a>定义写倾斜/幻读</h3><h4 id=\"一个事务的写入改变了另一个事务查询结果\"><a href=\"#一个事务的写入改变了另一个事务查询结果\" class=\"headerlink\" title=\"一个事务的写入改变了另一个事务查询结果\"></a>一个事务的写入改变了另一个事务查询结果</h4><h4 id=\"更新丢失问题。如果两个事务读取相同的一组对象，然后更新其中一部分\"><a href=\"#更新丢失问题。如果两个事务读取相同的一组对象，然后更新其中一部分\" class=\"headerlink\" title=\"更新丢失问题。如果两个事务读取相同的一组对象，然后更新其中一部分\"></a>更新丢失问题。如果两个事务读取相同的一组对象，然后更新其中一部分</h4><h4 id=\"写倾斜：不同的事务可能更新不同的对象\"><a href=\"#写倾斜：不同的事务可能更新不同的对象\" class=\"headerlink\" title=\"写倾斜：不同的事务可能更新不同的对象\"></a>写倾斜：不同的事务可能更新不同的对象</h4><h4 id=\"脏写、更新丢失：-不同的事务更新的是同一个对象\"><a href=\"#脏写、更新丢失：-不同的事务更新的是同一个对象\" class=\"headerlink\" title=\"脏写、更新丢失： 不同的事务更新的是同一个对象\"></a>脏写、更新丢失： 不同的事务更新的是同一个对象</h4><h4 id=\"之前可选方案的可行性\"><a href=\"#之前可选方案的可行性\" class=\"headerlink\" title=\"之前可选方案的可行性\"></a>之前可选方案的可行性</h4><h4 id=\"原子操作，不可行，因为涉及到多个对象\"><a href=\"#原子操作，不可行，因为涉及到多个对象\" class=\"headerlink\" title=\"原子操作，不可行，因为涉及到多个对象\"></a>原子操作，不可行，因为涉及到多个对象</h4><h4 id=\"定义数据库约束条件，然后数据库代为检查、执行约束，-不可行，-大多数场景的类型约束数据库不支持\"><a href=\"#定义数据库约束条件，然后数据库代为检查、执行约束，-不可行，-大多数场景的类型约束数据库不支持\" class=\"headerlink\" title=\"定义数据库约束条件，然后数据库代为检查、执行约束， 不可行， 大多数场景的类型约束数据库不支持\"></a>定义数据库约束条件，然后数据库代为检查、执行约束， 不可行， 大多数场景的类型约束数据库不支持</h4><h4 id=\"自动检测更新丢失，不可行，目前都不支持自动检测写倾斜（需要真正的可串行化隔离）\"><a href=\"#自动检测更新丢失，不可行，目前都不支持自动检测写倾斜（需要真正的可串行化隔离）\" class=\"headerlink\" title=\"自动检测更新丢失，不可行，目前都不支持自动检测写倾斜（需要真正的可串行化隔离）\"></a>自动检测更新丢失，不可行，目前都不支持自动检测写倾斜（需要真正的可串行化隔离）</h4><h4 id=\"对事务依赖的行来显式加锁，可行，-FOR-UPDATE\"><a href=\"#对事务依赖的行来显式加锁，可行，-FOR-UPDATE\" class=\"headerlink\" title=\"对事务依赖的行来显式加锁，可行， FOR UPDATE\"></a>对事务依赖的行来显式加锁，可行， FOR UPDATE</h4><h3 id=\"更多写倾斜的案例\"><a href=\"#更多写倾斜的案例\" class=\"headerlink\" title=\"更多写倾斜的案例\"></a>更多写倾斜的案例</h3><h3 id=\"为何产生写倾斜\"><a href=\"#为何产生写倾斜\" class=\"headerlink\" title=\"为何产生写倾斜\"></a>为何产生写倾斜</h3><h3 id=\"实体化冲突\"><a href=\"#实体化冲突\" class=\"headerlink\" title=\"实体化冲突\"></a>实体化冲突</h3><h4 id=\"把幻读问题-转变为-针对数据库中一组具体行的锁冲突问题\"><a href=\"#把幻读问题-转变为-针对数据库中一组具体行的锁冲突问题\" class=\"headerlink\" title=\"把幻读问题 转变为 针对数据库中一组具体行的锁冲突问题\"></a>把幻读问题 转变为 针对数据库中一组具体行的锁冲突问题</h4><h4 id=\"并发控制机制-降级为-数据模型\"><a href=\"#并发控制机制-降级为-数据模型\" class=\"headerlink\" title=\"并发控制机制 降级为 数据模型\"></a>并发控制机制 降级为 数据模型</h4><h1 id=\"串行化\"><a href=\"#串行化\" class=\"headerlink\" title=\"串行化\"></a>串行化</h1><h2 id=\"实际串行执行\"><a href=\"#实际串行执行\" class=\"headerlink\" title=\"实际串行执行\"></a>实际串行执行</h2><h3 id=\"采用存储过程封装事务\"><a href=\"#采用存储过程封装事务\" class=\"headerlink\" title=\"采用存储过程封装事务\"></a>采用存储过程封装事务</h3><h4 id=\"避免等待IO（用户交互，应用程序与数据库间多次网络通信）\"><a href=\"#避免等待IO（用户交互，应用程序与数据库间多次网络通信）\" class=\"headerlink\" title=\"避免等待IO（用户交互，应用程序与数据库间多次网络通信）\"></a>避免等待IO（用户交互，应用程序与数据库间多次网络通信）</h4><h3 id=\"存储过程的优缺点\"><a href=\"#存储过程的优缺点\" class=\"headerlink\" title=\"存储过程的优缺点\"></a>存储过程的优缺点</h3><h4 id=\"数据库厂商的存储过程语言大多语义丑陋，过时（最新的存储过程使用现有通用语言：-VoltDB使用Java或Groovy-Datomic使用Java或Clojure，Redis使用Lua）\"><a href=\"#数据库厂商的存储过程语言大多语义丑陋，过时（最新的存储过程使用现有通用语言：-VoltDB使用Java或Groovy-Datomic使用Java或Clojure，Redis使用Lua）\" class=\"headerlink\" title=\"数据库厂商的存储过程语言大多语义丑陋，过时（最新的存储过程使用现有通用语言： VoltDB使用Java或Groovy,Datomic使用Java或Clojure，Redis使用Lua）\"></a>数据库厂商的存储过程语言大多语义丑陋，过时（最新的存储过程使用现有通用语言： VoltDB使用Java或Groovy,Datomic使用Java或Clojure，Redis使用Lua）</h4><h4 id=\"数据库中运行代码难以管理（调试，版本控制，部署，测试，监控）\"><a href=\"#数据库中运行代码难以管理（调试，版本控制，部署，测试，监控）\" class=\"headerlink\" title=\"数据库中运行代码难以管理（调试，版本控制，部署，测试，监控）\"></a>数据库中运行代码难以管理（调试，版本控制，部署，测试，监控）</h4><h4 id=\"设计不好，所有应用程序都受影响\"><a href=\"#设计不好，所有应用程序都受影响\" class=\"headerlink\" title=\"设计不好，所有应用程序都受影响\"></a>设计不好，所有应用程序都受影响</h4><h3 id=\"分区\"><a href=\"#分区\" class=\"headerlink\" title=\"分区\"></a>分区</h3><h4 id=\"高写入需求下，单线程事务处理容易成为瓶颈\"><a href=\"#高写入需求下，单线程事务处理容易成为瓶颈\" class=\"headerlink\" title=\"高写入需求下，单线程事务处理容易成为瓶颈\"></a>高写入需求下，单线程事务处理容易成为瓶颈</h4><h4 id=\"分区，扩展到多个CPU核和多节点\"><a href=\"#分区，扩展到多个CPU核和多节点\" class=\"headerlink\" title=\"分区，扩展到多个CPU核和多节点\"></a>分区，扩展到多个CPU核和多节点</h4><h4 id=\"跨分区事务由额外的协调开销，所以适合大量键值数据，不适合带有多个二级索引的数据\"><a href=\"#跨分区事务由额外的协调开销，所以适合大量键值数据，不适合带有多个二级索引的数据\" class=\"headerlink\" title=\"跨分区事务由额外的协调开销，所以适合大量键值数据，不适合带有多个二级索引的数据\"></a>跨分区事务由额外的协调开销，所以适合大量键值数据，不适合带有多个二级索引的数据</h4><h3 id=\"串行执行小结\"><a href=\"#串行执行小结\" class=\"headerlink\" title=\"串行执行小结\"></a>串行执行小结</h3><h3 id=\"为什么现在能实现，为什么以前都要靠多线程并发来提升性能\"><a href=\"#为什么现在能实现，为什么以前都要靠多线程并发来提升性能\" class=\"headerlink\" title=\"为什么现在能实现，为什么以前都要靠多线程并发来提升性能\"></a>为什么现在能实现，为什么以前都要靠多线程并发来提升性能</h3><h4 id=\"内存越来越便宜，-事务所需数据都可加载到内存中\"><a href=\"#内存越来越便宜，-事务所需数据都可加载到内存中\" class=\"headerlink\" title=\"内存越来越便宜， 事务所需数据都可加载到内存中\"></a>内存越来越便宜， 事务所需数据都可加载到内存中</h4><h4 id=\"OLTP事务通常执行很快\"><a href=\"#OLTP事务通常执行很快\" class=\"headerlink\" title=\"OLTP事务通常执行很快\"></a>OLTP事务通常执行很快</h4><h4 id=\"Redis-VoltDB-H-store-Datomic等采用串行，-避免锁开销，-吞吐量上限为单个CPU核的吞吐量\"><a href=\"#Redis-VoltDB-H-store-Datomic等采用串行，-避免锁开销，-吞吐量上限为单个CPU核的吞吐量\" class=\"headerlink\" title=\"Redis, VoltDB/H-store, Datomic等采用串行， 避免锁开销， 吞吐量上限为单个CPU核的吞吐量\"></a>Redis, VoltDB/H-store, Datomic等采用串行， 避免锁开销， 吞吐量上限为单个CPU核的吞吐量</h4><h2 id=\"两阶段加锁（two-phase-locking-2PL）\"><a href=\"#两阶段加锁（two-phase-locking-2PL）\" class=\"headerlink\" title=\"两阶段加锁（two-phase locking, 2PL）\"></a>两阶段加锁（two-phase locking, 2PL）</h2><h3 id=\"实现2PL\"><a href=\"#实现2PL\" class=\"headerlink\" title=\"实现2PL\"></a>实现2PL</h3><h4 id=\"多个事务可以同时读取同一对象，但只要出现任何写操作，则必须加锁以独占访问（读写也会互斥）\"><a href=\"#多个事务可以同时读取同一对象，但只要出现任何写操作，则必须加锁以独占访问（读写也会互斥）\" class=\"headerlink\" title=\"多个事务可以同时读取同一对象，但只要出现任何写操作，则必须加锁以独占访问（读写也会互斥）\"></a>多个事务可以同时读取同一对象，但只要出现任何写操作，则必须加锁以独占访问（读写也会互斥）</h4><h4 id=\"1-每个对象都有一个读写锁来隔离读写操作\"><a href=\"#1-每个对象都有一个读写锁来隔离读写操作\" class=\"headerlink\" title=\"1. 每个对象都有一个读写锁来隔离读写操作\"></a>1. 每个对象都有一个读写锁来隔离读写操作</h4><h4 id=\"2-事务要读取对象，必须先获得读锁，可以有多个事务同时获得一个对象的读锁\"><a href=\"#2-事务要读取对象，必须先获得读锁，可以有多个事务同时获得一个对象的读锁\" class=\"headerlink\" title=\"2. 事务要读取对象，必须先获得读锁，可以有多个事务同时获得一个对象的读锁\"></a>2. 事务要读取对象，必须先获得读锁，可以有多个事务同时获得一个对象的读锁</h4><h4 id=\"3-如果某个事务已经获得对象的写锁，-其它事务必须等待\"><a href=\"#3-如果某个事务已经获得对象的写锁，-其它事务必须等待\" class=\"headerlink\" title=\"3. 如果某个事务已经获得对象的写锁， 其它事务必须等待\"></a>3. 如果某个事务已经获得对象的写锁， 其它事务必须等待</h4><h4 id=\"5-如果事务先读取，然后尝试写入，必须先把读锁升级为写锁\"><a href=\"#5-如果事务先读取，然后尝试写入，必须先把读锁升级为写锁\" class=\"headerlink\" title=\"5. 如果事务先读取，然后尝试写入，必须先把读锁升级为写锁\"></a>5. 如果事务先读取，然后尝试写入，必须先把读锁升级为写锁</h4><h4 id=\"4-事务要修改对象，-必须先获取写锁，如果已被加写锁，必须等待\"><a href=\"#4-事务要修改对象，-必须先获取写锁，如果已被加写锁，必须等待\" class=\"headerlink\" title=\"4. 事务要修改对象， 必须先获取写锁，如果已被加写锁，必须等待\"></a>4. 事务要修改对象， 必须先获取写锁，如果已被加写锁，必须等待</h4><h4 id=\"6-事务获得锁后，-一直持有到事务结束。第一阶段即事务执行之前要获取锁，第二阶段即事务结束时要释放锁。\"><a href=\"#6-事务获得锁后，-一直持有到事务结束。第一阶段即事务执行之前要获取锁，第二阶段即事务结束时要释放锁。\" class=\"headerlink\" title=\"6. 事务获得锁后， 一直持有到事务结束。第一阶段即事务执行之前要获取锁，第二阶段即事务结束时要释放锁。\"></a>6. 事务获得锁后， 一直持有到事务结束。第一阶段即事务执行之前要获取锁，第二阶段即事务结束时要释放锁。</h4><h4 id=\"容易死锁，数据库自动检测死锁，-强行中止其中一个\"><a href=\"#容易死锁，数据库自动检测死锁，-强行中止其中一个\" class=\"headerlink\" title=\"容易死锁，数据库自动检测死锁， 强行中止其中一个\"></a>容易死锁，数据库自动检测死锁， 强行中止其中一个</h4><h3 id=\"2PL的性能\"><a href=\"#2PL的性能\" class=\"headerlink\" title=\"2PL的性能\"></a>2PL的性能</h3><h4 id=\"锁的获取和释放本身开销\"><a href=\"#锁的获取和释放本身开销\" class=\"headerlink\" title=\"锁的获取和释放本身开销\"></a>锁的获取和释放本身开销</h4><h4 id=\"数据库访问延迟具有非常大的不确定性\"><a href=\"#数据库访问延迟具有非常大的不确定性\" class=\"headerlink\" title=\"数据库访问延迟具有非常大的不确定性\"></a>数据库访问延迟具有非常大的不确定性</h4><h4 id=\"降低了事务的并发性\"><a href=\"#降低了事务的并发性\" class=\"headerlink\" title=\"降低了事务的并发性\"></a>降低了事务的并发性</h4><h4 id=\"死锁更为频繁，如果由于死锁而被强行中止，应用层必须从头重试\"><a href=\"#死锁更为频繁，如果由于死锁而被强行中止，应用层必须从头重试\" class=\"headerlink\" title=\"死锁更为频繁，如果由于死锁而被强行中止，应用层必须从头重试\"></a>死锁更为频繁，如果由于死锁而被强行中止，应用层必须从头重试</h4><h3 id=\"谓词锁\"><a href=\"#谓词锁\" class=\"headerlink\" title=\"谓词锁\"></a>谓词锁</h3><h4 id=\"可串行化隔离也要防止幻读问题\"><a href=\"#可串行化隔离也要防止幻读问题\" class=\"headerlink\" title=\"可串行化隔离也要防止幻读问题\"></a>可串行化隔离也要防止幻读问题</h4><h4 id=\"作用于某些搜索条件的所有查询对象\"><a href=\"#作用于某些搜索条件的所有查询对象\" class=\"headerlink\" title=\"作用于某些搜索条件的所有查询对象\"></a>作用于某些搜索条件的所有查询对象</h4><h4 id=\"谓词锁可以保护那些上不存在但可能马上会被插入的对象\"><a href=\"#谓词锁可以保护那些上不存在但可能马上会被插入的对象\" class=\"headerlink\" title=\"谓词锁可以保护那些上不存在但可能马上会被插入的对象\"></a>谓词锁可以保护那些上不存在但可能马上会被插入的对象</h4><h4 id=\"两阶段加锁-谓词锁，可以防止所有竞争条件，隔离变得真正可串行化\"><a href=\"#两阶段加锁-谓词锁，可以防止所有竞争条件，隔离变得真正可串行化\" class=\"headerlink\" title=\"两阶段加锁+谓词锁，可以防止所有竞争条件，隔离变得真正可串行化\"></a>两阶段加锁+谓词锁，可以防止所有竞争条件，隔离变得真正可串行化</h4><h3 id=\"索引区间锁\"><a href=\"#索引区间锁\" class=\"headerlink\" title=\"索引区间锁\"></a>索引区间锁</h3><h4 id=\"对谓词锁的简化，因为谓词锁性能不佳\"><a href=\"#对谓词锁的简化，因为谓词锁性能不佳\" class=\"headerlink\" title=\"对谓词锁的简化，因为谓词锁性能不佳\"></a>对谓词锁的简化，因为谓词锁性能不佳</h4><h4 id=\"将保护的对象扩大化，不像谓词锁那么精确，但是开销低\"><a href=\"#将保护的对象扩大化，不像谓词锁那么精确，但是开销低\" class=\"headerlink\" title=\"将保护的对象扩大化，不像谓词锁那么精确，但是开销低\"></a>将保护的对象扩大化，不像谓词锁那么精确，但是开销低</h4><h4 id=\"如果没有合适的索引，可以回退到对整个表施加共享锁\"><a href=\"#如果没有合适的索引，可以回退到对整个表施加共享锁\" class=\"headerlink\" title=\"如果没有合适的索引，可以回退到对整个表施加共享锁\"></a>如果没有合适的索引，可以回退到对整个表施加共享锁</h4><h2 id=\"可串行化的快照隔离（SSI）\"><a href=\"#可串行化的快照隔离（SSI）\" class=\"headerlink\" title=\"可串行化的快照隔离（SSI）\"></a>可串行化的快照隔离（SSI）</h2><h3 id=\"悲观与乐观的并发控制\"><a href=\"#悲观与乐观的并发控制\" class=\"headerlink\" title=\"悲观与乐观的并发控制\"></a>悲观与乐观的并发控制</h3><h4 id=\"2PL是悲观并发控制机制\"><a href=\"#2PL是悲观并发控制机制\" class=\"headerlink\" title=\"2PL是悲观并发控制机制\"></a>2PL是悲观并发控制机制</h4><h4 id=\"SSI是乐观并发控制：-如果可能发生潜在冲突，事务继续执行而不中止；事务提交时检查是否冲突，是的话再中止并重试。\"><a href=\"#SSI是乐观并发控制：-如果可能发生潜在冲突，事务继续执行而不中止；事务提交时检查是否冲突，是的话再中止并重试。\" class=\"headerlink\" title=\"SSI是乐观并发控制： 如果可能发生潜在冲突，事务继续执行而不中止；事务提交时检查是否冲突，是的话再中止并重试。\"></a>SSI是乐观并发控制： 如果可能发生潜在冲突，事务继续执行而不中止；事务提交时检查是否冲突，是的话再中止并重试。</h4><h4 id=\"缺点：-如果冲突很多，则性能不佳；-如果系统已接近最大吞吐量，反复重试会使情况更糟\"><a href=\"#缺点：-如果冲突很多，则性能不佳；-如果系统已接近最大吞吐量，反复重试会使情况更糟\" class=\"headerlink\" title=\"缺点： 如果冲突很多，则性能不佳； 如果系统已接近最大吞吐量，反复重试会使情况更糟\"></a>缺点： 如果冲突很多，则性能不佳； 如果系统已接近最大吞吐量，反复重试会使情况更糟</h4><h4 id=\"优点：-如果系统有足够的性能提升空间，且事务竞争不大，-乐观并发控制会高效很多\"><a href=\"#优点：-如果系统有足够的性能提升空间，且事务竞争不大，-乐观并发控制会高效很多\" class=\"headerlink\" title=\"优点： 如果系统有足够的性能提升空间，且事务竞争不大， 乐观并发控制会高效很多\"></a>优点： 如果系统有足够的性能提升空间，且事务竞争不大， 乐观并发控制会高效很多</h4><h3 id=\"基于过期的条件做决定\"><a href=\"#基于过期的条件做决定\" class=\"headerlink\" title=\"基于过期的条件做决定\"></a>基于过期的条件做决定</h3><h4 id=\"数据库必须检测事务是否会修改其他事务的查询结果\"><a href=\"#数据库必须检测事务是否会修改其他事务的查询结果\" class=\"headerlink\" title=\"数据库必须检测事务是否会修改其他事务的查询结果\"></a>数据库必须检测事务是否会修改其他事务的查询结果</h4><h4 id=\"1-检测是否读取了（即将）过期的MVCC对象，即读取前已经有未提交的写入\"><a href=\"#1-检测是否读取了（即将）过期的MVCC对象，即读取前已经有未提交的写入\" class=\"headerlink\" title=\"1. 检测是否读取了（即将）过期的MVCC对象，即读取前已经有未提交的写入\"></a>1. 检测是否读取了（即将）过期的MVCC对象，即读取前已经有未提交的写入</h4><h4 id=\"2-检测写是否影响了之前的读，即读取后，又有新的写入\"><a href=\"#2-检测写是否影响了之前的读，即读取后，又有新的写入\" class=\"headerlink\" title=\"2.检测写是否影响了之前的读，即读取后，又有新的写入\"></a>2.检测写是否影响了之前的读，即读取后，又有新的写入</h4><h3 id=\"可串行化快照隔离的性能\"><a href=\"#可串行化快照隔离的性能\" class=\"headerlink\" title=\"可串行化快照隔离的性能\"></a>可串行化快照隔离的性能</h3><h4 id=\"优点：事务不需要等待其它事务所持有的锁，只读查询不需要任何锁\"><a href=\"#优点：事务不需要等待其它事务所持有的锁，只读查询不需要任何锁\" class=\"headerlink\" title=\"优点：事务不需要等待其它事务所持有的锁，只读查询不需要任何锁\"></a>优点：事务不需要等待其它事务所持有的锁，只读查询不需要任何锁</h4><h4 id=\"可以突破单个CPU核的限制，FoundationDB将冲突检测分区，事务分区\"><a href=\"#可以突破单个CPU核的限制，FoundationDB将冲突检测分区，事务分区\" class=\"headerlink\" title=\"可以突破单个CPU核的限制，FoundationDB将冲突检测分区，事务分区\"></a>可以突破单个CPU核的限制，FoundationDB将冲突检测分区，事务分区</h4><h4 id=\"事务中止的比例会显著影响SSI的性能表现\"><a href=\"#事务中止的比例会显著影响SSI的性能表现\" class=\"headerlink\" title=\"事务中止的比例会显著影响SSI的性能表现\"></a>事务中止的比例会显著影响SSI的性能表现</h4><h1 id=\"边界条件小结\"><a href=\"#边界条件小结\" class=\"headerlink\" title=\"边界条件小结\"></a>边界条件小结</h1><h2 id=\"脏读\"><a href=\"#脏读\" class=\"headerlink\" title=\"脏读\"></a>脏读</h2><h2 id=\"脏写\"><a href=\"#脏写\" class=\"headerlink\" title=\"脏写\"></a>脏写</h2><h2 id=\"读倾斜（不可重复读）\"><a href=\"#读倾斜（不可重复读）\" class=\"headerlink\" title=\"读倾斜（不可重复读）\"></a>读倾斜（不可重复读）</h2><h2 id=\"更新丢失\"><a href=\"#更新丢失\" class=\"headerlink\" title=\"更新丢失\"></a>更新丢失</h2><h2 id=\"写倾斜\"><a href=\"#写倾斜\" class=\"headerlink\" title=\"写倾斜\"></a>写倾斜</h2><h2 id=\"幻读\"><a href=\"#幻读\" class=\"headerlink\" title=\"幻读\"></a>幻读</h2>"},{"layout":"bigdata","title":"数仓2. 数仓分层，实时vs离线","date":"2020-10-14T13:47:20.000Z","_content":"\n## 数据仓库概念\n\n一听到数据仓库的概念, 我们第一反应会问到数据库与数据仓库的区别在哪里?\n\n我的理解是这样的:\n\n## 数据仓库分层\n![](https://tva1.sinaimg.cn/large/007S8ZIlly1gjw482colsj30mj0bf75s.jpg)\n整体来讲, 可以分为数据输入, 数据分析, 数据输出\n\nODS, 备份一份原始数据\n\nDWD, 负责数据ETL\n\nDWS, 聚合层 按天\n\nDWT, 聚合层 累积\n\nADS, 指标\n\n## 离线数仓 VS 实时数仓\n\n![](https://i.loli.net/2020/11/27/irHSFayM4wXhzRN.png)\n\n### Lambda, Kappa\n\n## 数仓技术选型\n\n\n### 输入层\n\n### OLAP数据引擎","source":"_posts/bigdata/数仓2-数仓分层，实时vs离线.md","raw":"---\nlayout: bigdata\ntitle: 数仓2. 数仓分层，实时vs离线\ndate: 2020-10-14 21:47:20\ntags:\n- 数据仓库\n- 数仓分层\n---\n\n## 数据仓库概念\n\n一听到数据仓库的概念, 我们第一反应会问到数据库与数据仓库的区别在哪里?\n\n我的理解是这样的:\n\n## 数据仓库分层\n![](https://tva1.sinaimg.cn/large/007S8ZIlly1gjw482colsj30mj0bf75s.jpg)\n整体来讲, 可以分为数据输入, 数据分析, 数据输出\n\nODS, 备份一份原始数据\n\nDWD, 负责数据ETL\n\nDWS, 聚合层 按天\n\nDWT, 聚合层 累积\n\nADS, 指标\n\n## 离线数仓 VS 实时数仓\n\n![](https://i.loli.net/2020/11/27/irHSFayM4wXhzRN.png)\n\n### Lambda, Kappa\n\n## 数仓技术选型\n\n\n### 输入层\n\n### OLAP数据引擎","slug":"bigdata/数仓2-数仓分层，实时vs离线","published":1,"updated":"2020-11-27T09:00:33.882Z","comments":1,"photos":[],"link":"","_id":"ckio9dwem003ak8nezpkrakbu","content":"<h2 id=\"数据仓库概念\"><a href=\"#数据仓库概念\" class=\"headerlink\" title=\"数据仓库概念\"></a>数据仓库概念</h2><p>一听到数据仓库的概念, 我们第一反应会问到数据库与数据仓库的区别在哪里?</p>\n<p>我的理解是这样的:</p>\n<h2 id=\"数据仓库分层\"><a href=\"#数据仓库分层\" class=\"headerlink\" title=\"数据仓库分层\"></a>数据仓库分层</h2><p><img src=\"https://tva1.sinaimg.cn/large/007S8ZIlly1gjw482colsj30mj0bf75s.jpg\" alt><br>整体来讲, 可以分为数据输入, 数据分析, 数据输出</p>\n<p>ODS, 备份一份原始数据</p>\n<p>DWD, 负责数据ETL</p>\n<p>DWS, 聚合层 按天</p>\n<p>DWT, 聚合层 累积</p>\n<p>ADS, 指标</p>\n<h2 id=\"离线数仓-VS-实时数仓\"><a href=\"#离线数仓-VS-实时数仓\" class=\"headerlink\" title=\"离线数仓 VS 实时数仓\"></a>离线数仓 VS 实时数仓</h2><p><img src=\"https://i.loli.net/2020/11/27/irHSFayM4wXhzRN.png\" alt></p>\n<h3 id=\"Lambda-Kappa\"><a href=\"#Lambda-Kappa\" class=\"headerlink\" title=\"Lambda, Kappa\"></a>Lambda, Kappa</h3><h2 id=\"数仓技术选型\"><a href=\"#数仓技术选型\" class=\"headerlink\" title=\"数仓技术选型\"></a>数仓技术选型</h2><h3 id=\"输入层\"><a href=\"#输入层\" class=\"headerlink\" title=\"输入层\"></a>输入层</h3><h3 id=\"OLAP数据引擎\"><a href=\"#OLAP数据引擎\" class=\"headerlink\" title=\"OLAP数据引擎\"></a>OLAP数据引擎</h3>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"数据仓库概念\"><a href=\"#数据仓库概念\" class=\"headerlink\" title=\"数据仓库概念\"></a>数据仓库概念</h2><p>一听到数据仓库的概念, 我们第一反应会问到数据库与数据仓库的区别在哪里?</p>\n<p>我的理解是这样的:</p>\n<h2 id=\"数据仓库分层\"><a href=\"#数据仓库分层\" class=\"headerlink\" title=\"数据仓库分层\"></a>数据仓库分层</h2><p><img src=\"https://tva1.sinaimg.cn/large/007S8ZIlly1gjw482colsj30mj0bf75s.jpg\" alt><br>整体来讲, 可以分为数据输入, 数据分析, 数据输出</p>\n<p>ODS, 备份一份原始数据</p>\n<p>DWD, 负责数据ETL</p>\n<p>DWS, 聚合层 按天</p>\n<p>DWT, 聚合层 累积</p>\n<p>ADS, 指标</p>\n<h2 id=\"离线数仓-VS-实时数仓\"><a href=\"#离线数仓-VS-实时数仓\" class=\"headerlink\" title=\"离线数仓 VS 实时数仓\"></a>离线数仓 VS 实时数仓</h2><p><img src=\"https://i.loli.net/2020/11/27/irHSFayM4wXhzRN.png\" alt></p>\n<h3 id=\"Lambda-Kappa\"><a href=\"#Lambda-Kappa\" class=\"headerlink\" title=\"Lambda, Kappa\"></a>Lambda, Kappa</h3><h2 id=\"数仓技术选型\"><a href=\"#数仓技术选型\" class=\"headerlink\" title=\"数仓技术选型\"></a>数仓技术选型</h2><h3 id=\"输入层\"><a href=\"#输入层\" class=\"headerlink\" title=\"输入层\"></a>输入层</h3><h3 id=\"OLAP数据引擎\"><a href=\"#OLAP数据引擎\" class=\"headerlink\" title=\"OLAP数据引擎\"></a>OLAP数据引擎</h3>"},{"title":"HDFS原理","date":"2020-05-04T12:31:33.000Z","_content":"#### Block的副本放置策略\n\n* 第一个副本: 放置在上传文件的DataNode; 如果是集群外提交, 随机挑选一台 磁盘不太满, CPU不太忙的节点\n* 第二个副本: 放置在跟第一个副本不同机架的节点上(容灾备份)\n* 第三个副本: 尽量跟第二个副本相同机架(节约网络资源)\n* 更多副本: 随机节点\n\n<!--more-->\n#### HDFS读流程\n![HDFS read](/images/hdfs/hdfs-read.png)\n\n1. 首先调用FileSystem对象的**open**方法, 获取的是一个DistributedFileSystem的实例\n2. DistributedFileSystem通过**RPC**获得文件的第一批block的**locations**, 同一block按照重复数会返回多个locations, 这些locations按照hadoop拓扑结构排序, 距离客户端近的排在前面\n3. 前两步会返回一个FSDataInputStream对象, 该对象会封装成 **DFSInputStream**对象,DFSInputStream可以方便的管理DataNode和NameNode数据流. 客户端调用read方法, DFSInputStream就会找出离客户端最近的datanode并连接datanode.\n4. 数据从datanode源源不断的流向客户端\n5. 如果第一个block块的数据读完了, 就会关闭指向第一个block块的datanode连接, 接着读取下一个block块. 这些操作对客户端透明, 从客户端角度来看只是读一个持续不断的流\n6. 如果第一批block读完了, DFSInputStream就会去NameNode拿下一批blocks的location,继续读, 当所有block读完, 关闭所有流.\n\n#### HDFS写流程\n![HDFS write](/images/hdfs/hdfs-write.png)\n\n1. 客户端通过调用DistributedFileSystem的create方法, 创建一个新的文件\n2. DistributedFileSystem通过RPC调用NameNode,去创建一个没有blocks关联的新文件. 创建前, NameNode会做各种校验, 比如文件是否存在, 客户端有无权限去创建等. 如果通过, NameNode就会记录下新文件, 否则就会抛出IO异常.\n3. 前两步结束后返回FSDataOutputStream的对象, 和读文件等时候相似, FSDataOutputStream被封装成DFSOutputStream.客户端开始写数据到DFSOutputStream, DFSOutputStream会把数据切成一个个小packet, 然后排成队列data queue.\n4. DataStreamer会去处理接受data queue, DataStreamer把packet按队列输出到管道的第一个DataNode中, 第一个DataNode又把packet输出到第二个DataNode中, 以此类推.\n5. DFSOutputStream还有一个队列叫 ack queue, 也是由packet组成, 等待DataNode的收到响应, 当pipeline中的所有DataNode都表示已经收到的时候, 这时ack queue才会把对应的packet包移除\n6. 客户端完成写数据后, 调用close方法关闭写入流\n7. DataStreamer把剩余的包都刷到pipeline里,然后等待ack消息, 收到最后一个ack后, 通知DataNode把文件标记为已完成.\n8. 一个重要的参数: dfs.client.block.write.replace-datanode-on-failure.min-replication\n\n#### HDFS文件权限\n* 与Linux文件权限类似\n    * r\n    * w\n    * x 权限x对于文件忽略, 对于文件夹表示是否允许访问其内容\n* 如果Linux用户lxm使用hadoop命令创建一个文件, 那么这个文件在HDFS中owner就是 lxm\n* HDFS权限的目的: 阻止好人做错事, 而不是阻止坏人做坏事. HDFS相信, 你告诉我你是谁, 我就认为你是谁.\n\n#### HDFS安全模式\n1. NameNode启动的时候, 首先将fsimage载入内存, 并执行edits中的各项操作\n2. 一旦在内存中成功建立文件系统元数据的映射, 则创建一个新的fsimage文件(无需SecondaryNameNode)和一个空的编辑日志(即improgress edits log)\n3. 此刻namenode运行在安全模式. 即 namenode的文件系统对于客户端是只读的\n4. 在此阶段,NameNode会收集各个DataNode的报告, 当数据块达到最小副本数(dfs.namenode.safemode.replication.min)以上时, 会被认为是“安全”的, 在一定比例(dfs.namenode.safemode.threshold-pct)的数据块被确定为“安全”后,安全模式结束\n5. 当检测到副本数不足的数据块时, 该块会被复制直到达到最小副本数, 系统中数据块的位置并不是NameNode维护的, 而是以块列表形式存储在DataNode中\n","source":"_posts/bigdata/HDFS原理.md","raw":"---\ntitle: HDFS原理\ndate: 2020-05-04 20:31:33\ncategories: 读书笔记\ntags:\n- 笔记\n- HDFS\n---\n#### Block的副本放置策略\n\n* 第一个副本: 放置在上传文件的DataNode; 如果是集群外提交, 随机挑选一台 磁盘不太满, CPU不太忙的节点\n* 第二个副本: 放置在跟第一个副本不同机架的节点上(容灾备份)\n* 第三个副本: 尽量跟第二个副本相同机架(节约网络资源)\n* 更多副本: 随机节点\n\n<!--more-->\n#### HDFS读流程\n![HDFS read](/images/hdfs/hdfs-read.png)\n\n1. 首先调用FileSystem对象的**open**方法, 获取的是一个DistributedFileSystem的实例\n2. DistributedFileSystem通过**RPC**获得文件的第一批block的**locations**, 同一block按照重复数会返回多个locations, 这些locations按照hadoop拓扑结构排序, 距离客户端近的排在前面\n3. 前两步会返回一个FSDataInputStream对象, 该对象会封装成 **DFSInputStream**对象,DFSInputStream可以方便的管理DataNode和NameNode数据流. 客户端调用read方法, DFSInputStream就会找出离客户端最近的datanode并连接datanode.\n4. 数据从datanode源源不断的流向客户端\n5. 如果第一个block块的数据读完了, 就会关闭指向第一个block块的datanode连接, 接着读取下一个block块. 这些操作对客户端透明, 从客户端角度来看只是读一个持续不断的流\n6. 如果第一批block读完了, DFSInputStream就会去NameNode拿下一批blocks的location,继续读, 当所有block读完, 关闭所有流.\n\n#### HDFS写流程\n![HDFS write](/images/hdfs/hdfs-write.png)\n\n1. 客户端通过调用DistributedFileSystem的create方法, 创建一个新的文件\n2. DistributedFileSystem通过RPC调用NameNode,去创建一个没有blocks关联的新文件. 创建前, NameNode会做各种校验, 比如文件是否存在, 客户端有无权限去创建等. 如果通过, NameNode就会记录下新文件, 否则就会抛出IO异常.\n3. 前两步结束后返回FSDataOutputStream的对象, 和读文件等时候相似, FSDataOutputStream被封装成DFSOutputStream.客户端开始写数据到DFSOutputStream, DFSOutputStream会把数据切成一个个小packet, 然后排成队列data queue.\n4. DataStreamer会去处理接受data queue, DataStreamer把packet按队列输出到管道的第一个DataNode中, 第一个DataNode又把packet输出到第二个DataNode中, 以此类推.\n5. DFSOutputStream还有一个队列叫 ack queue, 也是由packet组成, 等待DataNode的收到响应, 当pipeline中的所有DataNode都表示已经收到的时候, 这时ack queue才会把对应的packet包移除\n6. 客户端完成写数据后, 调用close方法关闭写入流\n7. DataStreamer把剩余的包都刷到pipeline里,然后等待ack消息, 收到最后一个ack后, 通知DataNode把文件标记为已完成.\n8. 一个重要的参数: dfs.client.block.write.replace-datanode-on-failure.min-replication\n\n#### HDFS文件权限\n* 与Linux文件权限类似\n    * r\n    * w\n    * x 权限x对于文件忽略, 对于文件夹表示是否允许访问其内容\n* 如果Linux用户lxm使用hadoop命令创建一个文件, 那么这个文件在HDFS中owner就是 lxm\n* HDFS权限的目的: 阻止好人做错事, 而不是阻止坏人做坏事. HDFS相信, 你告诉我你是谁, 我就认为你是谁.\n\n#### HDFS安全模式\n1. NameNode启动的时候, 首先将fsimage载入内存, 并执行edits中的各项操作\n2. 一旦在内存中成功建立文件系统元数据的映射, 则创建一个新的fsimage文件(无需SecondaryNameNode)和一个空的编辑日志(即improgress edits log)\n3. 此刻namenode运行在安全模式. 即 namenode的文件系统对于客户端是只读的\n4. 在此阶段,NameNode会收集各个DataNode的报告, 当数据块达到最小副本数(dfs.namenode.safemode.replication.min)以上时, 会被认为是“安全”的, 在一定比例(dfs.namenode.safemode.threshold-pct)的数据块被确定为“安全”后,安全模式结束\n5. 当检测到副本数不足的数据块时, 该块会被复制直到达到最小副本数, 系统中数据块的位置并不是NameNode维护的, 而是以块列表形式存储在DataNode中\n","slug":"bigdata/HDFS原理","published":1,"updated":"2020-10-27T08:08:15.934Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckio9dweo003ek8neb7q6pme3","content":"<h4 id=\"Block的副本放置策略\"><a href=\"#Block的副本放置策略\" class=\"headerlink\" title=\"Block的副本放置策略\"></a>Block的副本放置策略</h4><ul>\n<li>第一个副本: 放置在上传文件的DataNode; 如果是集群外提交, 随机挑选一台 磁盘不太满, CPU不太忙的节点</li>\n<li>第二个副本: 放置在跟第一个副本不同机架的节点上(容灾备份)</li>\n<li>第三个副本: 尽量跟第二个副本相同机架(节约网络资源)</li>\n<li>更多副本: 随机节点</li>\n</ul>\n<a id=\"more\"></a>\n<h4 id=\"HDFS读流程\"><a href=\"#HDFS读流程\" class=\"headerlink\" title=\"HDFS读流程\"></a>HDFS读流程</h4><p><img src=\"/images/hdfs/hdfs-read.png\" alt=\"HDFS read\"></p>\n<ol>\n<li>首先调用FileSystem对象的<strong>open</strong>方法, 获取的是一个DistributedFileSystem的实例</li>\n<li>DistributedFileSystem通过<strong>RPC</strong>获得文件的第一批block的<strong>locations</strong>, 同一block按照重复数会返回多个locations, 这些locations按照hadoop拓扑结构排序, 距离客户端近的排在前面</li>\n<li>前两步会返回一个FSDataInputStream对象, 该对象会封装成 <strong>DFSInputStream</strong>对象,DFSInputStream可以方便的管理DataNode和NameNode数据流. 客户端调用read方法, DFSInputStream就会找出离客户端最近的datanode并连接datanode.</li>\n<li>数据从datanode源源不断的流向客户端</li>\n<li>如果第一个block块的数据读完了, 就会关闭指向第一个block块的datanode连接, 接着读取下一个block块. 这些操作对客户端透明, 从客户端角度来看只是读一个持续不断的流</li>\n<li>如果第一批block读完了, DFSInputStream就会去NameNode拿下一批blocks的location,继续读, 当所有block读完, 关闭所有流.</li>\n</ol>\n<h4 id=\"HDFS写流程\"><a href=\"#HDFS写流程\" class=\"headerlink\" title=\"HDFS写流程\"></a>HDFS写流程</h4><p><img src=\"/images/hdfs/hdfs-write.png\" alt=\"HDFS write\"></p>\n<ol>\n<li>客户端通过调用DistributedFileSystem的create方法, 创建一个新的文件</li>\n<li>DistributedFileSystem通过RPC调用NameNode,去创建一个没有blocks关联的新文件. 创建前, NameNode会做各种校验, 比如文件是否存在, 客户端有无权限去创建等. 如果通过, NameNode就会记录下新文件, 否则就会抛出IO异常.</li>\n<li>前两步结束后返回FSDataOutputStream的对象, 和读文件等时候相似, FSDataOutputStream被封装成DFSOutputStream.客户端开始写数据到DFSOutputStream, DFSOutputStream会把数据切成一个个小packet, 然后排成队列data queue.</li>\n<li>DataStreamer会去处理接受data queue, DataStreamer把packet按队列输出到管道的第一个DataNode中, 第一个DataNode又把packet输出到第二个DataNode中, 以此类推.</li>\n<li>DFSOutputStream还有一个队列叫 ack queue, 也是由packet组成, 等待DataNode的收到响应, 当pipeline中的所有DataNode都表示已经收到的时候, 这时ack queue才会把对应的packet包移除</li>\n<li>客户端完成写数据后, 调用close方法关闭写入流</li>\n<li>DataStreamer把剩余的包都刷到pipeline里,然后等待ack消息, 收到最后一个ack后, 通知DataNode把文件标记为已完成.</li>\n<li>一个重要的参数: dfs.client.block.write.replace-datanode-on-failure.min-replication</li>\n</ol>\n<h4 id=\"HDFS文件权限\"><a href=\"#HDFS文件权限\" class=\"headerlink\" title=\"HDFS文件权限\"></a>HDFS文件权限</h4><ul>\n<li>与Linux文件权限类似<ul>\n<li>r</li>\n<li>w</li>\n<li>x 权限x对于文件忽略, 对于文件夹表示是否允许访问其内容</li>\n</ul>\n</li>\n<li>如果Linux用户lxm使用hadoop命令创建一个文件, 那么这个文件在HDFS中owner就是 lxm</li>\n<li>HDFS权限的目的: 阻止好人做错事, 而不是阻止坏人做坏事. HDFS相信, 你告诉我你是谁, 我就认为你是谁.</li>\n</ul>\n<h4 id=\"HDFS安全模式\"><a href=\"#HDFS安全模式\" class=\"headerlink\" title=\"HDFS安全模式\"></a>HDFS安全模式</h4><ol>\n<li>NameNode启动的时候, 首先将fsimage载入内存, 并执行edits中的各项操作</li>\n<li>一旦在内存中成功建立文件系统元数据的映射, 则创建一个新的fsimage文件(无需SecondaryNameNode)和一个空的编辑日志(即improgress edits log)</li>\n<li>此刻namenode运行在安全模式. 即 namenode的文件系统对于客户端是只读的</li>\n<li>在此阶段,NameNode会收集各个DataNode的报告, 当数据块达到最小副本数(dfs.namenode.safemode.replication.min)以上时, 会被认为是“安全”的, 在一定比例(dfs.namenode.safemode.threshold-pct)的数据块被确定为“安全”后,安全模式结束</li>\n<li>当检测到副本数不足的数据块时, 该块会被复制直到达到最小副本数, 系统中数据块的位置并不是NameNode维护的, 而是以块列表形式存储在DataNode中</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h4 id=\"Block的副本放置策略\"><a href=\"#Block的副本放置策略\" class=\"headerlink\" title=\"Block的副本放置策略\"></a>Block的副本放置策略</h4><ul>\n<li>第一个副本: 放置在上传文件的DataNode; 如果是集群外提交, 随机挑选一台 磁盘不太满, CPU不太忙的节点</li>\n<li>第二个副本: 放置在跟第一个副本不同机架的节点上(容灾备份)</li>\n<li>第三个副本: 尽量跟第二个副本相同机架(节约网络资源)</li>\n<li>更多副本: 随机节点</li>\n</ul>","more":"<h4 id=\"HDFS读流程\"><a href=\"#HDFS读流程\" class=\"headerlink\" title=\"HDFS读流程\"></a>HDFS读流程</h4><p><img src=\"/images/hdfs/hdfs-read.png\" alt=\"HDFS read\"></p>\n<ol>\n<li>首先调用FileSystem对象的<strong>open</strong>方法, 获取的是一个DistributedFileSystem的实例</li>\n<li>DistributedFileSystem通过<strong>RPC</strong>获得文件的第一批block的<strong>locations</strong>, 同一block按照重复数会返回多个locations, 这些locations按照hadoop拓扑结构排序, 距离客户端近的排在前面</li>\n<li>前两步会返回一个FSDataInputStream对象, 该对象会封装成 <strong>DFSInputStream</strong>对象,DFSInputStream可以方便的管理DataNode和NameNode数据流. 客户端调用read方法, DFSInputStream就会找出离客户端最近的datanode并连接datanode.</li>\n<li>数据从datanode源源不断的流向客户端</li>\n<li>如果第一个block块的数据读完了, 就会关闭指向第一个block块的datanode连接, 接着读取下一个block块. 这些操作对客户端透明, 从客户端角度来看只是读一个持续不断的流</li>\n<li>如果第一批block读完了, DFSInputStream就会去NameNode拿下一批blocks的location,继续读, 当所有block读完, 关闭所有流.</li>\n</ol>\n<h4 id=\"HDFS写流程\"><a href=\"#HDFS写流程\" class=\"headerlink\" title=\"HDFS写流程\"></a>HDFS写流程</h4><p><img src=\"/images/hdfs/hdfs-write.png\" alt=\"HDFS write\"></p>\n<ol>\n<li>客户端通过调用DistributedFileSystem的create方法, 创建一个新的文件</li>\n<li>DistributedFileSystem通过RPC调用NameNode,去创建一个没有blocks关联的新文件. 创建前, NameNode会做各种校验, 比如文件是否存在, 客户端有无权限去创建等. 如果通过, NameNode就会记录下新文件, 否则就会抛出IO异常.</li>\n<li>前两步结束后返回FSDataOutputStream的对象, 和读文件等时候相似, FSDataOutputStream被封装成DFSOutputStream.客户端开始写数据到DFSOutputStream, DFSOutputStream会把数据切成一个个小packet, 然后排成队列data queue.</li>\n<li>DataStreamer会去处理接受data queue, DataStreamer把packet按队列输出到管道的第一个DataNode中, 第一个DataNode又把packet输出到第二个DataNode中, 以此类推.</li>\n<li>DFSOutputStream还有一个队列叫 ack queue, 也是由packet组成, 等待DataNode的收到响应, 当pipeline中的所有DataNode都表示已经收到的时候, 这时ack queue才会把对应的packet包移除</li>\n<li>客户端完成写数据后, 调用close方法关闭写入流</li>\n<li>DataStreamer把剩余的包都刷到pipeline里,然后等待ack消息, 收到最后一个ack后, 通知DataNode把文件标记为已完成.</li>\n<li>一个重要的参数: dfs.client.block.write.replace-datanode-on-failure.min-replication</li>\n</ol>\n<h4 id=\"HDFS文件权限\"><a href=\"#HDFS文件权限\" class=\"headerlink\" title=\"HDFS文件权限\"></a>HDFS文件权限</h4><ul>\n<li>与Linux文件权限类似<ul>\n<li>r</li>\n<li>w</li>\n<li>x 权限x对于文件忽略, 对于文件夹表示是否允许访问其内容</li>\n</ul>\n</li>\n<li>如果Linux用户lxm使用hadoop命令创建一个文件, 那么这个文件在HDFS中owner就是 lxm</li>\n<li>HDFS权限的目的: 阻止好人做错事, 而不是阻止坏人做坏事. HDFS相信, 你告诉我你是谁, 我就认为你是谁.</li>\n</ul>\n<h4 id=\"HDFS安全模式\"><a href=\"#HDFS安全模式\" class=\"headerlink\" title=\"HDFS安全模式\"></a>HDFS安全模式</h4><ol>\n<li>NameNode启动的时候, 首先将fsimage载入内存, 并执行edits中的各项操作</li>\n<li>一旦在内存中成功建立文件系统元数据的映射, 则创建一个新的fsimage文件(无需SecondaryNameNode)和一个空的编辑日志(即improgress edits log)</li>\n<li>此刻namenode运行在安全模式. 即 namenode的文件系统对于客户端是只读的</li>\n<li>在此阶段,NameNode会收集各个DataNode的报告, 当数据块达到最小副本数(dfs.namenode.safemode.replication.min)以上时, 会被认为是“安全”的, 在一定比例(dfs.namenode.safemode.threshold-pct)的数据块被确定为“安全”后,安全模式结束</li>\n<li>当检测到副本数不足的数据块时, 该块会被复制直到达到最小副本数, 系统中数据块的位置并不是NameNode维护的, 而是以块列表形式存储在DataNode中</li>\n</ol>"},{"title":"数仓1. 聊聊数据采集","date":"2020-10-13T14:16:34.000Z","_content":"## 数据仓库\n\n数据仓库的数据来源往往有两类:\n\n* 业务数据, 处理事务过程中产生的数据, 通常存储在关系型数据库中,如 MySQL, Oracle等.\n* 行为数据, 用户与客户端产品交互过程中产生的数据, 通常存储在日志文件中.\n那么业务数据应该如何采集到数据仓库呢?\n\n## 1. 数据采集 - 业务数据同步方式\n\n### 接口 - 最古老的方式\n\n推: 应用主动发送数据到大数据平台.\n\n拉: 大数据平台定时从应用拉取数据.\n\n优点:\n    实现简单\n\n缺点:\n    耦合非常严重, 需要记录对方的访问信息和接口地址\n    增加业务开发人员额外工作\n\n### 消息队列\n\n订阅: 应用将数据发布到消息队列, 大数据订阅主题并消费\n\n优点:\n    业务与大数据解耦,  业务应用不关心谁消费了这条消息\n    多个消费者可以同时消费\n\n缺点:\n    仍旧增加开发人员额外工作\n    MQ带来的复杂度, 可用性问题\n\n### 数据库级别同步\n\n离线数据同步, 适用T+1的场景 sqoop, datax\n\n增量数据同步, **canal**, streamsets\n<!--more-->\n>-canal 模拟 MySQL slave 的交互协议，伪装自己为 MySQL slave ，向 MySQL master 发送 dump 协议\n>-MySQL master 收到 dump 请求，开始推送 binary log 给 slave (即 canal )\n>-canal 解析 binary log 对象(原始为 byte 流)\n>实现MySQL增量数据 - 字段映射并同步 - HBase/ES/RDB(mysql, postgresql, oracle, sqlserver...)\n\n优点:\n    不影响业务开发, 只需要双方提前对数据格式达成共识\n\n缺点:\n    复杂度\n    无法在迁移过程中做复杂的转换\n\n### 总结\n\n毫无疑问, 目前所有的数仓(的业务数据)都是基于数据库级别的同步来作为数据输入的.\n\n那么我们再来看一下行为数据的采集:\n\n## 2. 数据采集 - 行为数据同步\n\n在讨论行为数据的同步方式之前, 先来考虑两个问题:\n\n1. 业务数据的数据结构是有固定的模式的, 然而行为数据(停留,点击, 跳转, 提交, 轨迹等)复杂多样, **怎样针对不同的行为制定相同的数据模式?**\n\n2. 行为数据由前端发送, 还是后端发送? \n\n带着这俩问题, 先来看下事件模型.\n\n### 2.1. 用户行为数据模型 -  Event Model\n\n通常都会使用事件模型Event Model来描述用户在产品上的各种行为.\n\n#### Event五要素\n\n* Who:  登录用户ID, 匿名ID(cookie_id, 设备id)\n* When: 事件发生实际时间, 要考虑到本地时间不一定准确的问题, 可以初始化时从服务器获取, 而服务器要做NTP服务\n* Where: ip, GPS\n* How: 从事这个事件的方式. 包括设备,浏览器,APP版本,OS版本,渠道,referer,屏幕宽高,是否wifi\n* What: 用户所做事件的具体内容\n\n#### 复杂的数据纬度, 统一的数据格式\n\n每个产品的数据指标都不同, 如PV, UV, 视频播放数, 做题数等.尤其一些细节、精细化的分析, 都需要复杂的数据纬度来支撑.\n通过上面的Event Model, 为不同的事件, 定义相同的数据格式, 方便后续的收集处理.\n\n### 埋点: 前端 vs 后端\n\n**一句话:如果事件只在客户端发生,不需要往后端发送任何请求,那么在前端埋点;否则后端埋点较好.**\n\n考虑以下几种情况: \n\n事件只在前端发生, 不往后端发送任何请求, 前端发\n\n前端不能拿到事件所有(关键)字段,  后端发\n\n事件数据后端也需要使用, 后端发\n\n经常新增或修改指标, 后端发 (app涉及发版和用户更新问题)\n\n对数据的完整性、一致性、即时性要求很高, 后端发(controller层在处理业务请求时同时发送)\n\neg:\n\n客户端通常会多条数据打包压缩, 等满足一定条件再发, 如果网络状况不好, 或者应用关闭or进入后台, 可能造成上传不及时\n\n### 行为数据同步方式\n\n浏览器/APP -> Nginx -> Flume -> HDFS, Kafka\n","source":"_posts/bigdata/数仓1.聊聊数据采集.md","raw":"---\ntitle: 数仓1. 聊聊数据采集\ndate: 2020-10-13 22:16:34\ntags:\n- 数据仓库\n- 数据采集\n---\n## 数据仓库\n\n数据仓库的数据来源往往有两类:\n\n* 业务数据, 处理事务过程中产生的数据, 通常存储在关系型数据库中,如 MySQL, Oracle等.\n* 行为数据, 用户与客户端产品交互过程中产生的数据, 通常存储在日志文件中.\n那么业务数据应该如何采集到数据仓库呢?\n\n## 1. 数据采集 - 业务数据同步方式\n\n### 接口 - 最古老的方式\n\n推: 应用主动发送数据到大数据平台.\n\n拉: 大数据平台定时从应用拉取数据.\n\n优点:\n    实现简单\n\n缺点:\n    耦合非常严重, 需要记录对方的访问信息和接口地址\n    增加业务开发人员额外工作\n\n### 消息队列\n\n订阅: 应用将数据发布到消息队列, 大数据订阅主题并消费\n\n优点:\n    业务与大数据解耦,  业务应用不关心谁消费了这条消息\n    多个消费者可以同时消费\n\n缺点:\n    仍旧增加开发人员额外工作\n    MQ带来的复杂度, 可用性问题\n\n### 数据库级别同步\n\n离线数据同步, 适用T+1的场景 sqoop, datax\n\n增量数据同步, **canal**, streamsets\n<!--more-->\n>-canal 模拟 MySQL slave 的交互协议，伪装自己为 MySQL slave ，向 MySQL master 发送 dump 协议\n>-MySQL master 收到 dump 请求，开始推送 binary log 给 slave (即 canal )\n>-canal 解析 binary log 对象(原始为 byte 流)\n>实现MySQL增量数据 - 字段映射并同步 - HBase/ES/RDB(mysql, postgresql, oracle, sqlserver...)\n\n优点:\n    不影响业务开发, 只需要双方提前对数据格式达成共识\n\n缺点:\n    复杂度\n    无法在迁移过程中做复杂的转换\n\n### 总结\n\n毫无疑问, 目前所有的数仓(的业务数据)都是基于数据库级别的同步来作为数据输入的.\n\n那么我们再来看一下行为数据的采集:\n\n## 2. 数据采集 - 行为数据同步\n\n在讨论行为数据的同步方式之前, 先来考虑两个问题:\n\n1. 业务数据的数据结构是有固定的模式的, 然而行为数据(停留,点击, 跳转, 提交, 轨迹等)复杂多样, **怎样针对不同的行为制定相同的数据模式?**\n\n2. 行为数据由前端发送, 还是后端发送? \n\n带着这俩问题, 先来看下事件模型.\n\n### 2.1. 用户行为数据模型 -  Event Model\n\n通常都会使用事件模型Event Model来描述用户在产品上的各种行为.\n\n#### Event五要素\n\n* Who:  登录用户ID, 匿名ID(cookie_id, 设备id)\n* When: 事件发生实际时间, 要考虑到本地时间不一定准确的问题, 可以初始化时从服务器获取, 而服务器要做NTP服务\n* Where: ip, GPS\n* How: 从事这个事件的方式. 包括设备,浏览器,APP版本,OS版本,渠道,referer,屏幕宽高,是否wifi\n* What: 用户所做事件的具体内容\n\n#### 复杂的数据纬度, 统一的数据格式\n\n每个产品的数据指标都不同, 如PV, UV, 视频播放数, 做题数等.尤其一些细节、精细化的分析, 都需要复杂的数据纬度来支撑.\n通过上面的Event Model, 为不同的事件, 定义相同的数据格式, 方便后续的收集处理.\n\n### 埋点: 前端 vs 后端\n\n**一句话:如果事件只在客户端发生,不需要往后端发送任何请求,那么在前端埋点;否则后端埋点较好.**\n\n考虑以下几种情况: \n\n事件只在前端发生, 不往后端发送任何请求, 前端发\n\n前端不能拿到事件所有(关键)字段,  后端发\n\n事件数据后端也需要使用, 后端发\n\n经常新增或修改指标, 后端发 (app涉及发版和用户更新问题)\n\n对数据的完整性、一致性、即时性要求很高, 后端发(controller层在处理业务请求时同时发送)\n\neg:\n\n客户端通常会多条数据打包压缩, 等满足一定条件再发, 如果网络状况不好, 或者应用关闭or进入后台, 可能造成上传不及时\n\n### 行为数据同步方式\n\n浏览器/APP -> Nginx -> Flume -> HDFS, Kafka\n","slug":"bigdata/数仓1.聊聊数据采集","published":1,"updated":"2020-10-27T08:08:15.935Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckio9dweq003ik8ne8116f6kz","content":"<h2 id=\"数据仓库\"><a href=\"#数据仓库\" class=\"headerlink\" title=\"数据仓库\"></a>数据仓库</h2><p>数据仓库的数据来源往往有两类:</p>\n<ul>\n<li>业务数据, 处理事务过程中产生的数据, 通常存储在关系型数据库中,如 MySQL, Oracle等.</li>\n<li>行为数据, 用户与客户端产品交互过程中产生的数据, 通常存储在日志文件中.<br>那么业务数据应该如何采集到数据仓库呢?</li>\n</ul>\n<h2 id=\"1-数据采集-业务数据同步方式\"><a href=\"#1-数据采集-业务数据同步方式\" class=\"headerlink\" title=\"1. 数据采集 - 业务数据同步方式\"></a>1. 数据采集 - 业务数据同步方式</h2><h3 id=\"接口-最古老的方式\"><a href=\"#接口-最古老的方式\" class=\"headerlink\" title=\"接口 - 最古老的方式\"></a>接口 - 最古老的方式</h3><p>推: 应用主动发送数据到大数据平台.</p>\n<p>拉: 大数据平台定时从应用拉取数据.</p>\n<p>优点:<br>    实现简单</p>\n<p>缺点:<br>    耦合非常严重, 需要记录对方的访问信息和接口地址<br>    增加业务开发人员额外工作</p>\n<h3 id=\"消息队列\"><a href=\"#消息队列\" class=\"headerlink\" title=\"消息队列\"></a>消息队列</h3><p>订阅: 应用将数据发布到消息队列, 大数据订阅主题并消费</p>\n<p>优点:<br>    业务与大数据解耦,  业务应用不关心谁消费了这条消息<br>    多个消费者可以同时消费</p>\n<p>缺点:<br>    仍旧增加开发人员额外工作<br>    MQ带来的复杂度, 可用性问题</p>\n<h3 id=\"数据库级别同步\"><a href=\"#数据库级别同步\" class=\"headerlink\" title=\"数据库级别同步\"></a>数据库级别同步</h3><p>离线数据同步, 适用T+1的场景 sqoop, datax</p>\n<p>增量数据同步, <strong>canal</strong>, streamsets</p>\n<a id=\"more\"></a>\n<blockquote>\n<p>-canal 模拟 MySQL slave 的交互协议，伪装自己为 MySQL slave ，向 MySQL master 发送 dump 协议<br>-MySQL master 收到 dump 请求，开始推送 binary log 给 slave (即 canal )<br>-canal 解析 binary log 对象(原始为 byte 流)<br>实现MySQL增量数据 - 字段映射并同步 - HBase/ES/RDB(mysql, postgresql, oracle, sqlserver…)</p>\n</blockquote>\n<p>优点:<br>    不影响业务开发, 只需要双方提前对数据格式达成共识</p>\n<p>缺点:<br>    复杂度<br>    无法在迁移过程中做复杂的转换</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>毫无疑问, 目前所有的数仓(的业务数据)都是基于数据库级别的同步来作为数据输入的.</p>\n<p>那么我们再来看一下行为数据的采集:</p>\n<h2 id=\"2-数据采集-行为数据同步\"><a href=\"#2-数据采集-行为数据同步\" class=\"headerlink\" title=\"2. 数据采集 - 行为数据同步\"></a>2. 数据采集 - 行为数据同步</h2><p>在讨论行为数据的同步方式之前, 先来考虑两个问题:</p>\n<ol>\n<li><p>业务数据的数据结构是有固定的模式的, 然而行为数据(停留,点击, 跳转, 提交, 轨迹等)复杂多样, <strong>怎样针对不同的行为制定相同的数据模式?</strong></p>\n</li>\n<li><p>行为数据由前端发送, 还是后端发送? </p>\n</li>\n</ol>\n<p>带着这俩问题, 先来看下事件模型.</p>\n<h3 id=\"2-1-用户行为数据模型-Event-Model\"><a href=\"#2-1-用户行为数据模型-Event-Model\" class=\"headerlink\" title=\"2.1. 用户行为数据模型 -  Event Model\"></a>2.1. 用户行为数据模型 -  Event Model</h3><p>通常都会使用事件模型Event Model来描述用户在产品上的各种行为.</p>\n<h4 id=\"Event五要素\"><a href=\"#Event五要素\" class=\"headerlink\" title=\"Event五要素\"></a>Event五要素</h4><ul>\n<li>Who:  登录用户ID, 匿名ID(cookie_id, 设备id)</li>\n<li>When: 事件发生实际时间, 要考虑到本地时间不一定准确的问题, 可以初始化时从服务器获取, 而服务器要做NTP服务</li>\n<li>Where: ip, GPS</li>\n<li>How: 从事这个事件的方式. 包括设备,浏览器,APP版本,OS版本,渠道,referer,屏幕宽高,是否wifi</li>\n<li>What: 用户所做事件的具体内容</li>\n</ul>\n<h4 id=\"复杂的数据纬度-统一的数据格式\"><a href=\"#复杂的数据纬度-统一的数据格式\" class=\"headerlink\" title=\"复杂的数据纬度, 统一的数据格式\"></a>复杂的数据纬度, 统一的数据格式</h4><p>每个产品的数据指标都不同, 如PV, UV, 视频播放数, 做题数等.尤其一些细节、精细化的分析, 都需要复杂的数据纬度来支撑.<br>通过上面的Event Model, 为不同的事件, 定义相同的数据格式, 方便后续的收集处理.</p>\n<h3 id=\"埋点-前端-vs-后端\"><a href=\"#埋点-前端-vs-后端\" class=\"headerlink\" title=\"埋点: 前端 vs 后端\"></a>埋点: 前端 vs 后端</h3><p><strong>一句话:如果事件只在客户端发生,不需要往后端发送任何请求,那么在前端埋点;否则后端埋点较好.</strong></p>\n<p>考虑以下几种情况: </p>\n<p>事件只在前端发生, 不往后端发送任何请求, 前端发</p>\n<p>前端不能拿到事件所有(关键)字段,  后端发</p>\n<p>事件数据后端也需要使用, 后端发</p>\n<p>经常新增或修改指标, 后端发 (app涉及发版和用户更新问题)</p>\n<p>对数据的完整性、一致性、即时性要求很高, 后端发(controller层在处理业务请求时同时发送)</p>\n<p>eg:</p>\n<p>客户端通常会多条数据打包压缩, 等满足一定条件再发, 如果网络状况不好, 或者应用关闭or进入后台, 可能造成上传不及时</p>\n<h3 id=\"行为数据同步方式\"><a href=\"#行为数据同步方式\" class=\"headerlink\" title=\"行为数据同步方式\"></a>行为数据同步方式</h3><p>浏览器/APP -&gt; Nginx -&gt; Flume -&gt; HDFS, Kafka</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"数据仓库\"><a href=\"#数据仓库\" class=\"headerlink\" title=\"数据仓库\"></a>数据仓库</h2><p>数据仓库的数据来源往往有两类:</p>\n<ul>\n<li>业务数据, 处理事务过程中产生的数据, 通常存储在关系型数据库中,如 MySQL, Oracle等.</li>\n<li>行为数据, 用户与客户端产品交互过程中产生的数据, 通常存储在日志文件中.<br>那么业务数据应该如何采集到数据仓库呢?</li>\n</ul>\n<h2 id=\"1-数据采集-业务数据同步方式\"><a href=\"#1-数据采集-业务数据同步方式\" class=\"headerlink\" title=\"1. 数据采集 - 业务数据同步方式\"></a>1. 数据采集 - 业务数据同步方式</h2><h3 id=\"接口-最古老的方式\"><a href=\"#接口-最古老的方式\" class=\"headerlink\" title=\"接口 - 最古老的方式\"></a>接口 - 最古老的方式</h3><p>推: 应用主动发送数据到大数据平台.</p>\n<p>拉: 大数据平台定时从应用拉取数据.</p>\n<p>优点:<br>    实现简单</p>\n<p>缺点:<br>    耦合非常严重, 需要记录对方的访问信息和接口地址<br>    增加业务开发人员额外工作</p>\n<h3 id=\"消息队列\"><a href=\"#消息队列\" class=\"headerlink\" title=\"消息队列\"></a>消息队列</h3><p>订阅: 应用将数据发布到消息队列, 大数据订阅主题并消费</p>\n<p>优点:<br>    业务与大数据解耦,  业务应用不关心谁消费了这条消息<br>    多个消费者可以同时消费</p>\n<p>缺点:<br>    仍旧增加开发人员额外工作<br>    MQ带来的复杂度, 可用性问题</p>\n<h3 id=\"数据库级别同步\"><a href=\"#数据库级别同步\" class=\"headerlink\" title=\"数据库级别同步\"></a>数据库级别同步</h3><p>离线数据同步, 适用T+1的场景 sqoop, datax</p>\n<p>增量数据同步, <strong>canal</strong>, streamsets</p>","more":"<blockquote>\n<p>-canal 模拟 MySQL slave 的交互协议，伪装自己为 MySQL slave ，向 MySQL master 发送 dump 协议<br>-MySQL master 收到 dump 请求，开始推送 binary log 给 slave (即 canal )<br>-canal 解析 binary log 对象(原始为 byte 流)<br>实现MySQL增量数据 - 字段映射并同步 - HBase/ES/RDB(mysql, postgresql, oracle, sqlserver…)</p>\n</blockquote>\n<p>优点:<br>    不影响业务开发, 只需要双方提前对数据格式达成共识</p>\n<p>缺点:<br>    复杂度<br>    无法在迁移过程中做复杂的转换</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>毫无疑问, 目前所有的数仓(的业务数据)都是基于数据库级别的同步来作为数据输入的.</p>\n<p>那么我们再来看一下行为数据的采集:</p>\n<h2 id=\"2-数据采集-行为数据同步\"><a href=\"#2-数据采集-行为数据同步\" class=\"headerlink\" title=\"2. 数据采集 - 行为数据同步\"></a>2. 数据采集 - 行为数据同步</h2><p>在讨论行为数据的同步方式之前, 先来考虑两个问题:</p>\n<ol>\n<li><p>业务数据的数据结构是有固定的模式的, 然而行为数据(停留,点击, 跳转, 提交, 轨迹等)复杂多样, <strong>怎样针对不同的行为制定相同的数据模式?</strong></p>\n</li>\n<li><p>行为数据由前端发送, 还是后端发送? </p>\n</li>\n</ol>\n<p>带着这俩问题, 先来看下事件模型.</p>\n<h3 id=\"2-1-用户行为数据模型-Event-Model\"><a href=\"#2-1-用户行为数据模型-Event-Model\" class=\"headerlink\" title=\"2.1. 用户行为数据模型 -  Event Model\"></a>2.1. 用户行为数据模型 -  Event Model</h3><p>通常都会使用事件模型Event Model来描述用户在产品上的各种行为.</p>\n<h4 id=\"Event五要素\"><a href=\"#Event五要素\" class=\"headerlink\" title=\"Event五要素\"></a>Event五要素</h4><ul>\n<li>Who:  登录用户ID, 匿名ID(cookie_id, 设备id)</li>\n<li>When: 事件发生实际时间, 要考虑到本地时间不一定准确的问题, 可以初始化时从服务器获取, 而服务器要做NTP服务</li>\n<li>Where: ip, GPS</li>\n<li>How: 从事这个事件的方式. 包括设备,浏览器,APP版本,OS版本,渠道,referer,屏幕宽高,是否wifi</li>\n<li>What: 用户所做事件的具体内容</li>\n</ul>\n<h4 id=\"复杂的数据纬度-统一的数据格式\"><a href=\"#复杂的数据纬度-统一的数据格式\" class=\"headerlink\" title=\"复杂的数据纬度, 统一的数据格式\"></a>复杂的数据纬度, 统一的数据格式</h4><p>每个产品的数据指标都不同, 如PV, UV, 视频播放数, 做题数等.尤其一些细节、精细化的分析, 都需要复杂的数据纬度来支撑.<br>通过上面的Event Model, 为不同的事件, 定义相同的数据格式, 方便后续的收集处理.</p>\n<h3 id=\"埋点-前端-vs-后端\"><a href=\"#埋点-前端-vs-后端\" class=\"headerlink\" title=\"埋点: 前端 vs 后端\"></a>埋点: 前端 vs 后端</h3><p><strong>一句话:如果事件只在客户端发生,不需要往后端发送任何请求,那么在前端埋点;否则后端埋点较好.</strong></p>\n<p>考虑以下几种情况: </p>\n<p>事件只在前端发生, 不往后端发送任何请求, 前端发</p>\n<p>前端不能拿到事件所有(关键)字段,  后端发</p>\n<p>事件数据后端也需要使用, 后端发</p>\n<p>经常新增或修改指标, 后端发 (app涉及发版和用户更新问题)</p>\n<p>对数据的完整性、一致性、即时性要求很高, 后端发(controller层在处理业务请求时同时发送)</p>\n<p>eg:</p>\n<p>客户端通常会多条数据打包压缩, 等满足一定条件再发, 如果网络状况不好, 或者应用关闭or进入后台, 可能造成上传不及时</p>\n<h3 id=\"行为数据同步方式\"><a href=\"#行为数据同步方式\" class=\"headerlink\" title=\"行为数据同步方式\"></a>行为数据同步方式</h3><p>浏览器/APP -&gt; Nginx -&gt; Flume -&gt; HDFS, Kafka</p>"},{"title":"Flink-2. 流计算API基础","date":"2020-09-05T08:15:49.000Z","_content":"\n## Flink运行模型\n\n![runtime](https://tva1.sinaimg.cn/large/007S8ZIlly1gj7lszqn0xj30jg04i74i.jpg)\n以上为 Flink 的运行模型，Flink 的程序主要由三部分构成，分别为 Source、 Transformation、Sink。DataSource 主要负责数据的读取，Transformation 主要负责对 属于的转换操作，Sink 负责最终数据的输出。\n\n每个 Flink 程序都包含以下的若干流程:\n\n1. 获得一个执行环境;(Execution Environment)\n2. 加载/创建初始数据;(Source)\n3. 指定转换这些数据;(Transformation)\n4. 指定放置计算结果的位置;(Sink)\n5. 触发程序执行\n\n如下图所示:\n<!--more-->\n![stream dataflow](https://tva1.sinaimg.cn/large/007S8ZIlly1gj7ls5f2oej30hl0dswfz.jpg)\n\n## Enviroment\n\n**执行环境 StreamExecutionEnvironment 是所有 Flink 程序的基础。**\n\n创建一个执行环境，表示当前执行程序的上下文。\n\n* 如果程序独立调用, 如IDE中Run, 返回本地执行环境\n* 如果提交到集群, 则返回此集群的执行环境\n\n```java\nStreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\n```\n\n## Source\n\n数据源.\n\n* 内置的数据源: 基于File, Socket, Collection等.\n\n* addSource, 自定义数据源, 官方提供了常用的kafka, rabbitmq等, 也可以自己开发\n\neg: `env.addSource(new FlinkKafkaConsumer010<>(...))`\n\n## Sink\n\nData Sinks消费DataStreams中的数据, 并且输出到file, socket, 外部系统中.\n\n* 内置可以输出到txt, csv, socket, 直接打印等\n* addSink - 扩展sink方法, 通过connectors消费到外部系统\n\n## Transformations\n\nDataStream API的转换分为四类：\n\n1. 作用于单个事件的基本转换\n\n2. 针对相同键值事件的KeyedStream转换\n\n3. 将多条数据流合并为一条，或将一条数据流拆分为多条流的转换\n\n4. 对流中的事件进行重新组织的分发转换\n\nBasic Transformations\n\n* Map\n    对整个DataStream做一一对应的映射, 即每一个元素产生一个输出元素。\n* Filter, 过滤\n* FlatMap\n    对整个DataStream做一对多的映射， 即每一个元素可以产生多个（可以是一个）输出元素。\n\nKeyedStream Transformations\n\n* KeyBy\n    对输入DataStream分区， 即相同key的元素分到同一分区。基于key对流(内部使用hash函数)进行分区。\n* Aggregations\n    聚合操作,如min, max, sum等。\n* Reduce\n    根据多个元素生成一个元素。返回单个结果值。\n\nMultistream Transformation，多流转换\n\n* Union, 组合流\n* Connect, coMap, coFlatMap\n* Split & select, split拆分流, select从拆分流中选择特定流\n\nDistribution Transformation\n\n* Random\n    均匀分布分区\n* Round-Robin\n    轮询分区\n* Rescale\n    可伸缩分区\n* Broadcast\n    广播分区\n* Rebanlance\n    负载均衡分区\n* Global\n    global()方法将输入流中的所有事件发往下游算子的第一个并行任务。\n* Custom\n    用户程序自定义分区\n","source":"_posts/flink/Flink-2-流计算API.md","raw":"---\ntitle: Flink-2. 流计算API基础\ndate: 2020-09-05 16:15:49\ncategories: 流计算\ntags: \n- Flink\n---\n\n## Flink运行模型\n\n![runtime](https://tva1.sinaimg.cn/large/007S8ZIlly1gj7lszqn0xj30jg04i74i.jpg)\n以上为 Flink 的运行模型，Flink 的程序主要由三部分构成，分别为 Source、 Transformation、Sink。DataSource 主要负责数据的读取，Transformation 主要负责对 属于的转换操作，Sink 负责最终数据的输出。\n\n每个 Flink 程序都包含以下的若干流程:\n\n1. 获得一个执行环境;(Execution Environment)\n2. 加载/创建初始数据;(Source)\n3. 指定转换这些数据;(Transformation)\n4. 指定放置计算结果的位置;(Sink)\n5. 触发程序执行\n\n如下图所示:\n<!--more-->\n![stream dataflow](https://tva1.sinaimg.cn/large/007S8ZIlly1gj7ls5f2oej30hl0dswfz.jpg)\n\n## Enviroment\n\n**执行环境 StreamExecutionEnvironment 是所有 Flink 程序的基础。**\n\n创建一个执行环境，表示当前执行程序的上下文。\n\n* 如果程序独立调用, 如IDE中Run, 返回本地执行环境\n* 如果提交到集群, 则返回此集群的执行环境\n\n```java\nStreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\n```\n\n## Source\n\n数据源.\n\n* 内置的数据源: 基于File, Socket, Collection等.\n\n* addSource, 自定义数据源, 官方提供了常用的kafka, rabbitmq等, 也可以自己开发\n\neg: `env.addSource(new FlinkKafkaConsumer010<>(...))`\n\n## Sink\n\nData Sinks消费DataStreams中的数据, 并且输出到file, socket, 外部系统中.\n\n* 内置可以输出到txt, csv, socket, 直接打印等\n* addSink - 扩展sink方法, 通过connectors消费到外部系统\n\n## Transformations\n\nDataStream API的转换分为四类：\n\n1. 作用于单个事件的基本转换\n\n2. 针对相同键值事件的KeyedStream转换\n\n3. 将多条数据流合并为一条，或将一条数据流拆分为多条流的转换\n\n4. 对流中的事件进行重新组织的分发转换\n\nBasic Transformations\n\n* Map\n    对整个DataStream做一一对应的映射, 即每一个元素产生一个输出元素。\n* Filter, 过滤\n* FlatMap\n    对整个DataStream做一对多的映射， 即每一个元素可以产生多个（可以是一个）输出元素。\n\nKeyedStream Transformations\n\n* KeyBy\n    对输入DataStream分区， 即相同key的元素分到同一分区。基于key对流(内部使用hash函数)进行分区。\n* Aggregations\n    聚合操作,如min, max, sum等。\n* Reduce\n    根据多个元素生成一个元素。返回单个结果值。\n\nMultistream Transformation，多流转换\n\n* Union, 组合流\n* Connect, coMap, coFlatMap\n* Split & select, split拆分流, select从拆分流中选择特定流\n\nDistribution Transformation\n\n* Random\n    均匀分布分区\n* Round-Robin\n    轮询分区\n* Rescale\n    可伸缩分区\n* Broadcast\n    广播分区\n* Rebanlance\n    负载均衡分区\n* Global\n    global()方法将输入流中的所有事件发往下游算子的第一个并行任务。\n* Custom\n    用户程序自定义分区\n","slug":"flink/Flink-2-流计算API","published":1,"updated":"2020-10-27T08:08:15.939Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckio9dwes003mk8ne5jid51dg","content":"<h2 id=\"Flink运行模型\"><a href=\"#Flink运行模型\" class=\"headerlink\" title=\"Flink运行模型\"></a>Flink运行模型</h2><p><img src=\"https://tva1.sinaimg.cn/large/007S8ZIlly1gj7lszqn0xj30jg04i74i.jpg\" alt=\"runtime\"><br>以上为 Flink 的运行模型，Flink 的程序主要由三部分构成，分别为 Source、 Transformation、Sink。DataSource 主要负责数据的读取，Transformation 主要负责对 属于的转换操作，Sink 负责最终数据的输出。</p>\n<p>每个 Flink 程序都包含以下的若干流程:</p>\n<ol>\n<li>获得一个执行环境;(Execution Environment)</li>\n<li>加载/创建初始数据;(Source)</li>\n<li>指定转换这些数据;(Transformation)</li>\n<li>指定放置计算结果的位置;(Sink)</li>\n<li>触发程序执行</li>\n</ol>\n<p>如下图所示:</p>\n<a id=\"more\"></a>\n<p><img src=\"https://tva1.sinaimg.cn/large/007S8ZIlly1gj7ls5f2oej30hl0dswfz.jpg\" alt=\"stream dataflow\"></p>\n<h2 id=\"Enviroment\"><a href=\"#Enviroment\" class=\"headerlink\" title=\"Enviroment\"></a>Enviroment</h2><p><strong>执行环境 StreamExecutionEnvironment 是所有 Flink 程序的基础。</strong></p>\n<p>创建一个执行环境，表示当前执行程序的上下文。</p>\n<ul>\n<li>如果程序独立调用, 如IDE中Run, 返回本地执行环境</li>\n<li>如果提交到集群, 则返回此集群的执行环境</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Source\"><a href=\"#Source\" class=\"headerlink\" title=\"Source\"></a>Source</h2><p>数据源.</p>\n<ul>\n<li><p>内置的数据源: 基于File, Socket, Collection等.</p>\n</li>\n<li><p>addSource, 自定义数据源, 官方提供了常用的kafka, rabbitmq等, 也可以自己开发</p>\n</li>\n</ul>\n<p>eg: <code>env.addSource(new FlinkKafkaConsumer010&lt;&gt;(...))</code></p>\n<h2 id=\"Sink\"><a href=\"#Sink\" class=\"headerlink\" title=\"Sink\"></a>Sink</h2><p>Data Sinks消费DataStreams中的数据, 并且输出到file, socket, 外部系统中.</p>\n<ul>\n<li>内置可以输出到txt, csv, socket, 直接打印等</li>\n<li>addSink - 扩展sink方法, 通过connectors消费到外部系统</li>\n</ul>\n<h2 id=\"Transformations\"><a href=\"#Transformations\" class=\"headerlink\" title=\"Transformations\"></a>Transformations</h2><p>DataStream API的转换分为四类：</p>\n<ol>\n<li><p>作用于单个事件的基本转换</p>\n</li>\n<li><p>针对相同键值事件的KeyedStream转换</p>\n</li>\n<li><p>将多条数据流合并为一条，或将一条数据流拆分为多条流的转换</p>\n</li>\n<li><p>对流中的事件进行重新组织的分发转换</p>\n</li>\n</ol>\n<p>Basic Transformations</p>\n<ul>\n<li>Map<br>  对整个DataStream做一一对应的映射, 即每一个元素产生一个输出元素。</li>\n<li>Filter, 过滤</li>\n<li>FlatMap<br>  对整个DataStream做一对多的映射， 即每一个元素可以产生多个（可以是一个）输出元素。</li>\n</ul>\n<p>KeyedStream Transformations</p>\n<ul>\n<li>KeyBy<br>  对输入DataStream分区， 即相同key的元素分到同一分区。基于key对流(内部使用hash函数)进行分区。</li>\n<li>Aggregations<br>  聚合操作,如min, max, sum等。</li>\n<li>Reduce<br>  根据多个元素生成一个元素。返回单个结果值。</li>\n</ul>\n<p>Multistream Transformation，多流转换</p>\n<ul>\n<li>Union, 组合流</li>\n<li>Connect, coMap, coFlatMap</li>\n<li>Split &amp; select, split拆分流, select从拆分流中选择特定流</li>\n</ul>\n<p>Distribution Transformation</p>\n<ul>\n<li>Random<br>  均匀分布分区</li>\n<li>Round-Robin<br>  轮询分区</li>\n<li>Rescale<br>  可伸缩分区</li>\n<li>Broadcast<br>  广播分区</li>\n<li>Rebanlance<br>  负载均衡分区</li>\n<li>Global<br>  global()方法将输入流中的所有事件发往下游算子的第一个并行任务。</li>\n<li>Custom<br>  用户程序自定义分区</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"Flink运行模型\"><a href=\"#Flink运行模型\" class=\"headerlink\" title=\"Flink运行模型\"></a>Flink运行模型</h2><p><img src=\"https://tva1.sinaimg.cn/large/007S8ZIlly1gj7lszqn0xj30jg04i74i.jpg\" alt=\"runtime\"><br>以上为 Flink 的运行模型，Flink 的程序主要由三部分构成，分别为 Source、 Transformation、Sink。DataSource 主要负责数据的读取，Transformation 主要负责对 属于的转换操作，Sink 负责最终数据的输出。</p>\n<p>每个 Flink 程序都包含以下的若干流程:</p>\n<ol>\n<li>获得一个执行环境;(Execution Environment)</li>\n<li>加载/创建初始数据;(Source)</li>\n<li>指定转换这些数据;(Transformation)</li>\n<li>指定放置计算结果的位置;(Sink)</li>\n<li>触发程序执行</li>\n</ol>\n<p>如下图所示:</p>","more":"<p><img src=\"https://tva1.sinaimg.cn/large/007S8ZIlly1gj7ls5f2oej30hl0dswfz.jpg\" alt=\"stream dataflow\"></p>\n<h2 id=\"Enviroment\"><a href=\"#Enviroment\" class=\"headerlink\" title=\"Enviroment\"></a>Enviroment</h2><p><strong>执行环境 StreamExecutionEnvironment 是所有 Flink 程序的基础。</strong></p>\n<p>创建一个执行环境，表示当前执行程序的上下文。</p>\n<ul>\n<li>如果程序独立调用, 如IDE中Run, 返回本地执行环境</li>\n<li>如果提交到集群, 则返回此集群的执行环境</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Source\"><a href=\"#Source\" class=\"headerlink\" title=\"Source\"></a>Source</h2><p>数据源.</p>\n<ul>\n<li><p>内置的数据源: 基于File, Socket, Collection等.</p>\n</li>\n<li><p>addSource, 自定义数据源, 官方提供了常用的kafka, rabbitmq等, 也可以自己开发</p>\n</li>\n</ul>\n<p>eg: <code>env.addSource(new FlinkKafkaConsumer010&lt;&gt;(...))</code></p>\n<h2 id=\"Sink\"><a href=\"#Sink\" class=\"headerlink\" title=\"Sink\"></a>Sink</h2><p>Data Sinks消费DataStreams中的数据, 并且输出到file, socket, 外部系统中.</p>\n<ul>\n<li>内置可以输出到txt, csv, socket, 直接打印等</li>\n<li>addSink - 扩展sink方法, 通过connectors消费到外部系统</li>\n</ul>\n<h2 id=\"Transformations\"><a href=\"#Transformations\" class=\"headerlink\" title=\"Transformations\"></a>Transformations</h2><p>DataStream API的转换分为四类：</p>\n<ol>\n<li><p>作用于单个事件的基本转换</p>\n</li>\n<li><p>针对相同键值事件的KeyedStream转换</p>\n</li>\n<li><p>将多条数据流合并为一条，或将一条数据流拆分为多条流的转换</p>\n</li>\n<li><p>对流中的事件进行重新组织的分发转换</p>\n</li>\n</ol>\n<p>Basic Transformations</p>\n<ul>\n<li>Map<br>  对整个DataStream做一一对应的映射, 即每一个元素产生一个输出元素。</li>\n<li>Filter, 过滤</li>\n<li>FlatMap<br>  对整个DataStream做一对多的映射， 即每一个元素可以产生多个（可以是一个）输出元素。</li>\n</ul>\n<p>KeyedStream Transformations</p>\n<ul>\n<li>KeyBy<br>  对输入DataStream分区， 即相同key的元素分到同一分区。基于key对流(内部使用hash函数)进行分区。</li>\n<li>Aggregations<br>  聚合操作,如min, max, sum等。</li>\n<li>Reduce<br>  根据多个元素生成一个元素。返回单个结果值。</li>\n</ul>\n<p>Multistream Transformation，多流转换</p>\n<ul>\n<li>Union, 组合流</li>\n<li>Connect, coMap, coFlatMap</li>\n<li>Split &amp; select, split拆分流, select从拆分流中选择特定流</li>\n</ul>\n<p>Distribution Transformation</p>\n<ul>\n<li>Random<br>  均匀分布分区</li>\n<li>Round-Robin<br>  轮询分区</li>\n<li>Rescale<br>  可伸缩分区</li>\n<li>Broadcast<br>  广播分区</li>\n<li>Rebanlance<br>  负载均衡分区</li>\n<li>Global<br>  global()方法将输入流中的所有事件发往下游算子的第一个并行任务。</li>\n<li>Custom<br>  用户程序自定义分区</li>\n</ul>"},{"title":"数据收集(1)-Flume","date":"2020-05-08T08:20:58.000Z","_content":"## 一. 背景\n\n日志收集面临诸多难题：\n\n- 数据源种类繁多： 各服务产生日志格式不同，产生的方式也不同（本地文件，HTTP远程发送等）\n- 数据源是物理分布的： 日志是在分布式机器上，甚至跨机房\n- 流式的、不间断产生： 有些日志需要实时或近实时收集到，以供后端分析挖掘\n- 对可靠性有一定要求\n<!--more-->\n## 二. Flume简介\n\n### Flume OG\n\n- Flume是由Cloudera公司开源的，一种分布式的高可靠的中间件。\n- 能够对不同数据源的海量日志进行高效收集、聚合、移动，最后存储到后端存储系统中。\n\n### Flume NG\n\n- `Flume OG` (Original Generation)， 对应Flume 0.9.x及之前版本，已弃用， 看到相关帖子可以跳过了。\n- `Flume NG` (Next/New Generation)，对应Flume 1.x系列版本，目前应用广泛。\n\n去掉了中心化组件master及协调组件Zookeeper。\n\n## 三. 基础概念\n\nFlume的数据流是通过一系列称为**Agent**的组件构成的。\n\n![基础概念](/images/flume/flume01.png)\n\n一个Agent可从客户端（或者前一个Agent），经过拦截器（可选）、路由等操作后，传递给下一个或多个Agent，直到抵达指定的目标系统。\n\n### Event\n\nFlume将数据流水线中传递的数据称为 Event.\n\nEvent是Flume的基本数据单位.\n\n每个Event由以下两部分组成：\n\n- 头部 —— 一系列key:value对，可用于数据路由\n- 字节数组 ——封装了实际要传递的数据内容， 通常使用Avro,Thrift,Protobuf等对象序列化而成\n\nEvent可由专门的Client生成，Client将要发送的数据封装成Event对象，并调用Flume提供的SDK发送给Agent.\n\n### Agent组件构成\n\nAgent内存主要由三个组件构成，分别是Source, Channel 和 Sink.\n\n> Sink做动词时翻译为下沉， 做名词时翻译为 **水槽，水池，沟渠**.\n一目了然，数据像水流(封装为Event)，有源头(Source)，有管道(Channel)，最终通过沟渠(Sink)汇入湖海(HDFS，Hbase等存储)。\n当然Agent的Sink(沟渠)也可以将Event（水流）发送到另一个Agent的Source(水源)。\n\n- Source\n\nFlume数据流中接收Event的组件。\n\n通常从Client程序或者上一个Agent的Sink接收数据，并写入一个或多个Channel。\n\nFlume提供了很多Source实现：\n\n来自网络:\n\n- `Avro/Thrift Source`，接收不同RPC客户端发送的数据\n- `Kafka Source`\n- `Syslog Source, TCP/UDP`\n- `HTTP Source`\n\n    ...\n\n来自文件\n\n- `Exec Source`，执行指定Shell，并从标准输出中获取数据。如“tail -f xxx.log”。容错性很差\n- `Spooling Directory Source` ,监控目录池下文件变化，并将新文件近实时传入Channel。但是文件拷贝到目录下不能修改，目录下不能包含子目录。\n- `Taildir Source` , 实时监控，实时读取新增数据，断点续传\n\n    ...\n\n- Channel\n\n缓存区，暂存Source写入的Event，直到被 Sink 发送出去。\n\n平衡Source和Sink之间的速度差异：\n\n如果Sink处理吞吐量 < Source发送吞吐量\n\n目前Flume主要有以下几种Channel实现：\n\n- `Memory Channel`，内存中缓存Event，性能高，但断电或者内存不足时有问题\n- `File Channel`，磁盘文件中缓存，性能有所下降(建议File Channel目录跟日志目录在不同磁盘上, 提高效率)\n- `JDBC Channel`，适用于对故障恢复要求极高的场景\n- `Kafka Channel`\n\n    ...\n\n- Sink\n\n接收Channel数据，并发送给下一个Agent的Source，或者发送给存储系统。\n\n- `HDFS Sink`\n- `HBase Sink`，支持同步，异步两种写入方式\n- `Hive Sink`\n- `ElasticSearchSink/MorphlineSolrSink`，写入ES，Solr\n- `Kafaka Sink`\n- `Logger Sink`\n- `Http Sink`\n\n  ...\n\n## 四、高级组件\n\n为了方便用户更灵活控制数据流，Flume还允许用户设置其它组件：\n\n- Interceptor\n\n![interceptor](/images/flume/flume02.png)\n\nInterceptor组件作用在Source和Channel之间, 允许修改或丢弃传输过程中的Event.\n\n校验Event数据格式, 给Event增加header(默认只有message).\n\n需要实现 `org.apache.flume.interceptor.Interceptor`接口。\n\n可配置多个Interceptor，配置声明的顺序就是执行顺序。\n\n\"preserveExisting\"为true时, 若header已存在, 则不替换\n\n- `Timestamp Interceptor`，\"timestamp\": 当前时间\n- `Host Interceptor`, \"host\": agent所在IP;\n- `Static Interceptor`，增加固定的键值对\n- `Remove Header Interceptor`\n- `UUID Interceptor`\n- `Regx Filtering Interceptor`\n\n    ...\n\n- Channel Selector\n\nChannel Selector允许Source选择一个或多个符合条件的Channel，并将Event写入Channel.\n\n- `Replicating Channel Selector`(default)， 将相同数据导入多个Channel中\n- `Multiplexing Channel Selector`，根据Event header值动态路由\n- `Custom Channel Selector`，用户自定义\n\n- Sink Processor\n\n`Sink Group`：Flume允许将多个Sink组装在一起形成一个逻辑实体。\n\nSink Processor在 Sink Group基础上提供负载均衡以及容错的功能。\n\n- `Default Sink Processor`\n- `Failover Sink Processor`\n- `Load Balancing Sink Processor`，目前支持轮询和随机\n- `Custom Sink Processor`\n\n## 五、Flume的特性\n\n### 可靠性保证\n\n当节点出现故障时，日志能够被传送到其他节点上而不会丢失。Flume提供了三种级别的可靠性保障，从强到弱依次分别为：\n\n- end-to-end：收到数据agent首先将event写到磁盘上，当数据传送成功后，再删除；如果数据发送失败，可以重新发送。\n- Store on failure：这也是scribe采用的策略，当数据接收方crash时，将数据写到本地，待恢复后，继续发送\n- Besteffort：数据发送到接收方后，不会进行确认\n\n### 事务\n\nFlume 使用两个独立的事务:\n\n- Put事务, 负责Source → Channel的Event传递\n    1. doPut: 数据写入临时缓冲区putList\n    2. doCommit: 检查Channel内存队列是否足够合并\n    3. doRollback: channel内存队列空间不足, 回滚数据\n- Take事务, 负责 Channel → Sink的Event传递\n    1. doTake : 数据读取到临时缓冲区takeList\n    2. doCommit: 若数据全部发送成功, 则清除takeList\n    3. doRollback: 发送过程中出现任何异常, 将takeList中的数据归还给 Channel内存队列\n\n\n## 六、Flume应用场景\n\n1. 从集群中每个节点都读取日志, 最终汇聚到一个agent并存储\n\n![读取集群日志汇总](/images/flume/flume03.png)\n\n2. Multiplexing(多路) Agent\n\n![多路](/images/flume/flume04.png)\n\n一般有两种使用方式:\n\n- 复制(Replication), 数据复制成相同的多份发送到每个Channel\n- 分流(Multiplexing), Selector根据header的值确定传递到哪一个Channel\n","source":"_posts/bigdata/数据收集-1-Flume.md","raw":"---\ntitle: 数据收集(1)-Flume\ndate: 2020-05-08 16:20:58\ncategories: 读书笔记\ntags:\n- 笔记\n- Flume\n---\n## 一. 背景\n\n日志收集面临诸多难题：\n\n- 数据源种类繁多： 各服务产生日志格式不同，产生的方式也不同（本地文件，HTTP远程发送等）\n- 数据源是物理分布的： 日志是在分布式机器上，甚至跨机房\n- 流式的、不间断产生： 有些日志需要实时或近实时收集到，以供后端分析挖掘\n- 对可靠性有一定要求\n<!--more-->\n## 二. Flume简介\n\n### Flume OG\n\n- Flume是由Cloudera公司开源的，一种分布式的高可靠的中间件。\n- 能够对不同数据源的海量日志进行高效收集、聚合、移动，最后存储到后端存储系统中。\n\n### Flume NG\n\n- `Flume OG` (Original Generation)， 对应Flume 0.9.x及之前版本，已弃用， 看到相关帖子可以跳过了。\n- `Flume NG` (Next/New Generation)，对应Flume 1.x系列版本，目前应用广泛。\n\n去掉了中心化组件master及协调组件Zookeeper。\n\n## 三. 基础概念\n\nFlume的数据流是通过一系列称为**Agent**的组件构成的。\n\n![基础概念](/images/flume/flume01.png)\n\n一个Agent可从客户端（或者前一个Agent），经过拦截器（可选）、路由等操作后，传递给下一个或多个Agent，直到抵达指定的目标系统。\n\n### Event\n\nFlume将数据流水线中传递的数据称为 Event.\n\nEvent是Flume的基本数据单位.\n\n每个Event由以下两部分组成：\n\n- 头部 —— 一系列key:value对，可用于数据路由\n- 字节数组 ——封装了实际要传递的数据内容， 通常使用Avro,Thrift,Protobuf等对象序列化而成\n\nEvent可由专门的Client生成，Client将要发送的数据封装成Event对象，并调用Flume提供的SDK发送给Agent.\n\n### Agent组件构成\n\nAgent内存主要由三个组件构成，分别是Source, Channel 和 Sink.\n\n> Sink做动词时翻译为下沉， 做名词时翻译为 **水槽，水池，沟渠**.\n一目了然，数据像水流(封装为Event)，有源头(Source)，有管道(Channel)，最终通过沟渠(Sink)汇入湖海(HDFS，Hbase等存储)。\n当然Agent的Sink(沟渠)也可以将Event（水流）发送到另一个Agent的Source(水源)。\n\n- Source\n\nFlume数据流中接收Event的组件。\n\n通常从Client程序或者上一个Agent的Sink接收数据，并写入一个或多个Channel。\n\nFlume提供了很多Source实现：\n\n来自网络:\n\n- `Avro/Thrift Source`，接收不同RPC客户端发送的数据\n- `Kafka Source`\n- `Syslog Source, TCP/UDP`\n- `HTTP Source`\n\n    ...\n\n来自文件\n\n- `Exec Source`，执行指定Shell，并从标准输出中获取数据。如“tail -f xxx.log”。容错性很差\n- `Spooling Directory Source` ,监控目录池下文件变化，并将新文件近实时传入Channel。但是文件拷贝到目录下不能修改，目录下不能包含子目录。\n- `Taildir Source` , 实时监控，实时读取新增数据，断点续传\n\n    ...\n\n- Channel\n\n缓存区，暂存Source写入的Event，直到被 Sink 发送出去。\n\n平衡Source和Sink之间的速度差异：\n\n如果Sink处理吞吐量 < Source发送吞吐量\n\n目前Flume主要有以下几种Channel实现：\n\n- `Memory Channel`，内存中缓存Event，性能高，但断电或者内存不足时有问题\n- `File Channel`，磁盘文件中缓存，性能有所下降(建议File Channel目录跟日志目录在不同磁盘上, 提高效率)\n- `JDBC Channel`，适用于对故障恢复要求极高的场景\n- `Kafka Channel`\n\n    ...\n\n- Sink\n\n接收Channel数据，并发送给下一个Agent的Source，或者发送给存储系统。\n\n- `HDFS Sink`\n- `HBase Sink`，支持同步，异步两种写入方式\n- `Hive Sink`\n- `ElasticSearchSink/MorphlineSolrSink`，写入ES，Solr\n- `Kafaka Sink`\n- `Logger Sink`\n- `Http Sink`\n\n  ...\n\n## 四、高级组件\n\n为了方便用户更灵活控制数据流，Flume还允许用户设置其它组件：\n\n- Interceptor\n\n![interceptor](/images/flume/flume02.png)\n\nInterceptor组件作用在Source和Channel之间, 允许修改或丢弃传输过程中的Event.\n\n校验Event数据格式, 给Event增加header(默认只有message).\n\n需要实现 `org.apache.flume.interceptor.Interceptor`接口。\n\n可配置多个Interceptor，配置声明的顺序就是执行顺序。\n\n\"preserveExisting\"为true时, 若header已存在, 则不替换\n\n- `Timestamp Interceptor`，\"timestamp\": 当前时间\n- `Host Interceptor`, \"host\": agent所在IP;\n- `Static Interceptor`，增加固定的键值对\n- `Remove Header Interceptor`\n- `UUID Interceptor`\n- `Regx Filtering Interceptor`\n\n    ...\n\n- Channel Selector\n\nChannel Selector允许Source选择一个或多个符合条件的Channel，并将Event写入Channel.\n\n- `Replicating Channel Selector`(default)， 将相同数据导入多个Channel中\n- `Multiplexing Channel Selector`，根据Event header值动态路由\n- `Custom Channel Selector`，用户自定义\n\n- Sink Processor\n\n`Sink Group`：Flume允许将多个Sink组装在一起形成一个逻辑实体。\n\nSink Processor在 Sink Group基础上提供负载均衡以及容错的功能。\n\n- `Default Sink Processor`\n- `Failover Sink Processor`\n- `Load Balancing Sink Processor`，目前支持轮询和随机\n- `Custom Sink Processor`\n\n## 五、Flume的特性\n\n### 可靠性保证\n\n当节点出现故障时，日志能够被传送到其他节点上而不会丢失。Flume提供了三种级别的可靠性保障，从强到弱依次分别为：\n\n- end-to-end：收到数据agent首先将event写到磁盘上，当数据传送成功后，再删除；如果数据发送失败，可以重新发送。\n- Store on failure：这也是scribe采用的策略，当数据接收方crash时，将数据写到本地，待恢复后，继续发送\n- Besteffort：数据发送到接收方后，不会进行确认\n\n### 事务\n\nFlume 使用两个独立的事务:\n\n- Put事务, 负责Source → Channel的Event传递\n    1. doPut: 数据写入临时缓冲区putList\n    2. doCommit: 检查Channel内存队列是否足够合并\n    3. doRollback: channel内存队列空间不足, 回滚数据\n- Take事务, 负责 Channel → Sink的Event传递\n    1. doTake : 数据读取到临时缓冲区takeList\n    2. doCommit: 若数据全部发送成功, 则清除takeList\n    3. doRollback: 发送过程中出现任何异常, 将takeList中的数据归还给 Channel内存队列\n\n\n## 六、Flume应用场景\n\n1. 从集群中每个节点都读取日志, 最终汇聚到一个agent并存储\n\n![读取集群日志汇总](/images/flume/flume03.png)\n\n2. Multiplexing(多路) Agent\n\n![多路](/images/flume/flume04.png)\n\n一般有两种使用方式:\n\n- 复制(Replication), 数据复制成相同的多份发送到每个Channel\n- 分流(Multiplexing), Selector根据header的值确定传递到哪一个Channel\n","slug":"bigdata/数据收集-1-Flume","published":1,"updated":"2020-10-27T08:08:15.936Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckio9dweu003qk8nec7nhe0x2","content":"<h2 id=\"一-背景\"><a href=\"#一-背景\" class=\"headerlink\" title=\"一. 背景\"></a>一. 背景</h2><p>日志收集面临诸多难题：</p>\n<ul>\n<li>数据源种类繁多： 各服务产生日志格式不同，产生的方式也不同（本地文件，HTTP远程发送等）</li>\n<li>数据源是物理分布的： 日志是在分布式机器上，甚至跨机房</li>\n<li>流式的、不间断产生： 有些日志需要实时或近实时收集到，以供后端分析挖掘</li>\n<li>对可靠性有一定要求<a id=\"more\"></a>\n<h2 id=\"二-Flume简介\"><a href=\"#二-Flume简介\" class=\"headerlink\" title=\"二. Flume简介\"></a>二. Flume简介</h2></li>\n</ul>\n<h3 id=\"Flume-OG\"><a href=\"#Flume-OG\" class=\"headerlink\" title=\"Flume OG\"></a>Flume OG</h3><ul>\n<li>Flume是由Cloudera公司开源的，一种分布式的高可靠的中间件。</li>\n<li>能够对不同数据源的海量日志进行高效收集、聚合、移动，最后存储到后端存储系统中。</li>\n</ul>\n<h3 id=\"Flume-NG\"><a href=\"#Flume-NG\" class=\"headerlink\" title=\"Flume NG\"></a>Flume NG</h3><ul>\n<li><code>Flume OG</code> (Original Generation)， 对应Flume 0.9.x及之前版本，已弃用， 看到相关帖子可以跳过了。</li>\n<li><code>Flume NG</code> (Next/New Generation)，对应Flume 1.x系列版本，目前应用广泛。</li>\n</ul>\n<p>去掉了中心化组件master及协调组件Zookeeper。</p>\n<h2 id=\"三-基础概念\"><a href=\"#三-基础概念\" class=\"headerlink\" title=\"三. 基础概念\"></a>三. 基础概念</h2><p>Flume的数据流是通过一系列称为<strong>Agent</strong>的组件构成的。</p>\n<p><img src=\"/images/flume/flume01.png\" alt=\"基础概念\"></p>\n<p>一个Agent可从客户端（或者前一个Agent），经过拦截器（可选）、路由等操作后，传递给下一个或多个Agent，直到抵达指定的目标系统。</p>\n<h3 id=\"Event\"><a href=\"#Event\" class=\"headerlink\" title=\"Event\"></a>Event</h3><p>Flume将数据流水线中传递的数据称为 Event.</p>\n<p>Event是Flume的基本数据单位.</p>\n<p>每个Event由以下两部分组成：</p>\n<ul>\n<li>头部 —— 一系列key:value对，可用于数据路由</li>\n<li>字节数组 ——封装了实际要传递的数据内容， 通常使用Avro,Thrift,Protobuf等对象序列化而成</li>\n</ul>\n<p>Event可由专门的Client生成，Client将要发送的数据封装成Event对象，并调用Flume提供的SDK发送给Agent.</p>\n<h3 id=\"Agent组件构成\"><a href=\"#Agent组件构成\" class=\"headerlink\" title=\"Agent组件构成\"></a>Agent组件构成</h3><p>Agent内存主要由三个组件构成，分别是Source, Channel 和 Sink.</p>\n<blockquote>\n<p>Sink做动词时翻译为下沉， 做名词时翻译为 <strong>水槽，水池，沟渠</strong>.<br>一目了然，数据像水流(封装为Event)，有源头(Source)，有管道(Channel)，最终通过沟渠(Sink)汇入湖海(HDFS，Hbase等存储)。<br>当然Agent的Sink(沟渠)也可以将Event（水流）发送到另一个Agent的Source(水源)。</p>\n</blockquote>\n<ul>\n<li>Source</li>\n</ul>\n<p>Flume数据流中接收Event的组件。</p>\n<p>通常从Client程序或者上一个Agent的Sink接收数据，并写入一个或多个Channel。</p>\n<p>Flume提供了很多Source实现：</p>\n<p>来自网络:</p>\n<ul>\n<li><p><code>Avro/Thrift Source</code>，接收不同RPC客户端发送的数据</p>\n</li>\n<li><p><code>Kafka Source</code></p>\n</li>\n<li><p><code>Syslog Source, TCP/UDP</code></p>\n</li>\n<li><p><code>HTTP Source</code></p>\n<p>  …</p>\n</li>\n</ul>\n<p>来自文件</p>\n<ul>\n<li><p><code>Exec Source</code>，执行指定Shell，并从标准输出中获取数据。如“tail -f xxx.log”。容错性很差</p>\n</li>\n<li><p><code>Spooling Directory Source</code> ,监控目录池下文件变化，并将新文件近实时传入Channel。但是文件拷贝到目录下不能修改，目录下不能包含子目录。</p>\n</li>\n<li><p><code>Taildir Source</code> , 实时监控，实时读取新增数据，断点续传</p>\n<p>  …</p>\n</li>\n<li><p>Channel</p>\n</li>\n</ul>\n<p>缓存区，暂存Source写入的Event，直到被 Sink 发送出去。</p>\n<p>平衡Source和Sink之间的速度差异：</p>\n<p>如果Sink处理吞吐量 &lt; Source发送吞吐量</p>\n<p>目前Flume主要有以下几种Channel实现：</p>\n<ul>\n<li><p><code>Memory Channel</code>，内存中缓存Event，性能高，但断电或者内存不足时有问题</p>\n</li>\n<li><p><code>File Channel</code>，磁盘文件中缓存，性能有所下降(建议File Channel目录跟日志目录在不同磁盘上, 提高效率)</p>\n</li>\n<li><p><code>JDBC Channel</code>，适用于对故障恢复要求极高的场景</p>\n</li>\n<li><p><code>Kafka Channel</code></p>\n<p>  …</p>\n</li>\n<li><p>Sink</p>\n</li>\n</ul>\n<p>接收Channel数据，并发送给下一个Agent的Source，或者发送给存储系统。</p>\n<ul>\n<li><p><code>HDFS Sink</code></p>\n</li>\n<li><p><code>HBase Sink</code>，支持同步，异步两种写入方式</p>\n</li>\n<li><p><code>Hive Sink</code></p>\n</li>\n<li><p><code>ElasticSearchSink/MorphlineSolrSink</code>，写入ES，Solr</p>\n</li>\n<li><p><code>Kafaka Sink</code></p>\n</li>\n<li><p><code>Logger Sink</code></p>\n</li>\n<li><p><code>Http Sink</code></p>\n<p>…</p>\n</li>\n</ul>\n<h2 id=\"四、高级组件\"><a href=\"#四、高级组件\" class=\"headerlink\" title=\"四、高级组件\"></a>四、高级组件</h2><p>为了方便用户更灵活控制数据流，Flume还允许用户设置其它组件：</p>\n<ul>\n<li>Interceptor</li>\n</ul>\n<p><img src=\"/images/flume/flume02.png\" alt=\"interceptor\"></p>\n<p>Interceptor组件作用在Source和Channel之间, 允许修改或丢弃传输过程中的Event.</p>\n<p>校验Event数据格式, 给Event增加header(默认只有message).</p>\n<p>需要实现 <code>org.apache.flume.interceptor.Interceptor</code>接口。</p>\n<p>可配置多个Interceptor，配置声明的顺序就是执行顺序。</p>\n<p>“preserveExisting”为true时, 若header已存在, 则不替换</p>\n<ul>\n<li><p><code>Timestamp Interceptor</code>，”timestamp”: 当前时间</p>\n</li>\n<li><p><code>Host Interceptor</code>, “host”: agent所在IP;</p>\n</li>\n<li><p><code>Static Interceptor</code>，增加固定的键值对</p>\n</li>\n<li><p><code>Remove Header Interceptor</code></p>\n</li>\n<li><p><code>UUID Interceptor</code></p>\n</li>\n<li><p><code>Regx Filtering Interceptor</code></p>\n<p>  …</p>\n</li>\n<li><p>Channel Selector</p>\n</li>\n</ul>\n<p>Channel Selector允许Source选择一个或多个符合条件的Channel，并将Event写入Channel.</p>\n<ul>\n<li><p><code>Replicating Channel Selector</code>(default)， 将相同数据导入多个Channel中</p>\n</li>\n<li><p><code>Multiplexing Channel Selector</code>，根据Event header值动态路由</p>\n</li>\n<li><p><code>Custom Channel Selector</code>，用户自定义</p>\n</li>\n<li><p>Sink Processor</p>\n</li>\n</ul>\n<p><code>Sink Group</code>：Flume允许将多个Sink组装在一起形成一个逻辑实体。</p>\n<p>Sink Processor在 Sink Group基础上提供负载均衡以及容错的功能。</p>\n<ul>\n<li><code>Default Sink Processor</code></li>\n<li><code>Failover Sink Processor</code></li>\n<li><code>Load Balancing Sink Processor</code>，目前支持轮询和随机</li>\n<li><code>Custom Sink Processor</code></li>\n</ul>\n<h2 id=\"五、Flume的特性\"><a href=\"#五、Flume的特性\" class=\"headerlink\" title=\"五、Flume的特性\"></a>五、Flume的特性</h2><h3 id=\"可靠性保证\"><a href=\"#可靠性保证\" class=\"headerlink\" title=\"可靠性保证\"></a>可靠性保证</h3><p>当节点出现故障时，日志能够被传送到其他节点上而不会丢失。Flume提供了三种级别的可靠性保障，从强到弱依次分别为：</p>\n<ul>\n<li>end-to-end：收到数据agent首先将event写到磁盘上，当数据传送成功后，再删除；如果数据发送失败，可以重新发送。</li>\n<li>Store on failure：这也是scribe采用的策略，当数据接收方crash时，将数据写到本地，待恢复后，继续发送</li>\n<li>Besteffort：数据发送到接收方后，不会进行确认</li>\n</ul>\n<h3 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h3><p>Flume 使用两个独立的事务:</p>\n<ul>\n<li>Put事务, 负责Source → Channel的Event传递<ol>\n<li>doPut: 数据写入临时缓冲区putList</li>\n<li>doCommit: 检查Channel内存队列是否足够合并</li>\n<li>doRollback: channel内存队列空间不足, 回滚数据</li>\n</ol>\n</li>\n<li>Take事务, 负责 Channel → Sink的Event传递<ol>\n<li>doTake : 数据读取到临时缓冲区takeList</li>\n<li>doCommit: 若数据全部发送成功, 则清除takeList</li>\n<li>doRollback: 发送过程中出现任何异常, 将takeList中的数据归还给 Channel内存队列</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"六、Flume应用场景\"><a href=\"#六、Flume应用场景\" class=\"headerlink\" title=\"六、Flume应用场景\"></a>六、Flume应用场景</h2><ol>\n<li>从集群中每个节点都读取日志, 最终汇聚到一个agent并存储</li>\n</ol>\n<p><img src=\"/images/flume/flume03.png\" alt=\"读取集群日志汇总\"></p>\n<ol start=\"2\">\n<li>Multiplexing(多路) Agent</li>\n</ol>\n<p><img src=\"/images/flume/flume04.png\" alt=\"多路\"></p>\n<p>一般有两种使用方式:</p>\n<ul>\n<li>复制(Replication), 数据复制成相同的多份发送到每个Channel</li>\n<li>分流(Multiplexing), Selector根据header的值确定传递到哪一个Channel</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"一-背景\"><a href=\"#一-背景\" class=\"headerlink\" title=\"一. 背景\"></a>一. 背景</h2><p>日志收集面临诸多难题：</p>\n<ul>\n<li>数据源种类繁多： 各服务产生日志格式不同，产生的方式也不同（本地文件，HTTP远程发送等）</li>\n<li>数据源是物理分布的： 日志是在分布式机器上，甚至跨机房</li>\n<li>流式的、不间断产生： 有些日志需要实时或近实时收集到，以供后端分析挖掘</li>\n<li>对可靠性有一定要求","more":"<h2 id=\"二-Flume简介\"><a href=\"#二-Flume简介\" class=\"headerlink\" title=\"二. Flume简介\"></a>二. Flume简介</h2></li>\n</ul>\n<h3 id=\"Flume-OG\"><a href=\"#Flume-OG\" class=\"headerlink\" title=\"Flume OG\"></a>Flume OG</h3><ul>\n<li>Flume是由Cloudera公司开源的，一种分布式的高可靠的中间件。</li>\n<li>能够对不同数据源的海量日志进行高效收集、聚合、移动，最后存储到后端存储系统中。</li>\n</ul>\n<h3 id=\"Flume-NG\"><a href=\"#Flume-NG\" class=\"headerlink\" title=\"Flume NG\"></a>Flume NG</h3><ul>\n<li><code>Flume OG</code> (Original Generation)， 对应Flume 0.9.x及之前版本，已弃用， 看到相关帖子可以跳过了。</li>\n<li><code>Flume NG</code> (Next/New Generation)，对应Flume 1.x系列版本，目前应用广泛。</li>\n</ul>\n<p>去掉了中心化组件master及协调组件Zookeeper。</p>\n<h2 id=\"三-基础概念\"><a href=\"#三-基础概念\" class=\"headerlink\" title=\"三. 基础概念\"></a>三. 基础概念</h2><p>Flume的数据流是通过一系列称为<strong>Agent</strong>的组件构成的。</p>\n<p><img src=\"/images/flume/flume01.png\" alt=\"基础概念\"></p>\n<p>一个Agent可从客户端（或者前一个Agent），经过拦截器（可选）、路由等操作后，传递给下一个或多个Agent，直到抵达指定的目标系统。</p>\n<h3 id=\"Event\"><a href=\"#Event\" class=\"headerlink\" title=\"Event\"></a>Event</h3><p>Flume将数据流水线中传递的数据称为 Event.</p>\n<p>Event是Flume的基本数据单位.</p>\n<p>每个Event由以下两部分组成：</p>\n<ul>\n<li>头部 —— 一系列key:value对，可用于数据路由</li>\n<li>字节数组 ——封装了实际要传递的数据内容， 通常使用Avro,Thrift,Protobuf等对象序列化而成</li>\n</ul>\n<p>Event可由专门的Client生成，Client将要发送的数据封装成Event对象，并调用Flume提供的SDK发送给Agent.</p>\n<h3 id=\"Agent组件构成\"><a href=\"#Agent组件构成\" class=\"headerlink\" title=\"Agent组件构成\"></a>Agent组件构成</h3><p>Agent内存主要由三个组件构成，分别是Source, Channel 和 Sink.</p>\n<blockquote>\n<p>Sink做动词时翻译为下沉， 做名词时翻译为 <strong>水槽，水池，沟渠</strong>.<br>一目了然，数据像水流(封装为Event)，有源头(Source)，有管道(Channel)，最终通过沟渠(Sink)汇入湖海(HDFS，Hbase等存储)。<br>当然Agent的Sink(沟渠)也可以将Event（水流）发送到另一个Agent的Source(水源)。</p>\n</blockquote>\n<ul>\n<li>Source</li>\n</ul>\n<p>Flume数据流中接收Event的组件。</p>\n<p>通常从Client程序或者上一个Agent的Sink接收数据，并写入一个或多个Channel。</p>\n<p>Flume提供了很多Source实现：</p>\n<p>来自网络:</p>\n<ul>\n<li><p><code>Avro/Thrift Source</code>，接收不同RPC客户端发送的数据</p>\n</li>\n<li><p><code>Kafka Source</code></p>\n</li>\n<li><p><code>Syslog Source, TCP/UDP</code></p>\n</li>\n<li><p><code>HTTP Source</code></p>\n<p>  …</p>\n</li>\n</ul>\n<p>来自文件</p>\n<ul>\n<li><p><code>Exec Source</code>，执行指定Shell，并从标准输出中获取数据。如“tail -f xxx.log”。容错性很差</p>\n</li>\n<li><p><code>Spooling Directory Source</code> ,监控目录池下文件变化，并将新文件近实时传入Channel。但是文件拷贝到目录下不能修改，目录下不能包含子目录。</p>\n</li>\n<li><p><code>Taildir Source</code> , 实时监控，实时读取新增数据，断点续传</p>\n<p>  …</p>\n</li>\n<li><p>Channel</p>\n</li>\n</ul>\n<p>缓存区，暂存Source写入的Event，直到被 Sink 发送出去。</p>\n<p>平衡Source和Sink之间的速度差异：</p>\n<p>如果Sink处理吞吐量 &lt; Source发送吞吐量</p>\n<p>目前Flume主要有以下几种Channel实现：</p>\n<ul>\n<li><p><code>Memory Channel</code>，内存中缓存Event，性能高，但断电或者内存不足时有问题</p>\n</li>\n<li><p><code>File Channel</code>，磁盘文件中缓存，性能有所下降(建议File Channel目录跟日志目录在不同磁盘上, 提高效率)</p>\n</li>\n<li><p><code>JDBC Channel</code>，适用于对故障恢复要求极高的场景</p>\n</li>\n<li><p><code>Kafka Channel</code></p>\n<p>  …</p>\n</li>\n<li><p>Sink</p>\n</li>\n</ul>\n<p>接收Channel数据，并发送给下一个Agent的Source，或者发送给存储系统。</p>\n<ul>\n<li><p><code>HDFS Sink</code></p>\n</li>\n<li><p><code>HBase Sink</code>，支持同步，异步两种写入方式</p>\n</li>\n<li><p><code>Hive Sink</code></p>\n</li>\n<li><p><code>ElasticSearchSink/MorphlineSolrSink</code>，写入ES，Solr</p>\n</li>\n<li><p><code>Kafaka Sink</code></p>\n</li>\n<li><p><code>Logger Sink</code></p>\n</li>\n<li><p><code>Http Sink</code></p>\n<p>…</p>\n</li>\n</ul>\n<h2 id=\"四、高级组件\"><a href=\"#四、高级组件\" class=\"headerlink\" title=\"四、高级组件\"></a>四、高级组件</h2><p>为了方便用户更灵活控制数据流，Flume还允许用户设置其它组件：</p>\n<ul>\n<li>Interceptor</li>\n</ul>\n<p><img src=\"/images/flume/flume02.png\" alt=\"interceptor\"></p>\n<p>Interceptor组件作用在Source和Channel之间, 允许修改或丢弃传输过程中的Event.</p>\n<p>校验Event数据格式, 给Event增加header(默认只有message).</p>\n<p>需要实现 <code>org.apache.flume.interceptor.Interceptor</code>接口。</p>\n<p>可配置多个Interceptor，配置声明的顺序就是执行顺序。</p>\n<p>“preserveExisting”为true时, 若header已存在, 则不替换</p>\n<ul>\n<li><p><code>Timestamp Interceptor</code>，”timestamp”: 当前时间</p>\n</li>\n<li><p><code>Host Interceptor</code>, “host”: agent所在IP;</p>\n</li>\n<li><p><code>Static Interceptor</code>，增加固定的键值对</p>\n</li>\n<li><p><code>Remove Header Interceptor</code></p>\n</li>\n<li><p><code>UUID Interceptor</code></p>\n</li>\n<li><p><code>Regx Filtering Interceptor</code></p>\n<p>  …</p>\n</li>\n<li><p>Channel Selector</p>\n</li>\n</ul>\n<p>Channel Selector允许Source选择一个或多个符合条件的Channel，并将Event写入Channel.</p>\n<ul>\n<li><p><code>Replicating Channel Selector</code>(default)， 将相同数据导入多个Channel中</p>\n</li>\n<li><p><code>Multiplexing Channel Selector</code>，根据Event header值动态路由</p>\n</li>\n<li><p><code>Custom Channel Selector</code>，用户自定义</p>\n</li>\n<li><p>Sink Processor</p>\n</li>\n</ul>\n<p><code>Sink Group</code>：Flume允许将多个Sink组装在一起形成一个逻辑实体。</p>\n<p>Sink Processor在 Sink Group基础上提供负载均衡以及容错的功能。</p>\n<ul>\n<li><code>Default Sink Processor</code></li>\n<li><code>Failover Sink Processor</code></li>\n<li><code>Load Balancing Sink Processor</code>，目前支持轮询和随机</li>\n<li><code>Custom Sink Processor</code></li>\n</ul>\n<h2 id=\"五、Flume的特性\"><a href=\"#五、Flume的特性\" class=\"headerlink\" title=\"五、Flume的特性\"></a>五、Flume的特性</h2><h3 id=\"可靠性保证\"><a href=\"#可靠性保证\" class=\"headerlink\" title=\"可靠性保证\"></a>可靠性保证</h3><p>当节点出现故障时，日志能够被传送到其他节点上而不会丢失。Flume提供了三种级别的可靠性保障，从强到弱依次分别为：</p>\n<ul>\n<li>end-to-end：收到数据agent首先将event写到磁盘上，当数据传送成功后，再删除；如果数据发送失败，可以重新发送。</li>\n<li>Store on failure：这也是scribe采用的策略，当数据接收方crash时，将数据写到本地，待恢复后，继续发送</li>\n<li>Besteffort：数据发送到接收方后，不会进行确认</li>\n</ul>\n<h3 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h3><p>Flume 使用两个独立的事务:</p>\n<ul>\n<li>Put事务, 负责Source → Channel的Event传递<ol>\n<li>doPut: 数据写入临时缓冲区putList</li>\n<li>doCommit: 检查Channel内存队列是否足够合并</li>\n<li>doRollback: channel内存队列空间不足, 回滚数据</li>\n</ol>\n</li>\n<li>Take事务, 负责 Channel → Sink的Event传递<ol>\n<li>doTake : 数据读取到临时缓冲区takeList</li>\n<li>doCommit: 若数据全部发送成功, 则清除takeList</li>\n<li>doRollback: 发送过程中出现任何异常, 将takeList中的数据归还给 Channel内存队列</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"六、Flume应用场景\"><a href=\"#六、Flume应用场景\" class=\"headerlink\" title=\"六、Flume应用场景\"></a>六、Flume应用场景</h2><ol>\n<li>从集群中每个节点都读取日志, 最终汇聚到一个agent并存储</li>\n</ol>\n<p><img src=\"/images/flume/flume03.png\" alt=\"读取集群日志汇总\"></p>\n<ol start=\"2\">\n<li>Multiplexing(多路) Agent</li>\n</ol>\n<p><img src=\"/images/flume/flume04.png\" alt=\"多路\"></p>\n<p>一般有两种使用方式:</p>\n<ul>\n<li>复制(Replication), 数据复制成相同的多份发送到每个Channel</li>\n<li>分流(Multiplexing), Selector根据header的值确定传递到哪一个Channel</li>\n</ul>"},{"title":"Flink 4. Connectors","date":"2020-09-17T09:57:04.000Z","_content":"\n### DataStreeam Connector\n\n#### 预定义的Source\n\n* File-based:\n\n```java\nreadTextFile(path)\nreadFile(fileInputFormat, path)\nreadFile(fileInputFormat, path, watchType, interval, pathFilter, typeInfo)\n```\n\n* Socket-based:\n\n```java\nsocketTextStream()\n```\n\n* Collection-based:\n\n```java\nfromCollection(Collection)\nfromCollection(Iterator, Class)\nfromElements(T ...)\nfromParallelCollection(SplittableIterator, Class)\ngenerateSequence(from, to) \n```\n\n* Custom:\n\n```java\naddSource()\n```\n\n#### 预定义的Sink\n\n```java\nwriteAsText() / TextOutputFormat\n\nwriteAsCsv(...) / CsvOutputFormat\n\nprint() / printToErr()\n\nwriteUsingOutputFormat() / FileOutputFormat\n\nwriteToSocket()\n\naddSink()\n```\n\n#### 附带连接器\n\n* Apache Kafka (source/sink)\n* Apache Cassandra (sink)\n* Amazon Kinesis Streams (source/sink)\n* Elasticsearch (sink)\n* FileSystem（包括 Hadoop ） - 仅支持流 (sink)\n* FileSystem（包括 Hadoop ） - 流批统一 (sink)\n* RabbitMQ (source/sink)\n* Apache NiFi (source/sink)\n* Twitter Streaming API (source)\n* Google PubSub (source/sink)\n* JDBC (sink)\n\n#### Apache Bahir 中的连接器\nFlink 还有些一些额外的连接器通过 Apache Bahir 发布, 包括:\n\n* Apache ActiveMQ (source/sink)\n* Apache Flume (sink)\n* Redis (sink)\n* Akka (sink)\n* Netty (source)\n\n#### 连接Flink的其它方法\n\n##### 异步 I/O\n\n使用connector并不是唯一可以使数据进入或者流出Flink的方式。 一种常见的模式是从外部数据库或者 Web 服务查询数据得到初始数据流，然后通过 Map 或者 FlatMap 对初始数据流进行丰富和增强。 Flink 提供了异步 I/O API 来让这个过程更加简单、高效和稳定。\n\n##### 可查询状态（Queryable State Beta）\n当 Flink 应用程序需要向外部存储推送大量数据时会导致 I/O 瓶颈问题出现。在这种场景下，如果对数据的读操作远少于写操作，那么让外部应用从 Flink 拉取所需的数据会是一种更好的方式。 可查询状态 接口可以实现这个功能，该接口允许被 Flink 托管的状态可以被按需查询。\n\n### Table Connnector\n\nTable API和SQL程序，都支持连接并读写外部系统。 对于Table连接器，除了要了解支持的**连接器**， 还应该了解其支持的**表格式**。\n\n#### 连接器\n\n以Flink1.12为例，下面是其Table API & SQL支持的连接器类型。\n\n|Name\t|Version|\tSource|\tSink|\n|---- |----|----|----|\n|Filesystem\t\t    |                   |Bounded and Unbounded Scan,          |Lookup\tStreaming Sink, Batch Sink|\n|Elasticsearch\t  |6.x & 7.x\t        |Not supported\t                      |Streaming Sink, Batch Sink|\n|Apache Kafka\t    |0.10+\t            |Unbounded Scan\t                      |Streaming Sink, Batch Sink|\n|Amazon Kinesis   |           \t\t    |Unbounded Scan\t                      |Streaming Sink|\n|JDBC\t\t          |                   |Bounded Scan, Lookup\t                |Streaming Sink, Batch Sink|\n|Apache HBase\t    |1.4.x & 2.2.x    \t|Bounded Scan, Lookup\t                |Streaming Sink, Batch Sink|\n|Apache Hive\t    |                 \t|Unbounded Scan, Bounded Scan, Lookup\t|Streaming Sink, Batch Sink|\n\n\n#### 格式\n\n表格式是一种存储格式，定义了如何把二进制数据映射到表的列上。\n\n|格式\t          | 支持的连接器\n|----           |----\n|CSV\t          |Apache Kafka, Upsert Kafka, Amazon Kinesis Data Streams, Filesystem\n|JSON\t          |Apache Kafka, Upsert Kafka, Amazon Kinesis Data Streams, Filesystem, Elasticsearch\n|Apache Avro\t  |Apache Kafka, Upsert Kafka, Amazon Kinesis Data Streams, Filesystem\n|Confluent Avro\t|Apache Kafka, Upsert Kafka\n|Debezium CDC\t  |Apache Kafka, Filesystem\n|Canal CDC\t    |Apache Kafka, Filesystem\n|Maxwell CDC\t  |Apache Kafka, Filesystem\n|Apache Parquet\t|Filesystem\n|Apache ORC\t    |Filesystem\n|Raw\t          |Apache Kafka, Upsert Kafka, Amazon Kinesis Data Streams, Filesystem\n\n### Dataset Connector\n\n","source":"_posts/flink/Flink-4-Connectors.md","raw":"---\ntitle: Flink 4. Connectors\ndate: 2020-09-17 17:57:04\ncategories: 流计算\ntags: \n- Flink\n---\n\n### DataStreeam Connector\n\n#### 预定义的Source\n\n* File-based:\n\n```java\nreadTextFile(path)\nreadFile(fileInputFormat, path)\nreadFile(fileInputFormat, path, watchType, interval, pathFilter, typeInfo)\n```\n\n* Socket-based:\n\n```java\nsocketTextStream()\n```\n\n* Collection-based:\n\n```java\nfromCollection(Collection)\nfromCollection(Iterator, Class)\nfromElements(T ...)\nfromParallelCollection(SplittableIterator, Class)\ngenerateSequence(from, to) \n```\n\n* Custom:\n\n```java\naddSource()\n```\n\n#### 预定义的Sink\n\n```java\nwriteAsText() / TextOutputFormat\n\nwriteAsCsv(...) / CsvOutputFormat\n\nprint() / printToErr()\n\nwriteUsingOutputFormat() / FileOutputFormat\n\nwriteToSocket()\n\naddSink()\n```\n\n#### 附带连接器\n\n* Apache Kafka (source/sink)\n* Apache Cassandra (sink)\n* Amazon Kinesis Streams (source/sink)\n* Elasticsearch (sink)\n* FileSystem（包括 Hadoop ） - 仅支持流 (sink)\n* FileSystem（包括 Hadoop ） - 流批统一 (sink)\n* RabbitMQ (source/sink)\n* Apache NiFi (source/sink)\n* Twitter Streaming API (source)\n* Google PubSub (source/sink)\n* JDBC (sink)\n\n#### Apache Bahir 中的连接器\nFlink 还有些一些额外的连接器通过 Apache Bahir 发布, 包括:\n\n* Apache ActiveMQ (source/sink)\n* Apache Flume (sink)\n* Redis (sink)\n* Akka (sink)\n* Netty (source)\n\n#### 连接Flink的其它方法\n\n##### 异步 I/O\n\n使用connector并不是唯一可以使数据进入或者流出Flink的方式。 一种常见的模式是从外部数据库或者 Web 服务查询数据得到初始数据流，然后通过 Map 或者 FlatMap 对初始数据流进行丰富和增强。 Flink 提供了异步 I/O API 来让这个过程更加简单、高效和稳定。\n\n##### 可查询状态（Queryable State Beta）\n当 Flink 应用程序需要向外部存储推送大量数据时会导致 I/O 瓶颈问题出现。在这种场景下，如果对数据的读操作远少于写操作，那么让外部应用从 Flink 拉取所需的数据会是一种更好的方式。 可查询状态 接口可以实现这个功能，该接口允许被 Flink 托管的状态可以被按需查询。\n\n### Table Connnector\n\nTable API和SQL程序，都支持连接并读写外部系统。 对于Table连接器，除了要了解支持的**连接器**， 还应该了解其支持的**表格式**。\n\n#### 连接器\n\n以Flink1.12为例，下面是其Table API & SQL支持的连接器类型。\n\n|Name\t|Version|\tSource|\tSink|\n|---- |----|----|----|\n|Filesystem\t\t    |                   |Bounded and Unbounded Scan,          |Lookup\tStreaming Sink, Batch Sink|\n|Elasticsearch\t  |6.x & 7.x\t        |Not supported\t                      |Streaming Sink, Batch Sink|\n|Apache Kafka\t    |0.10+\t            |Unbounded Scan\t                      |Streaming Sink, Batch Sink|\n|Amazon Kinesis   |           \t\t    |Unbounded Scan\t                      |Streaming Sink|\n|JDBC\t\t          |                   |Bounded Scan, Lookup\t                |Streaming Sink, Batch Sink|\n|Apache HBase\t    |1.4.x & 2.2.x    \t|Bounded Scan, Lookup\t                |Streaming Sink, Batch Sink|\n|Apache Hive\t    |                 \t|Unbounded Scan, Bounded Scan, Lookup\t|Streaming Sink, Batch Sink|\n\n\n#### 格式\n\n表格式是一种存储格式，定义了如何把二进制数据映射到表的列上。\n\n|格式\t          | 支持的连接器\n|----           |----\n|CSV\t          |Apache Kafka, Upsert Kafka, Amazon Kinesis Data Streams, Filesystem\n|JSON\t          |Apache Kafka, Upsert Kafka, Amazon Kinesis Data Streams, Filesystem, Elasticsearch\n|Apache Avro\t  |Apache Kafka, Upsert Kafka, Amazon Kinesis Data Streams, Filesystem\n|Confluent Avro\t|Apache Kafka, Upsert Kafka\n|Debezium CDC\t  |Apache Kafka, Filesystem\n|Canal CDC\t    |Apache Kafka, Filesystem\n|Maxwell CDC\t  |Apache Kafka, Filesystem\n|Apache Parquet\t|Filesystem\n|Apache ORC\t    |Filesystem\n|Raw\t          |Apache Kafka, Upsert Kafka, Amazon Kinesis Data Streams, Filesystem\n\n### Dataset Connector\n\n","slug":"flink/Flink-4-Connectors","published":1,"updated":"2020-12-14T08:01:21.883Z","_id":"ckio9dwev003uk8ne90nn7yzz","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"DataStreeam-Connector\"><a href=\"#DataStreeam-Connector\" class=\"headerlink\" title=\"DataStreeam Connector\"></a>DataStreeam Connector</h3><h4 id=\"预定义的Source\"><a href=\"#预定义的Source\" class=\"headerlink\" title=\"预定义的Source\"></a>预定义的Source</h4><ul>\n<li>File-based:</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">readTextFile(path)</span><br><span class=\"line\">readFile(fileInputFormat, path)</span><br><span class=\"line\">readFile(fileInputFormat, path, watchType, interval, pathFilter, typeInfo)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Socket-based:</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">socketTextStream()</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Collection-based:</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fromCollection(Collection)</span><br><span class=\"line\">fromCollection(Iterator, Class)</span><br><span class=\"line\">fromElements(T ...)</span><br><span class=\"line\">fromParallelCollection(SplittableIterator, Class)</span><br><span class=\"line\">generateSequence(from, to)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Custom:</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">addSource()</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"预定义的Sink\"><a href=\"#预定义的Sink\" class=\"headerlink\" title=\"预定义的Sink\"></a>预定义的Sink</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">writeAsText() / TextOutputFormat</span><br><span class=\"line\"></span><br><span class=\"line\">writeAsCsv(...) / CsvOutputFormat</span><br><span class=\"line\"></span><br><span class=\"line\">print() / printToErr()</span><br><span class=\"line\"></span><br><span class=\"line\">writeUsingOutputFormat() / FileOutputFormat</span><br><span class=\"line\"></span><br><span class=\"line\">writeToSocket()</span><br><span class=\"line\"></span><br><span class=\"line\">addSink()</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"附带连接器\"><a href=\"#附带连接器\" class=\"headerlink\" title=\"附带连接器\"></a>附带连接器</h4><ul>\n<li>Apache Kafka (source/sink)</li>\n<li>Apache Cassandra (sink)</li>\n<li>Amazon Kinesis Streams (source/sink)</li>\n<li>Elasticsearch (sink)</li>\n<li>FileSystem（包括 Hadoop ） - 仅支持流 (sink)</li>\n<li>FileSystem（包括 Hadoop ） - 流批统一 (sink)</li>\n<li>RabbitMQ (source/sink)</li>\n<li>Apache NiFi (source/sink)</li>\n<li>Twitter Streaming API (source)</li>\n<li>Google PubSub (source/sink)</li>\n<li>JDBC (sink)</li>\n</ul>\n<h4 id=\"Apache-Bahir-中的连接器\"><a href=\"#Apache-Bahir-中的连接器\" class=\"headerlink\" title=\"Apache Bahir 中的连接器\"></a>Apache Bahir 中的连接器</h4><p>Flink 还有些一些额外的连接器通过 Apache Bahir 发布, 包括:</p>\n<ul>\n<li>Apache ActiveMQ (source/sink)</li>\n<li>Apache Flume (sink)</li>\n<li>Redis (sink)</li>\n<li>Akka (sink)</li>\n<li>Netty (source)</li>\n</ul>\n<h4 id=\"连接Flink的其它方法\"><a href=\"#连接Flink的其它方法\" class=\"headerlink\" title=\"连接Flink的其它方法\"></a>连接Flink的其它方法</h4><h5 id=\"异步-I-O\"><a href=\"#异步-I-O\" class=\"headerlink\" title=\"异步 I/O\"></a>异步 I/O</h5><p>使用connector并不是唯一可以使数据进入或者流出Flink的方式。 一种常见的模式是从外部数据库或者 Web 服务查询数据得到初始数据流，然后通过 Map 或者 FlatMap 对初始数据流进行丰富和增强。 Flink 提供了异步 I/O API 来让这个过程更加简单、高效和稳定。</p>\n<h5 id=\"可查询状态（Queryable-State-Beta）\"><a href=\"#可查询状态（Queryable-State-Beta）\" class=\"headerlink\" title=\"可查询状态（Queryable State Beta）\"></a>可查询状态（Queryable State Beta）</h5><p>当 Flink 应用程序需要向外部存储推送大量数据时会导致 I/O 瓶颈问题出现。在这种场景下，如果对数据的读操作远少于写操作，那么让外部应用从 Flink 拉取所需的数据会是一种更好的方式。 可查询状态 接口可以实现这个功能，该接口允许被 Flink 托管的状态可以被按需查询。</p>\n<h3 id=\"Table-Connnector\"><a href=\"#Table-Connnector\" class=\"headerlink\" title=\"Table Connnector\"></a>Table Connnector</h3><p>Table API和SQL程序，都支持连接并读写外部系统。 对于Table连接器，除了要了解支持的<strong>连接器</strong>， 还应该了解其支持的<strong>表格式</strong>。</p>\n<h4 id=\"连接器\"><a href=\"#连接器\" class=\"headerlink\" title=\"连接器\"></a>连接器</h4><p>以Flink1.12为例，下面是其Table API &amp; SQL支持的连接器类型。</p>\n<table>\n<thead>\n<tr>\n<th>Name</th>\n<th>Version</th>\n<th>Source</th>\n<th>Sink</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Filesystem</td>\n<td></td>\n<td>Bounded and Unbounded Scan,</td>\n<td>Lookup    Streaming Sink, Batch Sink</td>\n</tr>\n<tr>\n<td>Elasticsearch</td>\n<td>6.x &amp; 7.x</td>\n<td>Not supported</td>\n<td>Streaming Sink, Batch Sink</td>\n</tr>\n<tr>\n<td>Apache Kafka</td>\n<td>0.10+</td>\n<td>Unbounded Scan</td>\n<td>Streaming Sink, Batch Sink</td>\n</tr>\n<tr>\n<td>Amazon Kinesis</td>\n<td></td>\n<td>Unbounded Scan</td>\n<td>Streaming Sink</td>\n</tr>\n<tr>\n<td>JDBC</td>\n<td></td>\n<td>Bounded Scan, Lookup</td>\n<td>Streaming Sink, Batch Sink</td>\n</tr>\n<tr>\n<td>Apache HBase</td>\n<td>1.4.x &amp; 2.2.x</td>\n<td>Bounded Scan, Lookup</td>\n<td>Streaming Sink, Batch Sink</td>\n</tr>\n<tr>\n<td>Apache Hive</td>\n<td></td>\n<td>Unbounded Scan, Bounded Scan, Lookup</td>\n<td>Streaming Sink, Batch Sink</td>\n</tr>\n</tbody></table>\n<h4 id=\"格式\"><a href=\"#格式\" class=\"headerlink\" title=\"格式\"></a>格式</h4><p>表格式是一种存储格式，定义了如何把二进制数据映射到表的列上。</p>\n<table>\n<thead>\n<tr>\n<th>格式</th>\n<th>支持的连接器</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>CSV</td>\n<td>Apache Kafka, Upsert Kafka, Amazon Kinesis Data Streams, Filesystem</td>\n</tr>\n<tr>\n<td>JSON</td>\n<td>Apache Kafka, Upsert Kafka, Amazon Kinesis Data Streams, Filesystem, Elasticsearch</td>\n</tr>\n<tr>\n<td>Apache Avro</td>\n<td>Apache Kafka, Upsert Kafka, Amazon Kinesis Data Streams, Filesystem</td>\n</tr>\n<tr>\n<td>Confluent Avro</td>\n<td>Apache Kafka, Upsert Kafka</td>\n</tr>\n<tr>\n<td>Debezium CDC</td>\n<td>Apache Kafka, Filesystem</td>\n</tr>\n<tr>\n<td>Canal CDC</td>\n<td>Apache Kafka, Filesystem</td>\n</tr>\n<tr>\n<td>Maxwell CDC</td>\n<td>Apache Kafka, Filesystem</td>\n</tr>\n<tr>\n<td>Apache Parquet</td>\n<td>Filesystem</td>\n</tr>\n<tr>\n<td>Apache ORC</td>\n<td>Filesystem</td>\n</tr>\n<tr>\n<td>Raw</td>\n<td>Apache Kafka, Upsert Kafka, Amazon Kinesis Data Streams, Filesystem</td>\n</tr>\n</tbody></table>\n<h3 id=\"Dataset-Connector\"><a href=\"#Dataset-Connector\" class=\"headerlink\" title=\"Dataset Connector\"></a>Dataset Connector</h3>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"DataStreeam-Connector\"><a href=\"#DataStreeam-Connector\" class=\"headerlink\" title=\"DataStreeam Connector\"></a>DataStreeam Connector</h3><h4 id=\"预定义的Source\"><a href=\"#预定义的Source\" class=\"headerlink\" title=\"预定义的Source\"></a>预定义的Source</h4><ul>\n<li>File-based:</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">readTextFile(path)</span><br><span class=\"line\">readFile(fileInputFormat, path)</span><br><span class=\"line\">readFile(fileInputFormat, path, watchType, interval, pathFilter, typeInfo)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Socket-based:</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">socketTextStream()</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Collection-based:</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fromCollection(Collection)</span><br><span class=\"line\">fromCollection(Iterator, Class)</span><br><span class=\"line\">fromElements(T ...)</span><br><span class=\"line\">fromParallelCollection(SplittableIterator, Class)</span><br><span class=\"line\">generateSequence(from, to)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Custom:</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">addSource()</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"预定义的Sink\"><a href=\"#预定义的Sink\" class=\"headerlink\" title=\"预定义的Sink\"></a>预定义的Sink</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">writeAsText() / TextOutputFormat</span><br><span class=\"line\"></span><br><span class=\"line\">writeAsCsv(...) / CsvOutputFormat</span><br><span class=\"line\"></span><br><span class=\"line\">print() / printToErr()</span><br><span class=\"line\"></span><br><span class=\"line\">writeUsingOutputFormat() / FileOutputFormat</span><br><span class=\"line\"></span><br><span class=\"line\">writeToSocket()</span><br><span class=\"line\"></span><br><span class=\"line\">addSink()</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"附带连接器\"><a href=\"#附带连接器\" class=\"headerlink\" title=\"附带连接器\"></a>附带连接器</h4><ul>\n<li>Apache Kafka (source/sink)</li>\n<li>Apache Cassandra (sink)</li>\n<li>Amazon Kinesis Streams (source/sink)</li>\n<li>Elasticsearch (sink)</li>\n<li>FileSystem（包括 Hadoop ） - 仅支持流 (sink)</li>\n<li>FileSystem（包括 Hadoop ） - 流批统一 (sink)</li>\n<li>RabbitMQ (source/sink)</li>\n<li>Apache NiFi (source/sink)</li>\n<li>Twitter Streaming API (source)</li>\n<li>Google PubSub (source/sink)</li>\n<li>JDBC (sink)</li>\n</ul>\n<h4 id=\"Apache-Bahir-中的连接器\"><a href=\"#Apache-Bahir-中的连接器\" class=\"headerlink\" title=\"Apache Bahir 中的连接器\"></a>Apache Bahir 中的连接器</h4><p>Flink 还有些一些额外的连接器通过 Apache Bahir 发布, 包括:</p>\n<ul>\n<li>Apache ActiveMQ (source/sink)</li>\n<li>Apache Flume (sink)</li>\n<li>Redis (sink)</li>\n<li>Akka (sink)</li>\n<li>Netty (source)</li>\n</ul>\n<h4 id=\"连接Flink的其它方法\"><a href=\"#连接Flink的其它方法\" class=\"headerlink\" title=\"连接Flink的其它方法\"></a>连接Flink的其它方法</h4><h5 id=\"异步-I-O\"><a href=\"#异步-I-O\" class=\"headerlink\" title=\"异步 I/O\"></a>异步 I/O</h5><p>使用connector并不是唯一可以使数据进入或者流出Flink的方式。 一种常见的模式是从外部数据库或者 Web 服务查询数据得到初始数据流，然后通过 Map 或者 FlatMap 对初始数据流进行丰富和增强。 Flink 提供了异步 I/O API 来让这个过程更加简单、高效和稳定。</p>\n<h5 id=\"可查询状态（Queryable-State-Beta）\"><a href=\"#可查询状态（Queryable-State-Beta）\" class=\"headerlink\" title=\"可查询状态（Queryable State Beta）\"></a>可查询状态（Queryable State Beta）</h5><p>当 Flink 应用程序需要向外部存储推送大量数据时会导致 I/O 瓶颈问题出现。在这种场景下，如果对数据的读操作远少于写操作，那么让外部应用从 Flink 拉取所需的数据会是一种更好的方式。 可查询状态 接口可以实现这个功能，该接口允许被 Flink 托管的状态可以被按需查询。</p>\n<h3 id=\"Table-Connnector\"><a href=\"#Table-Connnector\" class=\"headerlink\" title=\"Table Connnector\"></a>Table Connnector</h3><p>Table API和SQL程序，都支持连接并读写外部系统。 对于Table连接器，除了要了解支持的<strong>连接器</strong>， 还应该了解其支持的<strong>表格式</strong>。</p>\n<h4 id=\"连接器\"><a href=\"#连接器\" class=\"headerlink\" title=\"连接器\"></a>连接器</h4><p>以Flink1.12为例，下面是其Table API &amp; SQL支持的连接器类型。</p>\n<table>\n<thead>\n<tr>\n<th>Name</th>\n<th>Version</th>\n<th>Source</th>\n<th>Sink</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Filesystem</td>\n<td></td>\n<td>Bounded and Unbounded Scan,</td>\n<td>Lookup    Streaming Sink, Batch Sink</td>\n</tr>\n<tr>\n<td>Elasticsearch</td>\n<td>6.x &amp; 7.x</td>\n<td>Not supported</td>\n<td>Streaming Sink, Batch Sink</td>\n</tr>\n<tr>\n<td>Apache Kafka</td>\n<td>0.10+</td>\n<td>Unbounded Scan</td>\n<td>Streaming Sink, Batch Sink</td>\n</tr>\n<tr>\n<td>Amazon Kinesis</td>\n<td></td>\n<td>Unbounded Scan</td>\n<td>Streaming Sink</td>\n</tr>\n<tr>\n<td>JDBC</td>\n<td></td>\n<td>Bounded Scan, Lookup</td>\n<td>Streaming Sink, Batch Sink</td>\n</tr>\n<tr>\n<td>Apache HBase</td>\n<td>1.4.x &amp; 2.2.x</td>\n<td>Bounded Scan, Lookup</td>\n<td>Streaming Sink, Batch Sink</td>\n</tr>\n<tr>\n<td>Apache Hive</td>\n<td></td>\n<td>Unbounded Scan, Bounded Scan, Lookup</td>\n<td>Streaming Sink, Batch Sink</td>\n</tr>\n</tbody></table>\n<h4 id=\"格式\"><a href=\"#格式\" class=\"headerlink\" title=\"格式\"></a>格式</h4><p>表格式是一种存储格式，定义了如何把二进制数据映射到表的列上。</p>\n<table>\n<thead>\n<tr>\n<th>格式</th>\n<th>支持的连接器</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>CSV</td>\n<td>Apache Kafka, Upsert Kafka, Amazon Kinesis Data Streams, Filesystem</td>\n</tr>\n<tr>\n<td>JSON</td>\n<td>Apache Kafka, Upsert Kafka, Amazon Kinesis Data Streams, Filesystem, Elasticsearch</td>\n</tr>\n<tr>\n<td>Apache Avro</td>\n<td>Apache Kafka, Upsert Kafka, Amazon Kinesis Data Streams, Filesystem</td>\n</tr>\n<tr>\n<td>Confluent Avro</td>\n<td>Apache Kafka, Upsert Kafka</td>\n</tr>\n<tr>\n<td>Debezium CDC</td>\n<td>Apache Kafka, Filesystem</td>\n</tr>\n<tr>\n<td>Canal CDC</td>\n<td>Apache Kafka, Filesystem</td>\n</tr>\n<tr>\n<td>Maxwell CDC</td>\n<td>Apache Kafka, Filesystem</td>\n</tr>\n<tr>\n<td>Apache Parquet</td>\n<td>Filesystem</td>\n</tr>\n<tr>\n<td>Apache ORC</td>\n<td>Filesystem</td>\n</tr>\n<tr>\n<td>Raw</td>\n<td>Apache Kafka, Upsert Kafka, Amazon Kinesis Data Streams, Filesystem</td>\n</tr>\n</tbody></table>\n<h3 id=\"Dataset-Connector\"><a href=\"#Dataset-Connector\" class=\"headerlink\" title=\"Dataset Connector\"></a>Dataset Connector</h3>"},{"title":"Flink-2. 流计算API窗口","date":"2020-09-12T14:21:49.000Z","_content":"\n## Window\n\n窗口是另一类算子， 是DataStream的逻辑边界， 在第一个元素到达后被创建， 在生命周期结束后被销毁。\n\n应用程序可以定义开窗机制， 触发器， 迟到生存期， 窗口聚合函数和清除器。\n\n窗口分两大类， 即Keyed Window和 Non-Keyed Window。\n\n## 窗口分类\n\n### 滚动窗口\n\n滚动窗口的时间长度是固定的， 且不同时间区间的窗口不会重叠， 可根据事件时间和处理时间定义。\n\n### 滑动窗口\n\n滑动窗口按照滑动步长将时间拆分成固定长度的窗口， 当滑动步长小于窗口长度时，相邻窗口间会重叠。\n\n### 会话窗口\n\n根据相邻元素之间的时间间隔确定会话窗口的边界， 分为固定时间间隔和动态时间间隔。\n\n### 全局窗口\n\n将相同KEY的元素聚合在一起，但是这种窗口没有起点也没有终点，因此必须自定义触发器、\n\n### 增量式计算\n\n拆分窗口的目的是将指定时间区间内的所有元素当成一个有界数据集， 以分析这个数据集的整体特征。\n\n那么从实现上来看，等待所有元素都被收集后再进行计算是最简单的， 但是毫无疑问会在最后的时间里疯狂占用CPU。\n\n如果我们采用增量式计算的设计，即数据进入引擎立刻被处理， 这样是可以提升整体计算性能。\n\n这样的好处是让计算任务平均在每个时间点上， 不会出现某个时刻突然大量计算的问题，减轻最后的计算压力。当然也增加数据处理引擎架构设计的复杂度。\n\n## 触发器\n\n触发器原型中包括4类触发机制， 基于事件驱动。\n\n（1）onElement: 每收到一个元素调用一次该方法。\n\n（2）onProcessingTime: 根据注册的处理时间定时器触发。\n\n（3）onEventTime: 根据注册的事件时间定时器触发。\n\n（4）onMerge: 两个窗口合并时触发。\n\n另外还提供了资源清除接口clear().\n\n## 清除器\n\n在触发器触发后， 窗口函数执行前或执行后清除窗口内元素，有以下两个方法：\n\n1. 触发器被触发后， 窗口函数执行前， 清除窗口内元素\n\n```java\nvoid evictBefore(Iterable<TimestampdValue<T>> elements, int size,  W window, EvictorContext evictorContext);\n```\n\n2. 触发器被触发后，窗口函数执行后，清除窗口内元素\n\n```java\nvoid evictAfter(Iterable<TimestampdValue<T>> elements, int size,  W window, EvictorContext evictorContext);\n```\n\n提供了三种内置清除器： CountEvictor, DeltaEvictor, TimeEvictor\n\n## 迟到生存期\n\nFlink默认的迟到生存期为0， 即事件时间窗口在水印到来后结束， 无需考虑事件迟到的情况。\n\n```scala\nval input: DataStream[T] = ...\n\ninput\n    .keyBy(...)\n    .window(...)\n    .allowedLateness(Time.seconds(10))\n    ...\n```","source":"_posts/flink/Flink-3-窗口.md","raw":"---\ntitle: Flink-2. 流计算API窗口\ndate: 2020-09-12 22:21:49\ncategories: 流计算\ntags: \n- Flink\n- 窗口函数\n---\n\n## Window\n\n窗口是另一类算子， 是DataStream的逻辑边界， 在第一个元素到达后被创建， 在生命周期结束后被销毁。\n\n应用程序可以定义开窗机制， 触发器， 迟到生存期， 窗口聚合函数和清除器。\n\n窗口分两大类， 即Keyed Window和 Non-Keyed Window。\n\n## 窗口分类\n\n### 滚动窗口\n\n滚动窗口的时间长度是固定的， 且不同时间区间的窗口不会重叠， 可根据事件时间和处理时间定义。\n\n### 滑动窗口\n\n滑动窗口按照滑动步长将时间拆分成固定长度的窗口， 当滑动步长小于窗口长度时，相邻窗口间会重叠。\n\n### 会话窗口\n\n根据相邻元素之间的时间间隔确定会话窗口的边界， 分为固定时间间隔和动态时间间隔。\n\n### 全局窗口\n\n将相同KEY的元素聚合在一起，但是这种窗口没有起点也没有终点，因此必须自定义触发器、\n\n### 增量式计算\n\n拆分窗口的目的是将指定时间区间内的所有元素当成一个有界数据集， 以分析这个数据集的整体特征。\n\n那么从实现上来看，等待所有元素都被收集后再进行计算是最简单的， 但是毫无疑问会在最后的时间里疯狂占用CPU。\n\n如果我们采用增量式计算的设计，即数据进入引擎立刻被处理， 这样是可以提升整体计算性能。\n\n这样的好处是让计算任务平均在每个时间点上， 不会出现某个时刻突然大量计算的问题，减轻最后的计算压力。当然也增加数据处理引擎架构设计的复杂度。\n\n## 触发器\n\n触发器原型中包括4类触发机制， 基于事件驱动。\n\n（1）onElement: 每收到一个元素调用一次该方法。\n\n（2）onProcessingTime: 根据注册的处理时间定时器触发。\n\n（3）onEventTime: 根据注册的事件时间定时器触发。\n\n（4）onMerge: 两个窗口合并时触发。\n\n另外还提供了资源清除接口clear().\n\n## 清除器\n\n在触发器触发后， 窗口函数执行前或执行后清除窗口内元素，有以下两个方法：\n\n1. 触发器被触发后， 窗口函数执行前， 清除窗口内元素\n\n```java\nvoid evictBefore(Iterable<TimestampdValue<T>> elements, int size,  W window, EvictorContext evictorContext);\n```\n\n2. 触发器被触发后，窗口函数执行后，清除窗口内元素\n\n```java\nvoid evictAfter(Iterable<TimestampdValue<T>> elements, int size,  W window, EvictorContext evictorContext);\n```\n\n提供了三种内置清除器： CountEvictor, DeltaEvictor, TimeEvictor\n\n## 迟到生存期\n\nFlink默认的迟到生存期为0， 即事件时间窗口在水印到来后结束， 无需考虑事件迟到的情况。\n\n```scala\nval input: DataStream[T] = ...\n\ninput\n    .keyBy(...)\n    .window(...)\n    .allowedLateness(Time.seconds(10))\n    ...\n```","slug":"flink/Flink-3-窗口","published":1,"updated":"2020-10-27T08:08:15.939Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckio9dwey003xk8ne0v5sd0r4","content":"<h2 id=\"Window\"><a href=\"#Window\" class=\"headerlink\" title=\"Window\"></a>Window</h2><p>窗口是另一类算子， 是DataStream的逻辑边界， 在第一个元素到达后被创建， 在生命周期结束后被销毁。</p>\n<p>应用程序可以定义开窗机制， 触发器， 迟到生存期， 窗口聚合函数和清除器。</p>\n<p>窗口分两大类， 即Keyed Window和 Non-Keyed Window。</p>\n<h2 id=\"窗口分类\"><a href=\"#窗口分类\" class=\"headerlink\" title=\"窗口分类\"></a>窗口分类</h2><h3 id=\"滚动窗口\"><a href=\"#滚动窗口\" class=\"headerlink\" title=\"滚动窗口\"></a>滚动窗口</h3><p>滚动窗口的时间长度是固定的， 且不同时间区间的窗口不会重叠， 可根据事件时间和处理时间定义。</p>\n<h3 id=\"滑动窗口\"><a href=\"#滑动窗口\" class=\"headerlink\" title=\"滑动窗口\"></a>滑动窗口</h3><p>滑动窗口按照滑动步长将时间拆分成固定长度的窗口， 当滑动步长小于窗口长度时，相邻窗口间会重叠。</p>\n<h3 id=\"会话窗口\"><a href=\"#会话窗口\" class=\"headerlink\" title=\"会话窗口\"></a>会话窗口</h3><p>根据相邻元素之间的时间间隔确定会话窗口的边界， 分为固定时间间隔和动态时间间隔。</p>\n<h3 id=\"全局窗口\"><a href=\"#全局窗口\" class=\"headerlink\" title=\"全局窗口\"></a>全局窗口</h3><p>将相同KEY的元素聚合在一起，但是这种窗口没有起点也没有终点，因此必须自定义触发器、</p>\n<h3 id=\"增量式计算\"><a href=\"#增量式计算\" class=\"headerlink\" title=\"增量式计算\"></a>增量式计算</h3><p>拆分窗口的目的是将指定时间区间内的所有元素当成一个有界数据集， 以分析这个数据集的整体特征。</p>\n<p>那么从实现上来看，等待所有元素都被收集后再进行计算是最简单的， 但是毫无疑问会在最后的时间里疯狂占用CPU。</p>\n<p>如果我们采用增量式计算的设计，即数据进入引擎立刻被处理， 这样是可以提升整体计算性能。</p>\n<p>这样的好处是让计算任务平均在每个时间点上， 不会出现某个时刻突然大量计算的问题，减轻最后的计算压力。当然也增加数据处理引擎架构设计的复杂度。</p>\n<h2 id=\"触发器\"><a href=\"#触发器\" class=\"headerlink\" title=\"触发器\"></a>触发器</h2><p>触发器原型中包括4类触发机制， 基于事件驱动。</p>\n<p>（1）onElement: 每收到一个元素调用一次该方法。</p>\n<p>（2）onProcessingTime: 根据注册的处理时间定时器触发。</p>\n<p>（3）onEventTime: 根据注册的事件时间定时器触发。</p>\n<p>（4）onMerge: 两个窗口合并时触发。</p>\n<p>另外还提供了资源清除接口clear().</p>\n<h2 id=\"清除器\"><a href=\"#清除器\" class=\"headerlink\" title=\"清除器\"></a>清除器</h2><p>在触发器触发后， 窗口函数执行前或执行后清除窗口内元素，有以下两个方法：</p>\n<ol>\n<li>触发器被触发后， 窗口函数执行前， 清除窗口内元素</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">evictBefore</span><span class=\"params\">(Iterable&lt;TimestampdValue&lt;T&gt;&gt; elements, <span class=\"keyword\">int</span> size,  W window, EvictorContext evictorContext)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>触发器被触发后，窗口函数执行后，清除窗口内元素</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">evictAfter</span><span class=\"params\">(Iterable&lt;TimestampdValue&lt;T&gt;&gt; elements, <span class=\"keyword\">int</span> size,  W window, EvictorContext evictorContext)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>提供了三种内置清除器： CountEvictor, DeltaEvictor, TimeEvictor</p>\n<h2 id=\"迟到生存期\"><a href=\"#迟到生存期\" class=\"headerlink\" title=\"迟到生存期\"></a>迟到生存期</h2><p>Flink默认的迟到生存期为0， 即事件时间窗口在水印到来后结束， 无需考虑事件迟到的情况。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> input: <span class=\"type\">DataStream</span>[<span class=\"type\">T</span>] = ...</span><br><span class=\"line\"></span><br><span class=\"line\">input</span><br><span class=\"line\">    .keyBy(...)</span><br><span class=\"line\">    .window(...)</span><br><span class=\"line\">    .allowedLateness(<span class=\"type\">Time</span>.seconds(<span class=\"number\">10</span>))</span><br><span class=\"line\">    ...</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Window\"><a href=\"#Window\" class=\"headerlink\" title=\"Window\"></a>Window</h2><p>窗口是另一类算子， 是DataStream的逻辑边界， 在第一个元素到达后被创建， 在生命周期结束后被销毁。</p>\n<p>应用程序可以定义开窗机制， 触发器， 迟到生存期， 窗口聚合函数和清除器。</p>\n<p>窗口分两大类， 即Keyed Window和 Non-Keyed Window。</p>\n<h2 id=\"窗口分类\"><a href=\"#窗口分类\" class=\"headerlink\" title=\"窗口分类\"></a>窗口分类</h2><h3 id=\"滚动窗口\"><a href=\"#滚动窗口\" class=\"headerlink\" title=\"滚动窗口\"></a>滚动窗口</h3><p>滚动窗口的时间长度是固定的， 且不同时间区间的窗口不会重叠， 可根据事件时间和处理时间定义。</p>\n<h3 id=\"滑动窗口\"><a href=\"#滑动窗口\" class=\"headerlink\" title=\"滑动窗口\"></a>滑动窗口</h3><p>滑动窗口按照滑动步长将时间拆分成固定长度的窗口， 当滑动步长小于窗口长度时，相邻窗口间会重叠。</p>\n<h3 id=\"会话窗口\"><a href=\"#会话窗口\" class=\"headerlink\" title=\"会话窗口\"></a>会话窗口</h3><p>根据相邻元素之间的时间间隔确定会话窗口的边界， 分为固定时间间隔和动态时间间隔。</p>\n<h3 id=\"全局窗口\"><a href=\"#全局窗口\" class=\"headerlink\" title=\"全局窗口\"></a>全局窗口</h3><p>将相同KEY的元素聚合在一起，但是这种窗口没有起点也没有终点，因此必须自定义触发器、</p>\n<h3 id=\"增量式计算\"><a href=\"#增量式计算\" class=\"headerlink\" title=\"增量式计算\"></a>增量式计算</h3><p>拆分窗口的目的是将指定时间区间内的所有元素当成一个有界数据集， 以分析这个数据集的整体特征。</p>\n<p>那么从实现上来看，等待所有元素都被收集后再进行计算是最简单的， 但是毫无疑问会在最后的时间里疯狂占用CPU。</p>\n<p>如果我们采用增量式计算的设计，即数据进入引擎立刻被处理， 这样是可以提升整体计算性能。</p>\n<p>这样的好处是让计算任务平均在每个时间点上， 不会出现某个时刻突然大量计算的问题，减轻最后的计算压力。当然也增加数据处理引擎架构设计的复杂度。</p>\n<h2 id=\"触发器\"><a href=\"#触发器\" class=\"headerlink\" title=\"触发器\"></a>触发器</h2><p>触发器原型中包括4类触发机制， 基于事件驱动。</p>\n<p>（1）onElement: 每收到一个元素调用一次该方法。</p>\n<p>（2）onProcessingTime: 根据注册的处理时间定时器触发。</p>\n<p>（3）onEventTime: 根据注册的事件时间定时器触发。</p>\n<p>（4）onMerge: 两个窗口合并时触发。</p>\n<p>另外还提供了资源清除接口clear().</p>\n<h2 id=\"清除器\"><a href=\"#清除器\" class=\"headerlink\" title=\"清除器\"></a>清除器</h2><p>在触发器触发后， 窗口函数执行前或执行后清除窗口内元素，有以下两个方法：</p>\n<ol>\n<li>触发器被触发后， 窗口函数执行前， 清除窗口内元素</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">evictBefore</span><span class=\"params\">(Iterable&lt;TimestampdValue&lt;T&gt;&gt; elements, <span class=\"keyword\">int</span> size,  W window, EvictorContext evictorContext)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>触发器被触发后，窗口函数执行后，清除窗口内元素</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">evictAfter</span><span class=\"params\">(Iterable&lt;TimestampdValue&lt;T&gt;&gt; elements, <span class=\"keyword\">int</span> size,  W window, EvictorContext evictorContext)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>提供了三种内置清除器： CountEvictor, DeltaEvictor, TimeEvictor</p>\n<h2 id=\"迟到生存期\"><a href=\"#迟到生存期\" class=\"headerlink\" title=\"迟到生存期\"></a>迟到生存期</h2><p>Flink默认的迟到生存期为0， 即事件时间窗口在水印到来后结束， 无需考虑事件迟到的情况。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> input: <span class=\"type\">DataStream</span>[<span class=\"type\">T</span>] = ...</span><br><span class=\"line\"></span><br><span class=\"line\">input</span><br><span class=\"line\">    .keyBy(...)</span><br><span class=\"line\">    .window(...)</span><br><span class=\"line\">    .allowedLateness(<span class=\"type\">Time</span>.seconds(<span class=\"number\">10</span>))</span><br><span class=\"line\">    ...</span><br></pre></td></tr></table></figure>"},{"title":"Flink 0. 流处理基本概念","date":"2020-08-26T13:57:26.000Z","_content":"\n### 无界流和有界流\n\n无界数据流:\n\n* 持续生成的, 本质上无限的数据集合\n* 数据会随时间的推演而持续增加，计算持续进行且不存在结束的状态\n\n有界数据流:\n\n* 有限的数据集合\n* 数据大小固定，计算最终会完成并处于结束的状态\n\n### 状态\n\n> 我们在设计一个微服务程序的时候, 往往追求服务是无状态的——这是因为要满足快速扩容、弹性缩容的要求。\n> 而对于无状态, 实际要求我们的接口满足幂等性-即无论多少次访问接口，同样的输入总能得到同样的输出。\n> 这里的状态，指的就是`中间计算结果`。\n\n但是流计算本质属于'增量处理'， 通常需要不断查询、保持状态；\n\n### 时间语义\n<!--more-->\n#### Time\n\n* **Event Time（很重要）**, 事件实际发生的时间\n* Ingestion Time（不太重要）, 数据进入流处理引擎的时间\n* **Processing Time（重要）**, 流计算引擎真正开始处理事件的时间\n![flink time](https://tva1.sinaimg.cn/large/007S8ZIlly1gj59zbvdtaj30k00b93za.jpg)\n\n#### Watermarks, 水位线\n\n预估收到数据的截止时间。决定窗口是否触发， 小于水位线的数据默认丢弃。\n![watermarks](https://tva1.sinaimg.cn/large/007S8ZIlly1gj5aj8c7erj30k00b9t9c.jpg)\n\n#### Window\n\n流处理应用中， 数据是连续不断的，因此我们不可能等所有数据都到了才处理。通常我们可以每来一个消息就处理一次， 但是有时我们需要做一些**聚合类**的处理。\n\n比如： 在过去的1小时内，有多少用户访问了我们的网页。\n\n为满足这种需求， 我们可以定义一个窗口， 用来收集最近1小时的数据， 并对窗口内的数据计算。\n\n窗口可以是时间驱动（Time Window, 例如：每分钟）, 也可以数据驱动（Count Window, 例如：每1000条记录）。\n\n通常把窗口分为三类：\n\n* 滚动窗口， Tumbling Window\n\n  * 将数据依据固定窗口长度进行切割\n  * 时间对齐，窗口长度固定，无重叠\n\n* 滑动窗口，Sliding Window\n  * 窗口按照固定长度，平滑地对数据一直（实际上有滑动间隔）切割\n  * 窗口长度固定，有重叠\n* 会话窗口\n  * 一段时间内没有接收到新数据就会生成新的窗口\n  * 时间不对齐\n\n#### Trigger\n\n触发器。决定了一个窗口何时能被计算或清除， 每个窗口都会拥有一个自己的Trigger。\n\n<!-- ### 延迟和吞吐量 -->","source":"_posts/flink/Flink-0-流处理基本概念.md","raw":"---\ntitle: Flink 0. 流处理基本概念\ndate: 2020-08-26 21:57:26\ncategories: 流计算\ntags: \n- Flink\n---\n\n### 无界流和有界流\n\n无界数据流:\n\n* 持续生成的, 本质上无限的数据集合\n* 数据会随时间的推演而持续增加，计算持续进行且不存在结束的状态\n\n有界数据流:\n\n* 有限的数据集合\n* 数据大小固定，计算最终会完成并处于结束的状态\n\n### 状态\n\n> 我们在设计一个微服务程序的时候, 往往追求服务是无状态的——这是因为要满足快速扩容、弹性缩容的要求。\n> 而对于无状态, 实际要求我们的接口满足幂等性-即无论多少次访问接口，同样的输入总能得到同样的输出。\n> 这里的状态，指的就是`中间计算结果`。\n\n但是流计算本质属于'增量处理'， 通常需要不断查询、保持状态；\n\n### 时间语义\n<!--more-->\n#### Time\n\n* **Event Time（很重要）**, 事件实际发生的时间\n* Ingestion Time（不太重要）, 数据进入流处理引擎的时间\n* **Processing Time（重要）**, 流计算引擎真正开始处理事件的时间\n![flink time](https://tva1.sinaimg.cn/large/007S8ZIlly1gj59zbvdtaj30k00b93za.jpg)\n\n#### Watermarks, 水位线\n\n预估收到数据的截止时间。决定窗口是否触发， 小于水位线的数据默认丢弃。\n![watermarks](https://tva1.sinaimg.cn/large/007S8ZIlly1gj5aj8c7erj30k00b9t9c.jpg)\n\n#### Window\n\n流处理应用中， 数据是连续不断的，因此我们不可能等所有数据都到了才处理。通常我们可以每来一个消息就处理一次， 但是有时我们需要做一些**聚合类**的处理。\n\n比如： 在过去的1小时内，有多少用户访问了我们的网页。\n\n为满足这种需求， 我们可以定义一个窗口， 用来收集最近1小时的数据， 并对窗口内的数据计算。\n\n窗口可以是时间驱动（Time Window, 例如：每分钟）, 也可以数据驱动（Count Window, 例如：每1000条记录）。\n\n通常把窗口分为三类：\n\n* 滚动窗口， Tumbling Window\n\n  * 将数据依据固定窗口长度进行切割\n  * 时间对齐，窗口长度固定，无重叠\n\n* 滑动窗口，Sliding Window\n  * 窗口按照固定长度，平滑地对数据一直（实际上有滑动间隔）切割\n  * 窗口长度固定，有重叠\n* 会话窗口\n  * 一段时间内没有接收到新数据就会生成新的窗口\n  * 时间不对齐\n\n#### Trigger\n\n触发器。决定了一个窗口何时能被计算或清除， 每个窗口都会拥有一个自己的Trigger。\n\n<!-- ### 延迟和吞吐量 -->","slug":"flink/Flink-0-流处理基本概念","published":1,"updated":"2020-10-27T08:08:15.938Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckio9dwez0041k8ne9opc0onp","content":"<h3 id=\"无界流和有界流\"><a href=\"#无界流和有界流\" class=\"headerlink\" title=\"无界流和有界流\"></a>无界流和有界流</h3><p>无界数据流:</p>\n<ul>\n<li>持续生成的, 本质上无限的数据集合</li>\n<li>数据会随时间的推演而持续增加，计算持续进行且不存在结束的状态</li>\n</ul>\n<p>有界数据流:</p>\n<ul>\n<li>有限的数据集合</li>\n<li>数据大小固定，计算最终会完成并处于结束的状态</li>\n</ul>\n<h3 id=\"状态\"><a href=\"#状态\" class=\"headerlink\" title=\"状态\"></a>状态</h3><blockquote>\n<p>我们在设计一个微服务程序的时候, 往往追求服务是无状态的——这是因为要满足快速扩容、弹性缩容的要求。<br>而对于无状态, 实际要求我们的接口满足幂等性-即无论多少次访问接口，同样的输入总能得到同样的输出。<br>这里的状态，指的就是<code>中间计算结果</code>。</p>\n</blockquote>\n<p>但是流计算本质属于’增量处理’， 通常需要不断查询、保持状态；</p>\n<h3 id=\"时间语义\"><a href=\"#时间语义\" class=\"headerlink\" title=\"时间语义\"></a>时间语义</h3><a id=\"more\"></a>\n<h4 id=\"Time\"><a href=\"#Time\" class=\"headerlink\" title=\"Time\"></a>Time</h4><ul>\n<li><strong>Event Time（很重要）</strong>, 事件实际发生的时间</li>\n<li>Ingestion Time（不太重要）, 数据进入流处理引擎的时间</li>\n<li><strong>Processing Time（重要）</strong>, 流计算引擎真正开始处理事件的时间<br><img src=\"https://tva1.sinaimg.cn/large/007S8ZIlly1gj59zbvdtaj30k00b93za.jpg\" alt=\"flink time\"></li>\n</ul>\n<h4 id=\"Watermarks-水位线\"><a href=\"#Watermarks-水位线\" class=\"headerlink\" title=\"Watermarks, 水位线\"></a>Watermarks, 水位线</h4><p>预估收到数据的截止时间。决定窗口是否触发， 小于水位线的数据默认丢弃。<br><img src=\"https://tva1.sinaimg.cn/large/007S8ZIlly1gj5aj8c7erj30k00b9t9c.jpg\" alt=\"watermarks\"></p>\n<h4 id=\"Window\"><a href=\"#Window\" class=\"headerlink\" title=\"Window\"></a>Window</h4><p>流处理应用中， 数据是连续不断的，因此我们不可能等所有数据都到了才处理。通常我们可以每来一个消息就处理一次， 但是有时我们需要做一些<strong>聚合类</strong>的处理。</p>\n<p>比如： 在过去的1小时内，有多少用户访问了我们的网页。</p>\n<p>为满足这种需求， 我们可以定义一个窗口， 用来收集最近1小时的数据， 并对窗口内的数据计算。</p>\n<p>窗口可以是时间驱动（Time Window, 例如：每分钟）, 也可以数据驱动（Count Window, 例如：每1000条记录）。</p>\n<p>通常把窗口分为三类：</p>\n<ul>\n<li><p>滚动窗口， Tumbling Window</p>\n<ul>\n<li>将数据依据固定窗口长度进行切割</li>\n<li>时间对齐，窗口长度固定，无重叠</li>\n</ul>\n</li>\n<li><p>滑动窗口，Sliding Window</p>\n<ul>\n<li>窗口按照固定长度，平滑地对数据一直（实际上有滑动间隔）切割</li>\n<li>窗口长度固定，有重叠</li>\n</ul>\n</li>\n<li><p>会话窗口</p>\n<ul>\n<li>一段时间内没有接收到新数据就会生成新的窗口</li>\n<li>时间不对齐</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Trigger\"><a href=\"#Trigger\" class=\"headerlink\" title=\"Trigger\"></a>Trigger</h4><p>触发器。决定了一个窗口何时能被计算或清除， 每个窗口都会拥有一个自己的Trigger。</p>\n<!-- ### 延迟和吞吐量 -->","site":{"data":{}},"excerpt":"<h3 id=\"无界流和有界流\"><a href=\"#无界流和有界流\" class=\"headerlink\" title=\"无界流和有界流\"></a>无界流和有界流</h3><p>无界数据流:</p>\n<ul>\n<li>持续生成的, 本质上无限的数据集合</li>\n<li>数据会随时间的推演而持续增加，计算持续进行且不存在结束的状态</li>\n</ul>\n<p>有界数据流:</p>\n<ul>\n<li>有限的数据集合</li>\n<li>数据大小固定，计算最终会完成并处于结束的状态</li>\n</ul>\n<h3 id=\"状态\"><a href=\"#状态\" class=\"headerlink\" title=\"状态\"></a>状态</h3><blockquote>\n<p>我们在设计一个微服务程序的时候, 往往追求服务是无状态的——这是因为要满足快速扩容、弹性缩容的要求。<br>而对于无状态, 实际要求我们的接口满足幂等性-即无论多少次访问接口，同样的输入总能得到同样的输出。<br>这里的状态，指的就是<code>中间计算结果</code>。</p>\n</blockquote>\n<p>但是流计算本质属于’增量处理’， 通常需要不断查询、保持状态；</p>\n<h3 id=\"时间语义\"><a href=\"#时间语义\" class=\"headerlink\" title=\"时间语义\"></a>时间语义</h3>","more":"<h4 id=\"Time\"><a href=\"#Time\" class=\"headerlink\" title=\"Time\"></a>Time</h4><ul>\n<li><strong>Event Time（很重要）</strong>, 事件实际发生的时间</li>\n<li>Ingestion Time（不太重要）, 数据进入流处理引擎的时间</li>\n<li><strong>Processing Time（重要）</strong>, 流计算引擎真正开始处理事件的时间<br><img src=\"https://tva1.sinaimg.cn/large/007S8ZIlly1gj59zbvdtaj30k00b93za.jpg\" alt=\"flink time\"></li>\n</ul>\n<h4 id=\"Watermarks-水位线\"><a href=\"#Watermarks-水位线\" class=\"headerlink\" title=\"Watermarks, 水位线\"></a>Watermarks, 水位线</h4><p>预估收到数据的截止时间。决定窗口是否触发， 小于水位线的数据默认丢弃。<br><img src=\"https://tva1.sinaimg.cn/large/007S8ZIlly1gj5aj8c7erj30k00b9t9c.jpg\" alt=\"watermarks\"></p>\n<h4 id=\"Window\"><a href=\"#Window\" class=\"headerlink\" title=\"Window\"></a>Window</h4><p>流处理应用中， 数据是连续不断的，因此我们不可能等所有数据都到了才处理。通常我们可以每来一个消息就处理一次， 但是有时我们需要做一些<strong>聚合类</strong>的处理。</p>\n<p>比如： 在过去的1小时内，有多少用户访问了我们的网页。</p>\n<p>为满足这种需求， 我们可以定义一个窗口， 用来收集最近1小时的数据， 并对窗口内的数据计算。</p>\n<p>窗口可以是时间驱动（Time Window, 例如：每分钟）, 也可以数据驱动（Count Window, 例如：每1000条记录）。</p>\n<p>通常把窗口分为三类：</p>\n<ul>\n<li><p>滚动窗口， Tumbling Window</p>\n<ul>\n<li>将数据依据固定窗口长度进行切割</li>\n<li>时间对齐，窗口长度固定，无重叠</li>\n</ul>\n</li>\n<li><p>滑动窗口，Sliding Window</p>\n<ul>\n<li>窗口按照固定长度，平滑地对数据一直（实际上有滑动间隔）切割</li>\n<li>窗口长度固定，有重叠</li>\n</ul>\n</li>\n<li><p>会话窗口</p>\n<ul>\n<li>一段时间内没有接收到新数据就会生成新的窗口</li>\n<li>时间不对齐</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Trigger\"><a href=\"#Trigger\" class=\"headerlink\" title=\"Trigger\"></a>Trigger</h4><p>触发器。决定了一个窗口何时能被计算或清除， 每个窗口都会拥有一个自己的Trigger。</p>\n<!-- ### 延迟和吞吐量 -->"},{"title":"读DDIA 4.数据编码与演化","date":"2020-10-12T13:37:16.000Z","_content":"![思维导图笔记](https://tva1.sinaimg.cn/large/007S8ZIlly1gjmvngyne8j30u016ve81.jpg)","source":"_posts/distribute/读DDIA-4-数据编码与演化.md","raw":"---\ntitle: 读DDIA 4.数据编码与演化\ndate: 2020-10-12 21:37:16\ntags: \n- DDIA\n- 笔记\n---\n![思维导图笔记](https://tva1.sinaimg.cn/large/007S8ZIlly1gjmvngyne8j30u016ve81.jpg)","slug":"distribute/读DDIA-4-数据编码与演化","published":1,"updated":"2020-10-27T08:08:15.937Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckio9dwf10045k8newdidqq80","content":"<p><img src=\"https://tva1.sinaimg.cn/large/007S8ZIlly1gjmvngyne8j30u016ve81.jpg\" alt=\"思维导图笔记\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"https://tva1.sinaimg.cn/large/007S8ZIlly1gjmvngyne8j30u016ve81.jpg\" alt=\"思维导图笔记\"></p>\n"},{"title":"Flink 5. State","date":"2020-12-09T09:03:21.000Z","_content":"\n示例： 利用ValueState，保存之前运算结果，并在条件满足后输出\n\n```java\nConfiguration configuration = new Configuration();\nStreamExecutionEnvironment env = StreamExecutionEnvironment.createLocalEnvironmentWithWebUI(configuration);\nenv.setParallelism(2);\n\nDataStream<Tuple2<Long, Long>> dataStream =\n    env.fromElements(\n        Tuple2.of(1L, 3L),\n        Tuple2.of(1L, 5L),\n        Tuple2.of(2L, 6L),\n        Tuple2.of(2L, 2L),\n        Tuple2.of(2L, 4L),\n        Tuple2.of(1L, 7L));\n\ndataStream.keyBy(0).flatMap(new CountAverageWithValueState()).print();\n\nenv.execute(\"Test state\");\n```\n\n```java\nimport org.apache.flink.api.common.functions.RichFlatMapFunction;\nimport org.apache.flink.api.common.state.ValueState;\nimport org.apache.flink.api.common.state.ValueStateDescriptor;\nimport org.apache.flink.api.common.typeinfo.Types;\nimport org.apache.flink.api.java.tuple.Tuple2;\nimport org.apache.flink.configuration.Configuration;\nimport org.apache.flink.util.Collector;\n\n\npublic class CountAverageWithValueState extends RichFlatMapFunction<Tuple2<Long, Long>, Tuple2<Long, Double>> {\n\n    private ValueState<Tuple2<Long,Long>> countAndSum;\n\n    @Override\n    public void open(Configuration parameters) throws Exception {\n        ValueStateDescriptor<Tuple2<Long,Long>> descriptor = new ValueStateDescriptor<Tuple2<Long, Long>>(\"average\",\n            Types.TUPLE(Types.LONG, Types.LONG));\n        countAndSum = getRuntimeContext().getState(descriptor);\n    }\n\n    @Override\n    public void flatMap(Tuple2<Long, Long> element, Collector<Tuple2<Long, Double>> out) throws Exception {\n        Tuple2<Long, Long> currentState = countAndSum.value();\n        if (currentState == null) {\n            currentState = Tuple2.of(0L, 0L);\n        }\n\n        currentState.f0 += 1;\n        currentState.f1 += element.f1;\n\n        countAndSum.update(currentState);\n\n        if (currentState.f0 >= 3) {\n            double avg = (double)currentState.f1 / currentState.f0;\n            out.collect(Tuple2.of(element.f0, avg));\n            countAndSum.clear();\n        }\n    }\n}\n```","source":"_posts/flink/Flink-5-State.md","raw":"---\ntitle: Flink 5. State\ndate: 2020-12-09 17:03:21\ntags:\n---\n\n示例： 利用ValueState，保存之前运算结果，并在条件满足后输出\n\n```java\nConfiguration configuration = new Configuration();\nStreamExecutionEnvironment env = StreamExecutionEnvironment.createLocalEnvironmentWithWebUI(configuration);\nenv.setParallelism(2);\n\nDataStream<Tuple2<Long, Long>> dataStream =\n    env.fromElements(\n        Tuple2.of(1L, 3L),\n        Tuple2.of(1L, 5L),\n        Tuple2.of(2L, 6L),\n        Tuple2.of(2L, 2L),\n        Tuple2.of(2L, 4L),\n        Tuple2.of(1L, 7L));\n\ndataStream.keyBy(0).flatMap(new CountAverageWithValueState()).print();\n\nenv.execute(\"Test state\");\n```\n\n```java\nimport org.apache.flink.api.common.functions.RichFlatMapFunction;\nimport org.apache.flink.api.common.state.ValueState;\nimport org.apache.flink.api.common.state.ValueStateDescriptor;\nimport org.apache.flink.api.common.typeinfo.Types;\nimport org.apache.flink.api.java.tuple.Tuple2;\nimport org.apache.flink.configuration.Configuration;\nimport org.apache.flink.util.Collector;\n\n\npublic class CountAverageWithValueState extends RichFlatMapFunction<Tuple2<Long, Long>, Tuple2<Long, Double>> {\n\n    private ValueState<Tuple2<Long,Long>> countAndSum;\n\n    @Override\n    public void open(Configuration parameters) throws Exception {\n        ValueStateDescriptor<Tuple2<Long,Long>> descriptor = new ValueStateDescriptor<Tuple2<Long, Long>>(\"average\",\n            Types.TUPLE(Types.LONG, Types.LONG));\n        countAndSum = getRuntimeContext().getState(descriptor);\n    }\n\n    @Override\n    public void flatMap(Tuple2<Long, Long> element, Collector<Tuple2<Long, Double>> out) throws Exception {\n        Tuple2<Long, Long> currentState = countAndSum.value();\n        if (currentState == null) {\n            currentState = Tuple2.of(0L, 0L);\n        }\n\n        currentState.f0 += 1;\n        currentState.f1 += element.f1;\n\n        countAndSum.update(currentState);\n\n        if (currentState.f0 >= 3) {\n            double avg = (double)currentState.f1 / currentState.f0;\n            out.collect(Tuple2.of(element.f0, avg));\n            countAndSum.clear();\n        }\n    }\n}\n```","slug":"flink/Flink-5-State","published":1,"updated":"2020-12-09T09:05:27.628Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckio9dwf40049k8nez5erjfbo","content":"<p>示例： 利用ValueState，保存之前运算结果，并在条件满足后输出</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Configuration configuration = <span class=\"keyword\">new</span> Configuration();</span><br><span class=\"line\">StreamExecutionEnvironment env = StreamExecutionEnvironment.createLocalEnvironmentWithWebUI(configuration);</span><br><span class=\"line\">env.setParallelism(<span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">DataStream&lt;Tuple2&lt;Long, Long&gt;&gt; dataStream =</span><br><span class=\"line\">    env.fromElements(</span><br><span class=\"line\">        Tuple2.of(<span class=\"number\">1L</span>, <span class=\"number\">3L</span>),</span><br><span class=\"line\">        Tuple2.of(<span class=\"number\">1L</span>, <span class=\"number\">5L</span>),</span><br><span class=\"line\">        Tuple2.of(<span class=\"number\">2L</span>, <span class=\"number\">6L</span>),</span><br><span class=\"line\">        Tuple2.of(<span class=\"number\">2L</span>, <span class=\"number\">2L</span>),</span><br><span class=\"line\">        Tuple2.of(<span class=\"number\">2L</span>, <span class=\"number\">4L</span>),</span><br><span class=\"line\">        Tuple2.of(<span class=\"number\">1L</span>, <span class=\"number\">7L</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">dataStream.keyBy(<span class=\"number\">0</span>).flatMap(<span class=\"keyword\">new</span> CountAverageWithValueState()).print();</span><br><span class=\"line\"></span><br><span class=\"line\">env.execute(<span class=\"string\">\"Test state\"</span>);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.apache.flink.api.common.functions.RichFlatMapFunction;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.flink.api.common.state.ValueState;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.flink.api.common.state.ValueStateDescriptor;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.flink.api.common.typeinfo.Types;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.flink.api.java.tuple.Tuple2;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.flink.configuration.Configuration;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.flink.util.Collector;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CountAverageWithValueState</span> <span class=\"keyword\">extends</span> <span class=\"title\">RichFlatMapFunction</span>&lt;<span class=\"title\">Tuple2</span>&lt;<span class=\"title\">Long</span>, <span class=\"title\">Long</span>&gt;, <span class=\"title\">Tuple2</span>&lt;<span class=\"title\">Long</span>, <span class=\"title\">Double</span>&gt;&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ValueState&lt;Tuple2&lt;Long,Long&gt;&gt; countAndSum;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">open</span><span class=\"params\">(Configuration parameters)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        ValueStateDescriptor&lt;Tuple2&lt;Long,Long&gt;&gt; descriptor = <span class=\"keyword\">new</span> ValueStateDescriptor&lt;Tuple2&lt;Long, Long&gt;&gt;(<span class=\"string\">\"average\"</span>,</span><br><span class=\"line\">            Types.TUPLE(Types.LONG, Types.LONG));</span><br><span class=\"line\">        countAndSum = getRuntimeContext().getState(descriptor);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">flatMap</span><span class=\"params\">(Tuple2&lt;Long, Long&gt; element, Collector&lt;Tuple2&lt;Long, Double&gt;&gt; out)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        Tuple2&lt;Long, Long&gt; currentState = countAndSum.value();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (currentState == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            currentState = Tuple2.of(<span class=\"number\">0L</span>, <span class=\"number\">0L</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        currentState.f0 += <span class=\"number\">1</span>;</span><br><span class=\"line\">        currentState.f1 += element.f1;</span><br><span class=\"line\"></span><br><span class=\"line\">        countAndSum.update(currentState);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (currentState.f0 &gt;= <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">double</span> avg = (<span class=\"keyword\">double</span>)currentState.f1 / currentState.f0;</span><br><span class=\"line\">            out.collect(Tuple2.of(element.f0, avg));</span><br><span class=\"line\">            countAndSum.clear();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>示例： 利用ValueState，保存之前运算结果，并在条件满足后输出</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Configuration configuration = <span class=\"keyword\">new</span> Configuration();</span><br><span class=\"line\">StreamExecutionEnvironment env = StreamExecutionEnvironment.createLocalEnvironmentWithWebUI(configuration);</span><br><span class=\"line\">env.setParallelism(<span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">DataStream&lt;Tuple2&lt;Long, Long&gt;&gt; dataStream =</span><br><span class=\"line\">    env.fromElements(</span><br><span class=\"line\">        Tuple2.of(<span class=\"number\">1L</span>, <span class=\"number\">3L</span>),</span><br><span class=\"line\">        Tuple2.of(<span class=\"number\">1L</span>, <span class=\"number\">5L</span>),</span><br><span class=\"line\">        Tuple2.of(<span class=\"number\">2L</span>, <span class=\"number\">6L</span>),</span><br><span class=\"line\">        Tuple2.of(<span class=\"number\">2L</span>, <span class=\"number\">2L</span>),</span><br><span class=\"line\">        Tuple2.of(<span class=\"number\">2L</span>, <span class=\"number\">4L</span>),</span><br><span class=\"line\">        Tuple2.of(<span class=\"number\">1L</span>, <span class=\"number\">7L</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">dataStream.keyBy(<span class=\"number\">0</span>).flatMap(<span class=\"keyword\">new</span> CountAverageWithValueState()).print();</span><br><span class=\"line\"></span><br><span class=\"line\">env.execute(<span class=\"string\">\"Test state\"</span>);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.apache.flink.api.common.functions.RichFlatMapFunction;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.flink.api.common.state.ValueState;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.flink.api.common.state.ValueStateDescriptor;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.flink.api.common.typeinfo.Types;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.flink.api.java.tuple.Tuple2;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.flink.configuration.Configuration;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.flink.util.Collector;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CountAverageWithValueState</span> <span class=\"keyword\">extends</span> <span class=\"title\">RichFlatMapFunction</span>&lt;<span class=\"title\">Tuple2</span>&lt;<span class=\"title\">Long</span>, <span class=\"title\">Long</span>&gt;, <span class=\"title\">Tuple2</span>&lt;<span class=\"title\">Long</span>, <span class=\"title\">Double</span>&gt;&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ValueState&lt;Tuple2&lt;Long,Long&gt;&gt; countAndSum;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">open</span><span class=\"params\">(Configuration parameters)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        ValueStateDescriptor&lt;Tuple2&lt;Long,Long&gt;&gt; descriptor = <span class=\"keyword\">new</span> ValueStateDescriptor&lt;Tuple2&lt;Long, Long&gt;&gt;(<span class=\"string\">\"average\"</span>,</span><br><span class=\"line\">            Types.TUPLE(Types.LONG, Types.LONG));</span><br><span class=\"line\">        countAndSum = getRuntimeContext().getState(descriptor);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">flatMap</span><span class=\"params\">(Tuple2&lt;Long, Long&gt; element, Collector&lt;Tuple2&lt;Long, Double&gt;&gt; out)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        Tuple2&lt;Long, Long&gt; currentState = countAndSum.value();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (currentState == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            currentState = Tuple2.of(<span class=\"number\">0L</span>, <span class=\"number\">0L</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        currentState.f0 += <span class=\"number\">1</span>;</span><br><span class=\"line\">        currentState.f1 += element.f1;</span><br><span class=\"line\"></span><br><span class=\"line\">        countAndSum.update(currentState);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (currentState.f0 &gt;= <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">double</span> avg = (<span class=\"keyword\">double</span>)currentState.f1 / currentState.f0;</span><br><span class=\"line\">            out.collect(Tuple2.of(element.f0, avg));</span><br><span class=\"line\">            countAndSum.clear();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Kong路由配置策略及JWT校验","date":"2019-11-17T13:28:28.000Z","_content":"","source":"_posts/microservice/Kong路由配置策略及JWT校验.md","raw":"---\ntitle: Kong路由配置策略及JWT校验\ndate: 2019-11-17 21:28:28\ntags:\n---\n","slug":"microservice/Kong路由配置策略及JWT校验","published":1,"updated":"2020-10-27T08:08:15.941Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckio9dwf6004ck8neq2unvs1d","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Flink 1. 基本架构","date":"2020-08-30T02:32:43.000Z","_content":"\n### 编程模型\n\nFlink提供了不同级别的抽象, 以开发流或批处理作业.\n\n![layered api](https://tva1.sinaimg.cn/large/007S8ZIlly1gj7iu5z64rj30r20bemy5.jpg)\n\n#### ProcessFunction\n\n* 最底层, 最具表达力的接口\n* 提供了对于时间和状态的细粒度控制\n* 可以用来实现许多有状态的事件驱动应用所需要的基于单个事件的复杂业务逻辑\n\n#### DataStream API && DataSet API\n\n* 核心API\n* 提供了通用的构建模块,比如transformations, joins, aggregations, windows等\n* DataSet API为有界数据集提供了额外的支持\n<!--more-->\n#### Table API && SQL\n\n* 关系型API, 最简洁, 但不如核心API更具表达能力\n* Table API以表为中心, 其中表在表达流数据时可以动态变化(Dynamic Table)\n* table与DataStream/DataSet可以无缝切换\n* 旨在简化数据分析、数据流水线和 ETL 应用的定义\n\n### Flink体系组件\n\n#### JobManager(Master)\n\n协调分布式执行, 进程由以下三个组件构成:\n\n* ResourceManager\n\n管理 **task slots**(向资源提供平台申请, 分配空闲slot, 终止空闲的TaskManger). Flink扩展了几种不同对资源管理器: Yarn, Mesos, k8s, standalone部署.\n\n* Dispatcher\n\n提供了REST接口为每个提交的任务启动一个JobMaster. \n\n也会启动一个WebUI.\n\n* JobMaster\n\n管理运行时的JobGraph. Flink集群中并行运行的每个job都有自己的JobManager.\n\n至少存在一个 JobManager, 高可用模式下, 可存在多个 JobManager, 其中一个是leader, 其它的都是standby.\n\n#### TaskManager(Workers)\n\n* 执行一个dataflow的task(或者特殊的subtask)、数据缓冲和datastream交换\n* 运行时至少存在一个worker处理器\n\n#### Clients\n\nFlink提供了丰富的客户端操作提交任务和任务交互.\n\n* Flink CommandLine\n* Scala Shell, 提交Table API的任务\n* SQL Client, 提交SQL任务\n* RestFul API, 让用户通过http调用\n* Web, 页面交互\n\n![Flink component](https://tva1.sinaimg.cn/large/007S8ZIlly1gj7gl0iajpj30nn0h1wga.jpg)\n\n### 任务执行\n\n#### Operators\n\n出于分布式执行的目的, Flink将operator的subtask链接在一起形成task, 每个task在一个线程中执行.\n\n好处:\n\n* 减少线程间的的切换和基于缓存区的数据交换, 减少时延的同时提升吞吐量\n下面这幅图，展示了 5 个 subtask 以 5 个并行的线程来执行:\n![operators](https://tva1.sinaimg.cn/large/007S8ZIlly1gj7hrb734lj30g00b1t9p.jpg)\n\n#### Tasks\n\n##### Setting Parallelism\n\n一个特定算子的子任务(subtask)的个数被称之为其并行度(parallelism).\n\n任务的并行度可以在Flink不同的级别设置: \n\n* Operator Level - source和sink均可调用`setParallelism()`方法\n\n* Execution Enviroment Level, 调用`env.setParallelism()`方法\n\n* Client Level, 可通过CLI中 `-p`参数,  或者代码中设置\n\n如:\n\n`./bin/flink run -p 10 ../examples/*WordCount-java*.jar`,\n\n`client.run(program, 10, true);`\n\n* System Level(set parallelism.default in flink-conf.yaml)\n\n#### Slots and Resources\n\nFlink 中每一个 worker(TaskManager)都是一个**JVM 进程**，它可能会在**独立的线程**上执行一个或多个 subtask。\n\n每个 task slot 表示 TaskManager 拥有资源的**一个固定大小的子集**, slot 目前仅仅用来隔离 task 的受管理的**内存**。\n\n通过调整 task slot 的数量，允许用户定义 subtask 之间如何互相隔离:\n\n* 一个 TaskManager 一个 slot，意味着每个 task group 运行在独立的 JVM 中\n![task-slot](https://tva1.sinaimg.cn/large/007S8ZIlly1gj7k70qyjij30pn086q45.jpg)\n\n* 一个 TaskManager 多个 slot  意味着更多的 subtask 可以共享同一个 JVM。而在同一个 JVM 进程中的 task 将**共享 TCP 连接(基于多路复用)和心跳消息**。它们也可能共享数据集和数据结构，因此这减少了每个 task 的负载。\n![slot-sharing](https://tva1.sinaimg.cn/large/007S8ZIlly1gj7k7s4aylj30pn0bwgoi.jpg)\n\n> Task Slot 是静态的概念，是指 TaskManager 具有的并发执行能力，可以通过 参数 taskmanager.numberOfTaskSlots 进行配置;\n> 而并行度 parallelism 是动态概念， 即 TaskManager 运行程序时实际使用的并发能力\n\n#### Task Failure Recovery\n\n* Restart Strategies\n\n* Failover Strategies\n","source":"_posts/flink/Flink-1-Flink基本架构.md","raw":"---\ntitle: Flink 1. 基本架构\ndate: 2020-08-30 10:32:43\ncategories: 流计算\ntags: \n- Flink\n---\n\n### 编程模型\n\nFlink提供了不同级别的抽象, 以开发流或批处理作业.\n\n![layered api](https://tva1.sinaimg.cn/large/007S8ZIlly1gj7iu5z64rj30r20bemy5.jpg)\n\n#### ProcessFunction\n\n* 最底层, 最具表达力的接口\n* 提供了对于时间和状态的细粒度控制\n* 可以用来实现许多有状态的事件驱动应用所需要的基于单个事件的复杂业务逻辑\n\n#### DataStream API && DataSet API\n\n* 核心API\n* 提供了通用的构建模块,比如transformations, joins, aggregations, windows等\n* DataSet API为有界数据集提供了额外的支持\n<!--more-->\n#### Table API && SQL\n\n* 关系型API, 最简洁, 但不如核心API更具表达能力\n* Table API以表为中心, 其中表在表达流数据时可以动态变化(Dynamic Table)\n* table与DataStream/DataSet可以无缝切换\n* 旨在简化数据分析、数据流水线和 ETL 应用的定义\n\n### Flink体系组件\n\n#### JobManager(Master)\n\n协调分布式执行, 进程由以下三个组件构成:\n\n* ResourceManager\n\n管理 **task slots**(向资源提供平台申请, 分配空闲slot, 终止空闲的TaskManger). Flink扩展了几种不同对资源管理器: Yarn, Mesos, k8s, standalone部署.\n\n* Dispatcher\n\n提供了REST接口为每个提交的任务启动一个JobMaster. \n\n也会启动一个WebUI.\n\n* JobMaster\n\n管理运行时的JobGraph. Flink集群中并行运行的每个job都有自己的JobManager.\n\n至少存在一个 JobManager, 高可用模式下, 可存在多个 JobManager, 其中一个是leader, 其它的都是standby.\n\n#### TaskManager(Workers)\n\n* 执行一个dataflow的task(或者特殊的subtask)、数据缓冲和datastream交换\n* 运行时至少存在一个worker处理器\n\n#### Clients\n\nFlink提供了丰富的客户端操作提交任务和任务交互.\n\n* Flink CommandLine\n* Scala Shell, 提交Table API的任务\n* SQL Client, 提交SQL任务\n* RestFul API, 让用户通过http调用\n* Web, 页面交互\n\n![Flink component](https://tva1.sinaimg.cn/large/007S8ZIlly1gj7gl0iajpj30nn0h1wga.jpg)\n\n### 任务执行\n\n#### Operators\n\n出于分布式执行的目的, Flink将operator的subtask链接在一起形成task, 每个task在一个线程中执行.\n\n好处:\n\n* 减少线程间的的切换和基于缓存区的数据交换, 减少时延的同时提升吞吐量\n下面这幅图，展示了 5 个 subtask 以 5 个并行的线程来执行:\n![operators](https://tva1.sinaimg.cn/large/007S8ZIlly1gj7hrb734lj30g00b1t9p.jpg)\n\n#### Tasks\n\n##### Setting Parallelism\n\n一个特定算子的子任务(subtask)的个数被称之为其并行度(parallelism).\n\n任务的并行度可以在Flink不同的级别设置: \n\n* Operator Level - source和sink均可调用`setParallelism()`方法\n\n* Execution Enviroment Level, 调用`env.setParallelism()`方法\n\n* Client Level, 可通过CLI中 `-p`参数,  或者代码中设置\n\n如:\n\n`./bin/flink run -p 10 ../examples/*WordCount-java*.jar`,\n\n`client.run(program, 10, true);`\n\n* System Level(set parallelism.default in flink-conf.yaml)\n\n#### Slots and Resources\n\nFlink 中每一个 worker(TaskManager)都是一个**JVM 进程**，它可能会在**独立的线程**上执行一个或多个 subtask。\n\n每个 task slot 表示 TaskManager 拥有资源的**一个固定大小的子集**, slot 目前仅仅用来隔离 task 的受管理的**内存**。\n\n通过调整 task slot 的数量，允许用户定义 subtask 之间如何互相隔离:\n\n* 一个 TaskManager 一个 slot，意味着每个 task group 运行在独立的 JVM 中\n![task-slot](https://tva1.sinaimg.cn/large/007S8ZIlly1gj7k70qyjij30pn086q45.jpg)\n\n* 一个 TaskManager 多个 slot  意味着更多的 subtask 可以共享同一个 JVM。而在同一个 JVM 进程中的 task 将**共享 TCP 连接(基于多路复用)和心跳消息**。它们也可能共享数据集和数据结构，因此这减少了每个 task 的负载。\n![slot-sharing](https://tva1.sinaimg.cn/large/007S8ZIlly1gj7k7s4aylj30pn0bwgoi.jpg)\n\n> Task Slot 是静态的概念，是指 TaskManager 具有的并发执行能力，可以通过 参数 taskmanager.numberOfTaskSlots 进行配置;\n> 而并行度 parallelism 是动态概念， 即 TaskManager 运行程序时实际使用的并发能力\n\n#### Task Failure Recovery\n\n* Restart Strategies\n\n* Failover Strategies\n","slug":"flink/Flink-1-Flink基本架构","published":1,"updated":"2020-10-27T08:08:15.938Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckio9dwf8004gk8nep3q14dq4","content":"<h3 id=\"编程模型\"><a href=\"#编程模型\" class=\"headerlink\" title=\"编程模型\"></a>编程模型</h3><p>Flink提供了不同级别的抽象, 以开发流或批处理作业.</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/007S8ZIlly1gj7iu5z64rj30r20bemy5.jpg\" alt=\"layered api\"></p>\n<h4 id=\"ProcessFunction\"><a href=\"#ProcessFunction\" class=\"headerlink\" title=\"ProcessFunction\"></a>ProcessFunction</h4><ul>\n<li>最底层, 最具表达力的接口</li>\n<li>提供了对于时间和状态的细粒度控制</li>\n<li>可以用来实现许多有状态的事件驱动应用所需要的基于单个事件的复杂业务逻辑</li>\n</ul>\n<h4 id=\"DataStream-API-amp-amp-DataSet-API\"><a href=\"#DataStream-API-amp-amp-DataSet-API\" class=\"headerlink\" title=\"DataStream API &amp;&amp; DataSet API\"></a>DataStream API &amp;&amp; DataSet API</h4><ul>\n<li><p>核心API</p>\n</li>\n<li><p>提供了通用的构建模块,比如transformations, joins, aggregations, windows等</p>\n</li>\n<li><p>DataSet API为有界数据集提供了额外的支持</p>\n<a id=\"more\"></a>\n<h4 id=\"Table-API-amp-amp-SQL\"><a href=\"#Table-API-amp-amp-SQL\" class=\"headerlink\" title=\"Table API &amp;&amp; SQL\"></a>Table API &amp;&amp; SQL</h4></li>\n<li><p>关系型API, 最简洁, 但不如核心API更具表达能力</p>\n</li>\n<li><p>Table API以表为中心, 其中表在表达流数据时可以动态变化(Dynamic Table)</p>\n</li>\n<li><p>table与DataStream/DataSet可以无缝切换</p>\n</li>\n<li><p>旨在简化数据分析、数据流水线和 ETL 应用的定义</p>\n</li>\n</ul>\n<h3 id=\"Flink体系组件\"><a href=\"#Flink体系组件\" class=\"headerlink\" title=\"Flink体系组件\"></a>Flink体系组件</h3><h4 id=\"JobManager-Master\"><a href=\"#JobManager-Master\" class=\"headerlink\" title=\"JobManager(Master)\"></a>JobManager(Master)</h4><p>协调分布式执行, 进程由以下三个组件构成:</p>\n<ul>\n<li>ResourceManager</li>\n</ul>\n<p>管理 <strong>task slots</strong>(向资源提供平台申请, 分配空闲slot, 终止空闲的TaskManger). Flink扩展了几种不同对资源管理器: Yarn, Mesos, k8s, standalone部署.</p>\n<ul>\n<li>Dispatcher</li>\n</ul>\n<p>提供了REST接口为每个提交的任务启动一个JobMaster. </p>\n<p>也会启动一个WebUI.</p>\n<ul>\n<li>JobMaster</li>\n</ul>\n<p>管理运行时的JobGraph. Flink集群中并行运行的每个job都有自己的JobManager.</p>\n<p>至少存在一个 JobManager, 高可用模式下, 可存在多个 JobManager, 其中一个是leader, 其它的都是standby.</p>\n<h4 id=\"TaskManager-Workers\"><a href=\"#TaskManager-Workers\" class=\"headerlink\" title=\"TaskManager(Workers)\"></a>TaskManager(Workers)</h4><ul>\n<li>执行一个dataflow的task(或者特殊的subtask)、数据缓冲和datastream交换</li>\n<li>运行时至少存在一个worker处理器</li>\n</ul>\n<h4 id=\"Clients\"><a href=\"#Clients\" class=\"headerlink\" title=\"Clients\"></a>Clients</h4><p>Flink提供了丰富的客户端操作提交任务和任务交互.</p>\n<ul>\n<li>Flink CommandLine</li>\n<li>Scala Shell, 提交Table API的任务</li>\n<li>SQL Client, 提交SQL任务</li>\n<li>RestFul API, 让用户通过http调用</li>\n<li>Web, 页面交互</li>\n</ul>\n<p><img src=\"https://tva1.sinaimg.cn/large/007S8ZIlly1gj7gl0iajpj30nn0h1wga.jpg\" alt=\"Flink component\"></p>\n<h3 id=\"任务执行\"><a href=\"#任务执行\" class=\"headerlink\" title=\"任务执行\"></a>任务执行</h3><h4 id=\"Operators\"><a href=\"#Operators\" class=\"headerlink\" title=\"Operators\"></a>Operators</h4><p>出于分布式执行的目的, Flink将operator的subtask链接在一起形成task, 每个task在一个线程中执行.</p>\n<p>好处:</p>\n<ul>\n<li>减少线程间的的切换和基于缓存区的数据交换, 减少时延的同时提升吞吐量<br>下面这幅图，展示了 5 个 subtask 以 5 个并行的线程来执行:<br><img src=\"https://tva1.sinaimg.cn/large/007S8ZIlly1gj7hrb734lj30g00b1t9p.jpg\" alt=\"operators\"></li>\n</ul>\n<h4 id=\"Tasks\"><a href=\"#Tasks\" class=\"headerlink\" title=\"Tasks\"></a>Tasks</h4><h5 id=\"Setting-Parallelism\"><a href=\"#Setting-Parallelism\" class=\"headerlink\" title=\"Setting Parallelism\"></a>Setting Parallelism</h5><p>一个特定算子的子任务(subtask)的个数被称之为其并行度(parallelism).</p>\n<p>任务的并行度可以在Flink不同的级别设置: </p>\n<ul>\n<li><p>Operator Level - source和sink均可调用<code>setParallelism()</code>方法</p>\n</li>\n<li><p>Execution Enviroment Level, 调用<code>env.setParallelism()</code>方法</p>\n</li>\n<li><p>Client Level, 可通过CLI中 <code>-p</code>参数,  或者代码中设置</p>\n</li>\n</ul>\n<p>如:</p>\n<p><code>./bin/flink run -p 10 ../examples/*WordCount-java*.jar</code>,</p>\n<p><code>client.run(program, 10, true);</code></p>\n<ul>\n<li>System Level(set parallelism.default in flink-conf.yaml)</li>\n</ul>\n<h4 id=\"Slots-and-Resources\"><a href=\"#Slots-and-Resources\" class=\"headerlink\" title=\"Slots and Resources\"></a>Slots and Resources</h4><p>Flink 中每一个 worker(TaskManager)都是一个<strong>JVM 进程</strong>，它可能会在<strong>独立的线程</strong>上执行一个或多个 subtask。</p>\n<p>每个 task slot 表示 TaskManager 拥有资源的<strong>一个固定大小的子集</strong>, slot 目前仅仅用来隔离 task 的受管理的<strong>内存</strong>。</p>\n<p>通过调整 task slot 的数量，允许用户定义 subtask 之间如何互相隔离:</p>\n<ul>\n<li><p>一个 TaskManager 一个 slot，意味着每个 task group 运行在独立的 JVM 中<br><img src=\"https://tva1.sinaimg.cn/large/007S8ZIlly1gj7k70qyjij30pn086q45.jpg\" alt=\"task-slot\"></p>\n</li>\n<li><p>一个 TaskManager 多个 slot  意味着更多的 subtask 可以共享同一个 JVM。而在同一个 JVM 进程中的 task 将<strong>共享 TCP 连接(基于多路复用)和心跳消息</strong>。它们也可能共享数据集和数据结构，因此这减少了每个 task 的负载。<br><img src=\"https://tva1.sinaimg.cn/large/007S8ZIlly1gj7k7s4aylj30pn0bwgoi.jpg\" alt=\"slot-sharing\"></p>\n</li>\n</ul>\n<blockquote>\n<p>Task Slot 是静态的概念，是指 TaskManager 具有的并发执行能力，可以通过 参数 taskmanager.numberOfTaskSlots 进行配置;<br>而并行度 parallelism 是动态概念， 即 TaskManager 运行程序时实际使用的并发能力</p>\n</blockquote>\n<h4 id=\"Task-Failure-Recovery\"><a href=\"#Task-Failure-Recovery\" class=\"headerlink\" title=\"Task Failure Recovery\"></a>Task Failure Recovery</h4><ul>\n<li><p>Restart Strategies</p>\n</li>\n<li><p>Failover Strategies</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h3 id=\"编程模型\"><a href=\"#编程模型\" class=\"headerlink\" title=\"编程模型\"></a>编程模型</h3><p>Flink提供了不同级别的抽象, 以开发流或批处理作业.</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/007S8ZIlly1gj7iu5z64rj30r20bemy5.jpg\" alt=\"layered api\"></p>\n<h4 id=\"ProcessFunction\"><a href=\"#ProcessFunction\" class=\"headerlink\" title=\"ProcessFunction\"></a>ProcessFunction</h4><ul>\n<li>最底层, 最具表达力的接口</li>\n<li>提供了对于时间和状态的细粒度控制</li>\n<li>可以用来实现许多有状态的事件驱动应用所需要的基于单个事件的复杂业务逻辑</li>\n</ul>\n<h4 id=\"DataStream-API-amp-amp-DataSet-API\"><a href=\"#DataStream-API-amp-amp-DataSet-API\" class=\"headerlink\" title=\"DataStream API &amp;&amp; DataSet API\"></a>DataStream API &amp;&amp; DataSet API</h4><ul>\n<li><p>核心API</p>\n</li>\n<li><p>提供了通用的构建模块,比如transformations, joins, aggregations, windows等</p>\n</li>\n<li><p>DataSet API为有界数据集提供了额外的支持</p>","more":"<h4 id=\"Table-API-amp-amp-SQL\"><a href=\"#Table-API-amp-amp-SQL\" class=\"headerlink\" title=\"Table API &amp;&amp; SQL\"></a>Table API &amp;&amp; SQL</h4></li>\n<li><p>关系型API, 最简洁, 但不如核心API更具表达能力</p>\n</li>\n<li><p>Table API以表为中心, 其中表在表达流数据时可以动态变化(Dynamic Table)</p>\n</li>\n<li><p>table与DataStream/DataSet可以无缝切换</p>\n</li>\n<li><p>旨在简化数据分析、数据流水线和 ETL 应用的定义</p>\n</li>\n</ul>\n<h3 id=\"Flink体系组件\"><a href=\"#Flink体系组件\" class=\"headerlink\" title=\"Flink体系组件\"></a>Flink体系组件</h3><h4 id=\"JobManager-Master\"><a href=\"#JobManager-Master\" class=\"headerlink\" title=\"JobManager(Master)\"></a>JobManager(Master)</h4><p>协调分布式执行, 进程由以下三个组件构成:</p>\n<ul>\n<li>ResourceManager</li>\n</ul>\n<p>管理 <strong>task slots</strong>(向资源提供平台申请, 分配空闲slot, 终止空闲的TaskManger). Flink扩展了几种不同对资源管理器: Yarn, Mesos, k8s, standalone部署.</p>\n<ul>\n<li>Dispatcher</li>\n</ul>\n<p>提供了REST接口为每个提交的任务启动一个JobMaster. </p>\n<p>也会启动一个WebUI.</p>\n<ul>\n<li>JobMaster</li>\n</ul>\n<p>管理运行时的JobGraph. Flink集群中并行运行的每个job都有自己的JobManager.</p>\n<p>至少存在一个 JobManager, 高可用模式下, 可存在多个 JobManager, 其中一个是leader, 其它的都是standby.</p>\n<h4 id=\"TaskManager-Workers\"><a href=\"#TaskManager-Workers\" class=\"headerlink\" title=\"TaskManager(Workers)\"></a>TaskManager(Workers)</h4><ul>\n<li>执行一个dataflow的task(或者特殊的subtask)、数据缓冲和datastream交换</li>\n<li>运行时至少存在一个worker处理器</li>\n</ul>\n<h4 id=\"Clients\"><a href=\"#Clients\" class=\"headerlink\" title=\"Clients\"></a>Clients</h4><p>Flink提供了丰富的客户端操作提交任务和任务交互.</p>\n<ul>\n<li>Flink CommandLine</li>\n<li>Scala Shell, 提交Table API的任务</li>\n<li>SQL Client, 提交SQL任务</li>\n<li>RestFul API, 让用户通过http调用</li>\n<li>Web, 页面交互</li>\n</ul>\n<p><img src=\"https://tva1.sinaimg.cn/large/007S8ZIlly1gj7gl0iajpj30nn0h1wga.jpg\" alt=\"Flink component\"></p>\n<h3 id=\"任务执行\"><a href=\"#任务执行\" class=\"headerlink\" title=\"任务执行\"></a>任务执行</h3><h4 id=\"Operators\"><a href=\"#Operators\" class=\"headerlink\" title=\"Operators\"></a>Operators</h4><p>出于分布式执行的目的, Flink将operator的subtask链接在一起形成task, 每个task在一个线程中执行.</p>\n<p>好处:</p>\n<ul>\n<li>减少线程间的的切换和基于缓存区的数据交换, 减少时延的同时提升吞吐量<br>下面这幅图，展示了 5 个 subtask 以 5 个并行的线程来执行:<br><img src=\"https://tva1.sinaimg.cn/large/007S8ZIlly1gj7hrb734lj30g00b1t9p.jpg\" alt=\"operators\"></li>\n</ul>\n<h4 id=\"Tasks\"><a href=\"#Tasks\" class=\"headerlink\" title=\"Tasks\"></a>Tasks</h4><h5 id=\"Setting-Parallelism\"><a href=\"#Setting-Parallelism\" class=\"headerlink\" title=\"Setting Parallelism\"></a>Setting Parallelism</h5><p>一个特定算子的子任务(subtask)的个数被称之为其并行度(parallelism).</p>\n<p>任务的并行度可以在Flink不同的级别设置: </p>\n<ul>\n<li><p>Operator Level - source和sink均可调用<code>setParallelism()</code>方法</p>\n</li>\n<li><p>Execution Enviroment Level, 调用<code>env.setParallelism()</code>方法</p>\n</li>\n<li><p>Client Level, 可通过CLI中 <code>-p</code>参数,  或者代码中设置</p>\n</li>\n</ul>\n<p>如:</p>\n<p><code>./bin/flink run -p 10 ../examples/*WordCount-java*.jar</code>,</p>\n<p><code>client.run(program, 10, true);</code></p>\n<ul>\n<li>System Level(set parallelism.default in flink-conf.yaml)</li>\n</ul>\n<h4 id=\"Slots-and-Resources\"><a href=\"#Slots-and-Resources\" class=\"headerlink\" title=\"Slots and Resources\"></a>Slots and Resources</h4><p>Flink 中每一个 worker(TaskManager)都是一个<strong>JVM 进程</strong>，它可能会在<strong>独立的线程</strong>上执行一个或多个 subtask。</p>\n<p>每个 task slot 表示 TaskManager 拥有资源的<strong>一个固定大小的子集</strong>, slot 目前仅仅用来隔离 task 的受管理的<strong>内存</strong>。</p>\n<p>通过调整 task slot 的数量，允许用户定义 subtask 之间如何互相隔离:</p>\n<ul>\n<li><p>一个 TaskManager 一个 slot，意味着每个 task group 运行在独立的 JVM 中<br><img src=\"https://tva1.sinaimg.cn/large/007S8ZIlly1gj7k70qyjij30pn086q45.jpg\" alt=\"task-slot\"></p>\n</li>\n<li><p>一个 TaskManager 多个 slot  意味着更多的 subtask 可以共享同一个 JVM。而在同一个 JVM 进程中的 task 将<strong>共享 TCP 连接(基于多路复用)和心跳消息</strong>。它们也可能共享数据集和数据结构，因此这减少了每个 task 的负载。<br><img src=\"https://tva1.sinaimg.cn/large/007S8ZIlly1gj7k7s4aylj30pn0bwgoi.jpg\" alt=\"slot-sharing\"></p>\n</li>\n</ul>\n<blockquote>\n<p>Task Slot 是静态的概念，是指 TaskManager 具有的并发执行能力，可以通过 参数 taskmanager.numberOfTaskSlots 进行配置;<br>而并行度 parallelism 是动态概念， 即 TaskManager 运行程序时实际使用的并发能力</p>\n</blockquote>\n<h4 id=\"Task-Failure-Recovery\"><a href=\"#Task-Failure-Recovery\" class=\"headerlink\" title=\"Task Failure Recovery\"></a>Task Failure Recovery</h4><ul>\n<li><p>Restart Strategies</p>\n</li>\n<li><p>Failover Strategies</p>\n</li>\n</ul>"},{"title":"Flink CDC踩坑集合","date":"2020-12-11T09:02:47.000Z","_content":"\n1. 使用flink sql 时，提前引入flink-json依赖\n\n异常信息\n\n```\nCaused by: org.apache.flink.table.api.ValidationException: Could not find any factories that implement 'org.apache.flink.table.factories.DeserializationFormatFactory' in the classpath.\n\tat org.apache.flink.table.factories.FactoryUtil.discoverFactory(FactoryUtil.java:229)\n\tat org.apache.flink.table.factories.FactoryUtil$TableFactoryHelper.discoverOptionalFormatFactory(FactoryUtil.java:538)\n\tat org.apache.flink.table.factories.FactoryUtil$TableFactoryHelper.discoverOptionalDecodingFormat(FactoryUtil.java:426)\n\tat org.apache.flink.table.factories.FactoryUtil$TableFactoryHelper.discoverDecodingFormat(FactoryUtil.java:413)\n\tat org.apache.flink.streaming.connectors.kafka.table.KafkaDynamicTableFactoryBase.createDynamicTableSource(KafkaDynamicTableFactoryBase.java:73)\n\tat org.apache.flink.table.factories.FactoryUtil.createTableSource(FactoryUtil.java:122)\n\t  \n```\n\n解决方案： pom文件中引入\n\n```xml\n<dependency>\n    <groupId>org.apache.flink</groupId>\n    <artifactId>flink-json</artifactId>\n    <version>1.11.0</version>\n</dependency>\n```\n\n2. Flink 1.11版本后简化了 connector 参数\n\nFlink由于发展太快（2020年已经发布了1.10，1.11，1.12三个大版本），很多2020年初的blog提供教程已经面临失效\n\n以 Kafka 为例，在 1.11 版本之前用户的 DDL 需要声明成如下方式\n\n```sql\n CREATE TABLE user_behavior (\n  ...\n) WITH (\n  'connector.type'='kafka',\n  'connector.version'='universal',\n  'connector.topic'='user_behavior',\n  'connector.startup-mode'='earliest-offset',\n  'connector.properties.zookeeper.connect'='localhost:2181',\n  'connector.properties.bootstrap.servers'='localhost:9092',\n  'format.type'='json'\n);\n```\n\n而在 Flink SQL 1.11 中则简化为\n\n```sql\nCREATE TABLE user_behavior (\n  ...\n) WITH (\n  'connector'='kafka',\n  'topic'='user_behavior',\n  'scan.startup.mode'='earliest-offset',\n  'properties.zookeeper.connect'='localhost:2181',\n  'properties.bootstrap.servers'='localhost:9092',\n  'format'='json'\n);\n```\n\n详细变更见[FLIP-122](https://cwiki.apache.org/confluence/display/FLINK/FLIP-122%3A+New+Connector+Property+Keys+for+New+Factory)\n\n3. flink-sql-connector-jdbc声明表时，必须指定主键\n\n否则会报异常：\n\n```\njava.lang.IllegalStateException: please declare primary key for sink table when query contains update/delete record.\n\tat org.apache.flink.util.Preconditions.checkState(Preconditions.java:195)\n\tat org.apache.flink.connector.jdbc.table.JdbcDynamicTableSink.validatePrimaryKey(JdbcDynamicTableSink.java:72)\n\tat org.apache.flink.connector.jdbc.table.JdbcDynamicTableSink.getChangelogMode(JdbcDynamicTableSink.java:63)\n\tat org.apache.flink.table.planner.plan.optimize.program.FlinkChangelogModeInferenceProgram$SatisfyModifyKindSetTraitVisitor.visit(FlinkChangelogModeInferenceProgram.scala:120)\n\tat org.apache.flink.table.planner.plan.optimize.program.FlinkChangelogModeInferenceProgram.optimize(FlinkChangelogModeInferenceProgram.scala:50)\n\tat org.apache.flink.table.planner.plan.optimize.program.FlinkChangelogModeInferenceProgram.optimize(FlinkChangelogModeInferenceProgram.scala:39)\n\tat org.apache.flink.table.planner.plan.optimize.program.FlinkGroupProgram$$anonfun$optimize$1$$anonfun$apply$1.apply(FlinkGroupProgram.scala:63)\n\tat org.apache.flink.table.planner.plan.optimize.program.FlinkGroupProgram$$anonfun$optimize$1$$anonfun$apply$1.apply(FlinkGroupProgram.scala:60)\n\tat scala.collection.TraversableOnce$$anonfun$foldLeft$1.apply(TraversableOnce.scala:157)\n\tat scala.collection.TraversableOnce$$anonfun$foldLeft$1.apply(TraversableOnce.scala:157)\n\tat scala.collection.Iterator$class.foreach(Iterator.scala:891)\n\tat scala.collection.AbstractIterator.foreach(Iterator.scala:1334)\n\tat scala.collection.IterableLike$class.foreach(IterableLike.scala:72)\n\tat scala.collection.AbstractIterable.foreach(Iterable.scala:54)\n\tat scala.collection.TraversableOnce$class.foldLeft(TraversableOnce.scala:157)\n\tat scala.collection.AbstractTraversable.foldLeft(Traversable.scala:104)\n\tat org.apache.flink.table.planner.plan.optimize.program.FlinkGroupProgram$$anonfun$optimize$1.apply(FlinkGroupProgram.scala:60)\n\tat org.apache.flink.table.planner.plan.optimize.program.FlinkGroupProgram$$anonfun$optimize$1.apply(FlinkGroupProgram.scala:55)\n\tat scala.collection.TraversableOnce$$anonfun$foldLeft$1.apply(TraversableOnce.scala:157)\n\tat scala.collection.TraversableOnce$$anonfun$foldLeft$1.apply(TraversableOnce.scala:157)\n\tat scala.collection.immutable.Range.foreach(Range.scala:160)\n\tat scala.collection.TraversableOnce$class.foldLeft(TraversableOnce.scala:157)\n\tat scala.collection.AbstractTraversable.foldLeft(Traversable.scala:104)\n\tat org.apache.flink.table.planner.plan.optimize.program.FlinkGroupProgram.optimize(FlinkGroupProgram.scala:55)\n\tat org.apache.flink.table.planner.plan.optimize.program.FlinkChainedProgram$$anonfun$optimize$1.apply(FlinkChainedProgram.scala:62)\n\tat org.apache.flink.table.planner.plan.optimize.program.FlinkChainedProgram$$anonfun$optimize$1.apply(FlinkChainedProgram.scala:58)\n\tat scala.collection.TraversableOnce$$anonfun$foldLeft$1.apply(TraversableOnce.scala:157)\n\tat scala.collection.TraversableOnce$$anonfun$foldLeft$1.apply(TraversableOnce.scala:157)\n\tat scala.collection.Iterator$class.foreach(Iterator.scala:891)\n\tat scala.collection.AbstractIterator.foreach(Iterator.scala:1334)\n\tat scala.collection.IterableLike$class.foreach(IterableLike.scala:72)\n\tat scala.collection.AbstractIterable.foreach(Iterable.scala:54)\n\tat scala.collection.TraversableOnce$class.foldLeft(TraversableOnce.scala:157)\n\tat scala.collection.AbstractTraversable.foldLeft(Traversable.scala:104)\n\tat org.apache.flink.table.planner.plan.optimize.program.FlinkChainedProgram.optimize(FlinkChainedProgram.scala:57)\n\tat org.apache.flink.table.planner.plan.optimize.StreamCommonSubGraphBasedOptimizer.optimizeTree(StreamCommonSubGraphBasedOptimizer.scala:164)\n\tat org.apache.flink.table.planner.plan.optimize.StreamCommonSubGraphBasedOptimizer.doOptimize(StreamCommonSubGraphBasedOptimizer.scala:80)\n\tat org.apache.flink.table.planner.plan.optimize.CommonSubGraphBasedOptimizer.optimize(CommonSubGraphBasedOptimizer.scala:77)\n\tat org.apache.flink.table.planner.delegation.PlannerBase.optimize(PlannerBase.scala:279)\n\tat org.apache.flink.table.planner.delegation.PlannerBase.translate(PlannerBase.scala:164)\n\tat org.apache.flink.table.api.internal.TableEnvironmentImpl.translate(TableEnvironmentImpl.java:1264)\n\tat org.apache.flink.table.api.internal.TableEnvironmentImpl.executeInternal(TableEnvironmentImpl.java:700)\n\tat org.apache.flink.table.api.internal.TableEnvironmentImpl.executeOperation(TableEnvironmentImpl.java:787)\n\tat org.apache.flink.table.api.internal.TableEnvironmentImpl.executeSql(TableEnvironmentImpl.java:690)\n    ···\n```\n\n4. 使用flink-mysql-cdc时，请注意检查线上数据库binlog-format属性，另外要给用户授权\n\n```sql\nSET GLOBAL binlog_format = 'ROW';\n```\n\n```sql\nGRANT SELECT, RELOAD, SHOW DATABASES, REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO 'user' IDENTIFIED BY 'password';\n```\n\n5. 接收到MIXED或STATEMENT格式日志退出\n\n虽然你可能将Mysql的binlog日志格式改为`row`，但是仍然可能存在之前的`session`或者有用户手动修改并提交`mixed`或者`statement`格式的日志，这会导致cdc组件异常并退出。\n\n`flink-mysql-cdc`并没有直接关于此情况设置，但是其引用的`debezium`组件，在`1.3`版本（虽然官方文档在1.2版本也有相关属性，但是看其源码并不支持）开始支持**忽略解析错误的语句**。\n可以通过添加属性配置，来跳过。但是也可能带来丢失数据的风险。\n\n[debezium文档](https://debezium.io/documentation/reference/1.3/connectors/mysql.html#mysql-property-event-processing-failure-handling-mode\n)\n\n```properties\n'debezium.event.processing.failure.handling.mode' = 'skip',\n'debezium.inconsistent.schema.handling.mode' = 'skip',\n'debezium.database.history.skip.unparseable.ddl' = 'true'\n```\n\n\n6. 目标表要注意清除外键依赖\n\n同步数据时，很多公司都会直接同步原始表的所有字段作为数仓`ods`层或者`dim`层，并使用mysql存储，不做任何处理，只有在流表与维表join的时候才会读取.\n\n此时可能从业务数据库导出sql并导入数仓的mysql，外键依赖也可能会导入。\n\n那么需要注意去掉其外键依赖，否则会在同步时发生异常。","source":"_posts/flink/Flink-CDC踩坑集合.md","raw":"---\ntitle: Flink CDC踩坑集合\ndate: 2020-12-11 17:02:47\ncategories: 流计算\ntags: \n- Flink\n- 踩坑\n---\n\n1. 使用flink sql 时，提前引入flink-json依赖\n\n异常信息\n\n```\nCaused by: org.apache.flink.table.api.ValidationException: Could not find any factories that implement 'org.apache.flink.table.factories.DeserializationFormatFactory' in the classpath.\n\tat org.apache.flink.table.factories.FactoryUtil.discoverFactory(FactoryUtil.java:229)\n\tat org.apache.flink.table.factories.FactoryUtil$TableFactoryHelper.discoverOptionalFormatFactory(FactoryUtil.java:538)\n\tat org.apache.flink.table.factories.FactoryUtil$TableFactoryHelper.discoverOptionalDecodingFormat(FactoryUtil.java:426)\n\tat org.apache.flink.table.factories.FactoryUtil$TableFactoryHelper.discoverDecodingFormat(FactoryUtil.java:413)\n\tat org.apache.flink.streaming.connectors.kafka.table.KafkaDynamicTableFactoryBase.createDynamicTableSource(KafkaDynamicTableFactoryBase.java:73)\n\tat org.apache.flink.table.factories.FactoryUtil.createTableSource(FactoryUtil.java:122)\n\t  \n```\n\n解决方案： pom文件中引入\n\n```xml\n<dependency>\n    <groupId>org.apache.flink</groupId>\n    <artifactId>flink-json</artifactId>\n    <version>1.11.0</version>\n</dependency>\n```\n\n2. Flink 1.11版本后简化了 connector 参数\n\nFlink由于发展太快（2020年已经发布了1.10，1.11，1.12三个大版本），很多2020年初的blog提供教程已经面临失效\n\n以 Kafka 为例，在 1.11 版本之前用户的 DDL 需要声明成如下方式\n\n```sql\n CREATE TABLE user_behavior (\n  ...\n) WITH (\n  'connector.type'='kafka',\n  'connector.version'='universal',\n  'connector.topic'='user_behavior',\n  'connector.startup-mode'='earliest-offset',\n  'connector.properties.zookeeper.connect'='localhost:2181',\n  'connector.properties.bootstrap.servers'='localhost:9092',\n  'format.type'='json'\n);\n```\n\n而在 Flink SQL 1.11 中则简化为\n\n```sql\nCREATE TABLE user_behavior (\n  ...\n) WITH (\n  'connector'='kafka',\n  'topic'='user_behavior',\n  'scan.startup.mode'='earliest-offset',\n  'properties.zookeeper.connect'='localhost:2181',\n  'properties.bootstrap.servers'='localhost:9092',\n  'format'='json'\n);\n```\n\n详细变更见[FLIP-122](https://cwiki.apache.org/confluence/display/FLINK/FLIP-122%3A+New+Connector+Property+Keys+for+New+Factory)\n\n3. flink-sql-connector-jdbc声明表时，必须指定主键\n\n否则会报异常：\n\n```\njava.lang.IllegalStateException: please declare primary key for sink table when query contains update/delete record.\n\tat org.apache.flink.util.Preconditions.checkState(Preconditions.java:195)\n\tat org.apache.flink.connector.jdbc.table.JdbcDynamicTableSink.validatePrimaryKey(JdbcDynamicTableSink.java:72)\n\tat org.apache.flink.connector.jdbc.table.JdbcDynamicTableSink.getChangelogMode(JdbcDynamicTableSink.java:63)\n\tat org.apache.flink.table.planner.plan.optimize.program.FlinkChangelogModeInferenceProgram$SatisfyModifyKindSetTraitVisitor.visit(FlinkChangelogModeInferenceProgram.scala:120)\n\tat org.apache.flink.table.planner.plan.optimize.program.FlinkChangelogModeInferenceProgram.optimize(FlinkChangelogModeInferenceProgram.scala:50)\n\tat org.apache.flink.table.planner.plan.optimize.program.FlinkChangelogModeInferenceProgram.optimize(FlinkChangelogModeInferenceProgram.scala:39)\n\tat org.apache.flink.table.planner.plan.optimize.program.FlinkGroupProgram$$anonfun$optimize$1$$anonfun$apply$1.apply(FlinkGroupProgram.scala:63)\n\tat org.apache.flink.table.planner.plan.optimize.program.FlinkGroupProgram$$anonfun$optimize$1$$anonfun$apply$1.apply(FlinkGroupProgram.scala:60)\n\tat scala.collection.TraversableOnce$$anonfun$foldLeft$1.apply(TraversableOnce.scala:157)\n\tat scala.collection.TraversableOnce$$anonfun$foldLeft$1.apply(TraversableOnce.scala:157)\n\tat scala.collection.Iterator$class.foreach(Iterator.scala:891)\n\tat scala.collection.AbstractIterator.foreach(Iterator.scala:1334)\n\tat scala.collection.IterableLike$class.foreach(IterableLike.scala:72)\n\tat scala.collection.AbstractIterable.foreach(Iterable.scala:54)\n\tat scala.collection.TraversableOnce$class.foldLeft(TraversableOnce.scala:157)\n\tat scala.collection.AbstractTraversable.foldLeft(Traversable.scala:104)\n\tat org.apache.flink.table.planner.plan.optimize.program.FlinkGroupProgram$$anonfun$optimize$1.apply(FlinkGroupProgram.scala:60)\n\tat org.apache.flink.table.planner.plan.optimize.program.FlinkGroupProgram$$anonfun$optimize$1.apply(FlinkGroupProgram.scala:55)\n\tat scala.collection.TraversableOnce$$anonfun$foldLeft$1.apply(TraversableOnce.scala:157)\n\tat scala.collection.TraversableOnce$$anonfun$foldLeft$1.apply(TraversableOnce.scala:157)\n\tat scala.collection.immutable.Range.foreach(Range.scala:160)\n\tat scala.collection.TraversableOnce$class.foldLeft(TraversableOnce.scala:157)\n\tat scala.collection.AbstractTraversable.foldLeft(Traversable.scala:104)\n\tat org.apache.flink.table.planner.plan.optimize.program.FlinkGroupProgram.optimize(FlinkGroupProgram.scala:55)\n\tat org.apache.flink.table.planner.plan.optimize.program.FlinkChainedProgram$$anonfun$optimize$1.apply(FlinkChainedProgram.scala:62)\n\tat org.apache.flink.table.planner.plan.optimize.program.FlinkChainedProgram$$anonfun$optimize$1.apply(FlinkChainedProgram.scala:58)\n\tat scala.collection.TraversableOnce$$anonfun$foldLeft$1.apply(TraversableOnce.scala:157)\n\tat scala.collection.TraversableOnce$$anonfun$foldLeft$1.apply(TraversableOnce.scala:157)\n\tat scala.collection.Iterator$class.foreach(Iterator.scala:891)\n\tat scala.collection.AbstractIterator.foreach(Iterator.scala:1334)\n\tat scala.collection.IterableLike$class.foreach(IterableLike.scala:72)\n\tat scala.collection.AbstractIterable.foreach(Iterable.scala:54)\n\tat scala.collection.TraversableOnce$class.foldLeft(TraversableOnce.scala:157)\n\tat scala.collection.AbstractTraversable.foldLeft(Traversable.scala:104)\n\tat org.apache.flink.table.planner.plan.optimize.program.FlinkChainedProgram.optimize(FlinkChainedProgram.scala:57)\n\tat org.apache.flink.table.planner.plan.optimize.StreamCommonSubGraphBasedOptimizer.optimizeTree(StreamCommonSubGraphBasedOptimizer.scala:164)\n\tat org.apache.flink.table.planner.plan.optimize.StreamCommonSubGraphBasedOptimizer.doOptimize(StreamCommonSubGraphBasedOptimizer.scala:80)\n\tat org.apache.flink.table.planner.plan.optimize.CommonSubGraphBasedOptimizer.optimize(CommonSubGraphBasedOptimizer.scala:77)\n\tat org.apache.flink.table.planner.delegation.PlannerBase.optimize(PlannerBase.scala:279)\n\tat org.apache.flink.table.planner.delegation.PlannerBase.translate(PlannerBase.scala:164)\n\tat org.apache.flink.table.api.internal.TableEnvironmentImpl.translate(TableEnvironmentImpl.java:1264)\n\tat org.apache.flink.table.api.internal.TableEnvironmentImpl.executeInternal(TableEnvironmentImpl.java:700)\n\tat org.apache.flink.table.api.internal.TableEnvironmentImpl.executeOperation(TableEnvironmentImpl.java:787)\n\tat org.apache.flink.table.api.internal.TableEnvironmentImpl.executeSql(TableEnvironmentImpl.java:690)\n    ···\n```\n\n4. 使用flink-mysql-cdc时，请注意检查线上数据库binlog-format属性，另外要给用户授权\n\n```sql\nSET GLOBAL binlog_format = 'ROW';\n```\n\n```sql\nGRANT SELECT, RELOAD, SHOW DATABASES, REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO 'user' IDENTIFIED BY 'password';\n```\n\n5. 接收到MIXED或STATEMENT格式日志退出\n\n虽然你可能将Mysql的binlog日志格式改为`row`，但是仍然可能存在之前的`session`或者有用户手动修改并提交`mixed`或者`statement`格式的日志，这会导致cdc组件异常并退出。\n\n`flink-mysql-cdc`并没有直接关于此情况设置，但是其引用的`debezium`组件，在`1.3`版本（虽然官方文档在1.2版本也有相关属性，但是看其源码并不支持）开始支持**忽略解析错误的语句**。\n可以通过添加属性配置，来跳过。但是也可能带来丢失数据的风险。\n\n[debezium文档](https://debezium.io/documentation/reference/1.3/connectors/mysql.html#mysql-property-event-processing-failure-handling-mode\n)\n\n```properties\n'debezium.event.processing.failure.handling.mode' = 'skip',\n'debezium.inconsistent.schema.handling.mode' = 'skip',\n'debezium.database.history.skip.unparseable.ddl' = 'true'\n```\n\n\n6. 目标表要注意清除外键依赖\n\n同步数据时，很多公司都会直接同步原始表的所有字段作为数仓`ods`层或者`dim`层，并使用mysql存储，不做任何处理，只有在流表与维表join的时候才会读取.\n\n此时可能从业务数据库导出sql并导入数仓的mysql，外键依赖也可能会导入。\n\n那么需要注意去掉其外键依赖，否则会在同步时发生异常。","slug":"flink/Flink-CDC踩坑集合","published":1,"updated":"2020-12-14T05:44:58.864Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckio9dwf9004kk8neln4t3s43","content":"<ol>\n<li>使用flink sql 时，提前引入flink-json依赖</li>\n</ol>\n<p>异常信息</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Caused by: org.apache.flink.table.api.ValidationException: Could not find any factories that implement &apos;org.apache.flink.table.factories.DeserializationFormatFactory&apos; in the classpath.</span><br><span class=\"line\">\tat org.apache.flink.table.factories.FactoryUtil.discoverFactory(FactoryUtil.java:229)</span><br><span class=\"line\">\tat org.apache.flink.table.factories.FactoryUtil$TableFactoryHelper.discoverOptionalFormatFactory(FactoryUtil.java:538)</span><br><span class=\"line\">\tat org.apache.flink.table.factories.FactoryUtil$TableFactoryHelper.discoverOptionalDecodingFormat(FactoryUtil.java:426)</span><br><span class=\"line\">\tat org.apache.flink.table.factories.FactoryUtil$TableFactoryHelper.discoverDecodingFormat(FactoryUtil.java:413)</span><br><span class=\"line\">\tat org.apache.flink.streaming.connectors.kafka.table.KafkaDynamicTableFactoryBase.createDynamicTableSource(KafkaDynamicTableFactoryBase.java:73)</span><br><span class=\"line\">\tat org.apache.flink.table.factories.FactoryUtil.createTableSource(FactoryUtil.java:122)</span><br></pre></td></tr></table></figure>\n\n<p>解决方案： pom文件中引入</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.flink<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>flink-json<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.11.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>Flink 1.11版本后简化了 connector 参数</li>\n</ol>\n<p>Flink由于发展太快（2020年已经发布了1.10，1.11，1.12三个大版本），很多2020年初的blog提供教程已经面临失效</p>\n<p>以 Kafka 为例，在 1.11 版本之前用户的 DDL 需要声明成如下方式</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> user_behavior (</span><br><span class=\"line\">  ...</span><br><span class=\"line\">) <span class=\"keyword\">WITH</span> (</span><br><span class=\"line\">  <span class=\"string\">'connector.type'</span>=<span class=\"string\">'kafka'</span>,</span><br><span class=\"line\">  <span class=\"string\">'connector.version'</span>=<span class=\"string\">'universal'</span>,</span><br><span class=\"line\">  <span class=\"string\">'connector.topic'</span>=<span class=\"string\">'user_behavior'</span>,</span><br><span class=\"line\">  <span class=\"string\">'connector.startup-mode'</span>=<span class=\"string\">'earliest-offset'</span>,</span><br><span class=\"line\">  <span class=\"string\">'connector.properties.zookeeper.connect'</span>=<span class=\"string\">'localhost:2181'</span>,</span><br><span class=\"line\">  <span class=\"string\">'connector.properties.bootstrap.servers'</span>=<span class=\"string\">'localhost:9092'</span>,</span><br><span class=\"line\">  <span class=\"string\">'format.type'</span>=<span class=\"string\">'json'</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p>而在 Flink SQL 1.11 中则简化为</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> user_behavior (</span><br><span class=\"line\">  ...</span><br><span class=\"line\">) <span class=\"keyword\">WITH</span> (</span><br><span class=\"line\">  <span class=\"string\">'connector'</span>=<span class=\"string\">'kafka'</span>,</span><br><span class=\"line\">  <span class=\"string\">'topic'</span>=<span class=\"string\">'user_behavior'</span>,</span><br><span class=\"line\">  <span class=\"string\">'scan.startup.mode'</span>=<span class=\"string\">'earliest-offset'</span>,</span><br><span class=\"line\">  <span class=\"string\">'properties.zookeeper.connect'</span>=<span class=\"string\">'localhost:2181'</span>,</span><br><span class=\"line\">  <span class=\"string\">'properties.bootstrap.servers'</span>=<span class=\"string\">'localhost:9092'</span>,</span><br><span class=\"line\">  <span class=\"string\">'format'</span>=<span class=\"string\">'json'</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p>详细变更见<a href=\"https://cwiki.apache.org/confluence/display/FLINK/FLIP-122%3A+New+Connector+Property+Keys+for+New+Factory\" target=\"_blank\" rel=\"noopener\">FLIP-122</a></p>\n<ol start=\"3\">\n<li>flink-sql-connector-jdbc声明表时，必须指定主键</li>\n</ol>\n<p>否则会报异常：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java.lang.IllegalStateException: please declare primary key for sink table when query contains update/delete record.</span><br><span class=\"line\">\tat org.apache.flink.util.Preconditions.checkState(Preconditions.java:195)</span><br><span class=\"line\">\tat org.apache.flink.connector.jdbc.table.JdbcDynamicTableSink.validatePrimaryKey(JdbcDynamicTableSink.java:72)</span><br><span class=\"line\">\tat org.apache.flink.connector.jdbc.table.JdbcDynamicTableSink.getChangelogMode(JdbcDynamicTableSink.java:63)</span><br><span class=\"line\">\tat org.apache.flink.table.planner.plan.optimize.program.FlinkChangelogModeInferenceProgram$SatisfyModifyKindSetTraitVisitor.visit(FlinkChangelogModeInferenceProgram.scala:120)</span><br><span class=\"line\">\tat org.apache.flink.table.planner.plan.optimize.program.FlinkChangelogModeInferenceProgram.optimize(FlinkChangelogModeInferenceProgram.scala:50)</span><br><span class=\"line\">\tat org.apache.flink.table.planner.plan.optimize.program.FlinkChangelogModeInferenceProgram.optimize(FlinkChangelogModeInferenceProgram.scala:39)</span><br><span class=\"line\">\tat org.apache.flink.table.planner.plan.optimize.program.FlinkGroupProgram$$anonfun$optimize$1$$anonfun$apply$1.apply(FlinkGroupProgram.scala:63)</span><br><span class=\"line\">\tat org.apache.flink.table.planner.plan.optimize.program.FlinkGroupProgram$$anonfun$optimize$1$$anonfun$apply$1.apply(FlinkGroupProgram.scala:60)</span><br><span class=\"line\">\tat scala.collection.TraversableOnce$$anonfun$foldLeft$1.apply(TraversableOnce.scala:157)</span><br><span class=\"line\">\tat scala.collection.TraversableOnce$$anonfun$foldLeft$1.apply(TraversableOnce.scala:157)</span><br><span class=\"line\">\tat scala.collection.Iterator$class.foreach(Iterator.scala:891)</span><br><span class=\"line\">\tat scala.collection.AbstractIterator.foreach(Iterator.scala:1334)</span><br><span class=\"line\">\tat scala.collection.IterableLike$class.foreach(IterableLike.scala:72)</span><br><span class=\"line\">\tat scala.collection.AbstractIterable.foreach(Iterable.scala:54)</span><br><span class=\"line\">\tat scala.collection.TraversableOnce$class.foldLeft(TraversableOnce.scala:157)</span><br><span class=\"line\">\tat scala.collection.AbstractTraversable.foldLeft(Traversable.scala:104)</span><br><span class=\"line\">\tat org.apache.flink.table.planner.plan.optimize.program.FlinkGroupProgram$$anonfun$optimize$1.apply(FlinkGroupProgram.scala:60)</span><br><span class=\"line\">\tat org.apache.flink.table.planner.plan.optimize.program.FlinkGroupProgram$$anonfun$optimize$1.apply(FlinkGroupProgram.scala:55)</span><br><span class=\"line\">\tat scala.collection.TraversableOnce$$anonfun$foldLeft$1.apply(TraversableOnce.scala:157)</span><br><span class=\"line\">\tat scala.collection.TraversableOnce$$anonfun$foldLeft$1.apply(TraversableOnce.scala:157)</span><br><span class=\"line\">\tat scala.collection.immutable.Range.foreach(Range.scala:160)</span><br><span class=\"line\">\tat scala.collection.TraversableOnce$class.foldLeft(TraversableOnce.scala:157)</span><br><span class=\"line\">\tat scala.collection.AbstractTraversable.foldLeft(Traversable.scala:104)</span><br><span class=\"line\">\tat org.apache.flink.table.planner.plan.optimize.program.FlinkGroupProgram.optimize(FlinkGroupProgram.scala:55)</span><br><span class=\"line\">\tat org.apache.flink.table.planner.plan.optimize.program.FlinkChainedProgram$$anonfun$optimize$1.apply(FlinkChainedProgram.scala:62)</span><br><span class=\"line\">\tat org.apache.flink.table.planner.plan.optimize.program.FlinkChainedProgram$$anonfun$optimize$1.apply(FlinkChainedProgram.scala:58)</span><br><span class=\"line\">\tat scala.collection.TraversableOnce$$anonfun$foldLeft$1.apply(TraversableOnce.scala:157)</span><br><span class=\"line\">\tat scala.collection.TraversableOnce$$anonfun$foldLeft$1.apply(TraversableOnce.scala:157)</span><br><span class=\"line\">\tat scala.collection.Iterator$class.foreach(Iterator.scala:891)</span><br><span class=\"line\">\tat scala.collection.AbstractIterator.foreach(Iterator.scala:1334)</span><br><span class=\"line\">\tat scala.collection.IterableLike$class.foreach(IterableLike.scala:72)</span><br><span class=\"line\">\tat scala.collection.AbstractIterable.foreach(Iterable.scala:54)</span><br><span class=\"line\">\tat scala.collection.TraversableOnce$class.foldLeft(TraversableOnce.scala:157)</span><br><span class=\"line\">\tat scala.collection.AbstractTraversable.foldLeft(Traversable.scala:104)</span><br><span class=\"line\">\tat org.apache.flink.table.planner.plan.optimize.program.FlinkChainedProgram.optimize(FlinkChainedProgram.scala:57)</span><br><span class=\"line\">\tat org.apache.flink.table.planner.plan.optimize.StreamCommonSubGraphBasedOptimizer.optimizeTree(StreamCommonSubGraphBasedOptimizer.scala:164)</span><br><span class=\"line\">\tat org.apache.flink.table.planner.plan.optimize.StreamCommonSubGraphBasedOptimizer.doOptimize(StreamCommonSubGraphBasedOptimizer.scala:80)</span><br><span class=\"line\">\tat org.apache.flink.table.planner.plan.optimize.CommonSubGraphBasedOptimizer.optimize(CommonSubGraphBasedOptimizer.scala:77)</span><br><span class=\"line\">\tat org.apache.flink.table.planner.delegation.PlannerBase.optimize(PlannerBase.scala:279)</span><br><span class=\"line\">\tat org.apache.flink.table.planner.delegation.PlannerBase.translate(PlannerBase.scala:164)</span><br><span class=\"line\">\tat org.apache.flink.table.api.internal.TableEnvironmentImpl.translate(TableEnvironmentImpl.java:1264)</span><br><span class=\"line\">\tat org.apache.flink.table.api.internal.TableEnvironmentImpl.executeInternal(TableEnvironmentImpl.java:700)</span><br><span class=\"line\">\tat org.apache.flink.table.api.internal.TableEnvironmentImpl.executeOperation(TableEnvironmentImpl.java:787)</span><br><span class=\"line\">\tat org.apache.flink.table.api.internal.TableEnvironmentImpl.executeSql(TableEnvironmentImpl.java:690)</span><br><span class=\"line\">    ···</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>使用flink-mysql-cdc时，请注意检查线上数据库binlog-format属性，另外要给用户授权</li>\n</ol>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SET</span> <span class=\"keyword\">GLOBAL</span> binlog_format = <span class=\"string\">'ROW'</span>;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">GRANT</span> <span class=\"keyword\">SELECT</span>, RELOAD, <span class=\"keyword\">SHOW</span> <span class=\"keyword\">DATABASES</span>, <span class=\"keyword\">REPLICATION</span> <span class=\"keyword\">SLAVE</span>, <span class=\"keyword\">REPLICATION</span> <span class=\"keyword\">CLIENT</span> <span class=\"keyword\">ON</span> *.* <span class=\"keyword\">TO</span> <span class=\"string\">'user'</span> <span class=\"keyword\">IDENTIFIED</span> <span class=\"keyword\">BY</span> <span class=\"string\">'password'</span>;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li>接收到MIXED或STATEMENT格式日志退出</li>\n</ol>\n<p>虽然你可能将Mysql的binlog日志格式改为<code>row</code>，但是仍然可能存在之前的<code>session</code>或者有用户手动修改并提交<code>mixed</code>或者<code>statement</code>格式的日志，这会导致cdc组件异常并退出。</p>\n<p><code>flink-mysql-cdc</code>并没有直接关于此情况设置，但是其引用的<code>debezium</code>组件，在<code>1.3</code>版本（虽然官方文档在1.2版本也有相关属性，但是看其源码并不支持）开始支持<strong>忽略解析错误的语句</strong>。<br>可以通过添加属性配置，来跳过。但是也可能带来丢失数据的风险。</p>\n<p><a href=\"https://debezium.io/documentation/reference/1.3/connectors/mysql.html#mysql-property-event-processing-failure-handling-mode\" target=\"_blank\" rel=\"noopener\">debezium文档</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&apos;debezium.event.processing.failure.handling.mode&apos; = &apos;skip&apos;,</span><br><span class=\"line\">&apos;debezium.inconsistent.schema.handling.mode&apos; = &apos;skip&apos;,</span><br><span class=\"line\">&apos;debezium.database.history.skip.unparseable.ddl&apos; = &apos;true&apos;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"6\">\n<li>目标表要注意清除外键依赖</li>\n</ol>\n<p>同步数据时，很多公司都会直接同步原始表的所有字段作为数仓<code>ods</code>层或者<code>dim</code>层，并使用mysql存储，不做任何处理，只有在流表与维表join的时候才会读取.</p>\n<p>此时可能从业务数据库导出sql并导入数仓的mysql，外键依赖也可能会导入。</p>\n<p>那么需要注意去掉其外键依赖，否则会在同步时发生异常。</p>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li>使用flink sql 时，提前引入flink-json依赖</li>\n</ol>\n<p>异常信息</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Caused by: org.apache.flink.table.api.ValidationException: Could not find any factories that implement &apos;org.apache.flink.table.factories.DeserializationFormatFactory&apos; in the classpath.</span><br><span class=\"line\">\tat org.apache.flink.table.factories.FactoryUtil.discoverFactory(FactoryUtil.java:229)</span><br><span class=\"line\">\tat org.apache.flink.table.factories.FactoryUtil$TableFactoryHelper.discoverOptionalFormatFactory(FactoryUtil.java:538)</span><br><span class=\"line\">\tat org.apache.flink.table.factories.FactoryUtil$TableFactoryHelper.discoverOptionalDecodingFormat(FactoryUtil.java:426)</span><br><span class=\"line\">\tat org.apache.flink.table.factories.FactoryUtil$TableFactoryHelper.discoverDecodingFormat(FactoryUtil.java:413)</span><br><span class=\"line\">\tat org.apache.flink.streaming.connectors.kafka.table.KafkaDynamicTableFactoryBase.createDynamicTableSource(KafkaDynamicTableFactoryBase.java:73)</span><br><span class=\"line\">\tat org.apache.flink.table.factories.FactoryUtil.createTableSource(FactoryUtil.java:122)</span><br></pre></td></tr></table></figure>\n\n<p>解决方案： pom文件中引入</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.flink<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>flink-json<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.11.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>Flink 1.11版本后简化了 connector 参数</li>\n</ol>\n<p>Flink由于发展太快（2020年已经发布了1.10，1.11，1.12三个大版本），很多2020年初的blog提供教程已经面临失效</p>\n<p>以 Kafka 为例，在 1.11 版本之前用户的 DDL 需要声明成如下方式</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> user_behavior (</span><br><span class=\"line\">  ...</span><br><span class=\"line\">) <span class=\"keyword\">WITH</span> (</span><br><span class=\"line\">  <span class=\"string\">'connector.type'</span>=<span class=\"string\">'kafka'</span>,</span><br><span class=\"line\">  <span class=\"string\">'connector.version'</span>=<span class=\"string\">'universal'</span>,</span><br><span class=\"line\">  <span class=\"string\">'connector.topic'</span>=<span class=\"string\">'user_behavior'</span>,</span><br><span class=\"line\">  <span class=\"string\">'connector.startup-mode'</span>=<span class=\"string\">'earliest-offset'</span>,</span><br><span class=\"line\">  <span class=\"string\">'connector.properties.zookeeper.connect'</span>=<span class=\"string\">'localhost:2181'</span>,</span><br><span class=\"line\">  <span class=\"string\">'connector.properties.bootstrap.servers'</span>=<span class=\"string\">'localhost:9092'</span>,</span><br><span class=\"line\">  <span class=\"string\">'format.type'</span>=<span class=\"string\">'json'</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p>而在 Flink SQL 1.11 中则简化为</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> user_behavior (</span><br><span class=\"line\">  ...</span><br><span class=\"line\">) <span class=\"keyword\">WITH</span> (</span><br><span class=\"line\">  <span class=\"string\">'connector'</span>=<span class=\"string\">'kafka'</span>,</span><br><span class=\"line\">  <span class=\"string\">'topic'</span>=<span class=\"string\">'user_behavior'</span>,</span><br><span class=\"line\">  <span class=\"string\">'scan.startup.mode'</span>=<span class=\"string\">'earliest-offset'</span>,</span><br><span class=\"line\">  <span class=\"string\">'properties.zookeeper.connect'</span>=<span class=\"string\">'localhost:2181'</span>,</span><br><span class=\"line\">  <span class=\"string\">'properties.bootstrap.servers'</span>=<span class=\"string\">'localhost:9092'</span>,</span><br><span class=\"line\">  <span class=\"string\">'format'</span>=<span class=\"string\">'json'</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p>详细变更见<a href=\"https://cwiki.apache.org/confluence/display/FLINK/FLIP-122%3A+New+Connector+Property+Keys+for+New+Factory\" target=\"_blank\" rel=\"noopener\">FLIP-122</a></p>\n<ol start=\"3\">\n<li>flink-sql-connector-jdbc声明表时，必须指定主键</li>\n</ol>\n<p>否则会报异常：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java.lang.IllegalStateException: please declare primary key for sink table when query contains update/delete record.</span><br><span class=\"line\">\tat org.apache.flink.util.Preconditions.checkState(Preconditions.java:195)</span><br><span class=\"line\">\tat org.apache.flink.connector.jdbc.table.JdbcDynamicTableSink.validatePrimaryKey(JdbcDynamicTableSink.java:72)</span><br><span class=\"line\">\tat org.apache.flink.connector.jdbc.table.JdbcDynamicTableSink.getChangelogMode(JdbcDynamicTableSink.java:63)</span><br><span class=\"line\">\tat org.apache.flink.table.planner.plan.optimize.program.FlinkChangelogModeInferenceProgram$SatisfyModifyKindSetTraitVisitor.visit(FlinkChangelogModeInferenceProgram.scala:120)</span><br><span class=\"line\">\tat org.apache.flink.table.planner.plan.optimize.program.FlinkChangelogModeInferenceProgram.optimize(FlinkChangelogModeInferenceProgram.scala:50)</span><br><span class=\"line\">\tat org.apache.flink.table.planner.plan.optimize.program.FlinkChangelogModeInferenceProgram.optimize(FlinkChangelogModeInferenceProgram.scala:39)</span><br><span class=\"line\">\tat org.apache.flink.table.planner.plan.optimize.program.FlinkGroupProgram$$anonfun$optimize$1$$anonfun$apply$1.apply(FlinkGroupProgram.scala:63)</span><br><span class=\"line\">\tat org.apache.flink.table.planner.plan.optimize.program.FlinkGroupProgram$$anonfun$optimize$1$$anonfun$apply$1.apply(FlinkGroupProgram.scala:60)</span><br><span class=\"line\">\tat scala.collection.TraversableOnce$$anonfun$foldLeft$1.apply(TraversableOnce.scala:157)</span><br><span class=\"line\">\tat scala.collection.TraversableOnce$$anonfun$foldLeft$1.apply(TraversableOnce.scala:157)</span><br><span class=\"line\">\tat scala.collection.Iterator$class.foreach(Iterator.scala:891)</span><br><span class=\"line\">\tat scala.collection.AbstractIterator.foreach(Iterator.scala:1334)</span><br><span class=\"line\">\tat scala.collection.IterableLike$class.foreach(IterableLike.scala:72)</span><br><span class=\"line\">\tat scala.collection.AbstractIterable.foreach(Iterable.scala:54)</span><br><span class=\"line\">\tat scala.collection.TraversableOnce$class.foldLeft(TraversableOnce.scala:157)</span><br><span class=\"line\">\tat scala.collection.AbstractTraversable.foldLeft(Traversable.scala:104)</span><br><span class=\"line\">\tat org.apache.flink.table.planner.plan.optimize.program.FlinkGroupProgram$$anonfun$optimize$1.apply(FlinkGroupProgram.scala:60)</span><br><span class=\"line\">\tat org.apache.flink.table.planner.plan.optimize.program.FlinkGroupProgram$$anonfun$optimize$1.apply(FlinkGroupProgram.scala:55)</span><br><span class=\"line\">\tat scala.collection.TraversableOnce$$anonfun$foldLeft$1.apply(TraversableOnce.scala:157)</span><br><span class=\"line\">\tat scala.collection.TraversableOnce$$anonfun$foldLeft$1.apply(TraversableOnce.scala:157)</span><br><span class=\"line\">\tat scala.collection.immutable.Range.foreach(Range.scala:160)</span><br><span class=\"line\">\tat scala.collection.TraversableOnce$class.foldLeft(TraversableOnce.scala:157)</span><br><span class=\"line\">\tat scala.collection.AbstractTraversable.foldLeft(Traversable.scala:104)</span><br><span class=\"line\">\tat org.apache.flink.table.planner.plan.optimize.program.FlinkGroupProgram.optimize(FlinkGroupProgram.scala:55)</span><br><span class=\"line\">\tat org.apache.flink.table.planner.plan.optimize.program.FlinkChainedProgram$$anonfun$optimize$1.apply(FlinkChainedProgram.scala:62)</span><br><span class=\"line\">\tat org.apache.flink.table.planner.plan.optimize.program.FlinkChainedProgram$$anonfun$optimize$1.apply(FlinkChainedProgram.scala:58)</span><br><span class=\"line\">\tat scala.collection.TraversableOnce$$anonfun$foldLeft$1.apply(TraversableOnce.scala:157)</span><br><span class=\"line\">\tat scala.collection.TraversableOnce$$anonfun$foldLeft$1.apply(TraversableOnce.scala:157)</span><br><span class=\"line\">\tat scala.collection.Iterator$class.foreach(Iterator.scala:891)</span><br><span class=\"line\">\tat scala.collection.AbstractIterator.foreach(Iterator.scala:1334)</span><br><span class=\"line\">\tat scala.collection.IterableLike$class.foreach(IterableLike.scala:72)</span><br><span class=\"line\">\tat scala.collection.AbstractIterable.foreach(Iterable.scala:54)</span><br><span class=\"line\">\tat scala.collection.TraversableOnce$class.foldLeft(TraversableOnce.scala:157)</span><br><span class=\"line\">\tat scala.collection.AbstractTraversable.foldLeft(Traversable.scala:104)</span><br><span class=\"line\">\tat org.apache.flink.table.planner.plan.optimize.program.FlinkChainedProgram.optimize(FlinkChainedProgram.scala:57)</span><br><span class=\"line\">\tat org.apache.flink.table.planner.plan.optimize.StreamCommonSubGraphBasedOptimizer.optimizeTree(StreamCommonSubGraphBasedOptimizer.scala:164)</span><br><span class=\"line\">\tat org.apache.flink.table.planner.plan.optimize.StreamCommonSubGraphBasedOptimizer.doOptimize(StreamCommonSubGraphBasedOptimizer.scala:80)</span><br><span class=\"line\">\tat org.apache.flink.table.planner.plan.optimize.CommonSubGraphBasedOptimizer.optimize(CommonSubGraphBasedOptimizer.scala:77)</span><br><span class=\"line\">\tat org.apache.flink.table.planner.delegation.PlannerBase.optimize(PlannerBase.scala:279)</span><br><span class=\"line\">\tat org.apache.flink.table.planner.delegation.PlannerBase.translate(PlannerBase.scala:164)</span><br><span class=\"line\">\tat org.apache.flink.table.api.internal.TableEnvironmentImpl.translate(TableEnvironmentImpl.java:1264)</span><br><span class=\"line\">\tat org.apache.flink.table.api.internal.TableEnvironmentImpl.executeInternal(TableEnvironmentImpl.java:700)</span><br><span class=\"line\">\tat org.apache.flink.table.api.internal.TableEnvironmentImpl.executeOperation(TableEnvironmentImpl.java:787)</span><br><span class=\"line\">\tat org.apache.flink.table.api.internal.TableEnvironmentImpl.executeSql(TableEnvironmentImpl.java:690)</span><br><span class=\"line\">    ···</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>使用flink-mysql-cdc时，请注意检查线上数据库binlog-format属性，另外要给用户授权</li>\n</ol>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SET</span> <span class=\"keyword\">GLOBAL</span> binlog_format = <span class=\"string\">'ROW'</span>;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">GRANT</span> <span class=\"keyword\">SELECT</span>, RELOAD, <span class=\"keyword\">SHOW</span> <span class=\"keyword\">DATABASES</span>, <span class=\"keyword\">REPLICATION</span> <span class=\"keyword\">SLAVE</span>, <span class=\"keyword\">REPLICATION</span> <span class=\"keyword\">CLIENT</span> <span class=\"keyword\">ON</span> *.* <span class=\"keyword\">TO</span> <span class=\"string\">'user'</span> <span class=\"keyword\">IDENTIFIED</span> <span class=\"keyword\">BY</span> <span class=\"string\">'password'</span>;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li>接收到MIXED或STATEMENT格式日志退出</li>\n</ol>\n<p>虽然你可能将Mysql的binlog日志格式改为<code>row</code>，但是仍然可能存在之前的<code>session</code>或者有用户手动修改并提交<code>mixed</code>或者<code>statement</code>格式的日志，这会导致cdc组件异常并退出。</p>\n<p><code>flink-mysql-cdc</code>并没有直接关于此情况设置，但是其引用的<code>debezium</code>组件，在<code>1.3</code>版本（虽然官方文档在1.2版本也有相关属性，但是看其源码并不支持）开始支持<strong>忽略解析错误的语句</strong>。<br>可以通过添加属性配置，来跳过。但是也可能带来丢失数据的风险。</p>\n<p><a href=\"https://debezium.io/documentation/reference/1.3/connectors/mysql.html#mysql-property-event-processing-failure-handling-mode\" target=\"_blank\" rel=\"noopener\">debezium文档</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&apos;debezium.event.processing.failure.handling.mode&apos; = &apos;skip&apos;,</span><br><span class=\"line\">&apos;debezium.inconsistent.schema.handling.mode&apos; = &apos;skip&apos;,</span><br><span class=\"line\">&apos;debezium.database.history.skip.unparseable.ddl&apos; = &apos;true&apos;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"6\">\n<li>目标表要注意清除外键依赖</li>\n</ol>\n<p>同步数据时，很多公司都会直接同步原始表的所有字段作为数仓<code>ods</code>层或者<code>dim</code>层，并使用mysql存储，不做任何处理，只有在流表与维表join的时候才会读取.</p>\n<p>此时可能从业务数据库导出sql并导入数仓的mysql，外键依赖也可能会导入。</p>\n<p>那么需要注意去掉其外键依赖，否则会在同步时发生异常。</p>\n"},{"title":"微服务改造-2-网关","date":"2019-07-11T12:16:39.000Z","_content":"\n网关验证是粗粒度的鉴权,只是用来隔离外部的无效请求, 比如爬虫; 各服务之间会有细粒度的鉴权, 依靠ip白名单以及token鉴权\n混合云情况下, 要考虑子网和公网\n请求通过网关层之后, https协议可以转为http协议, 内部之间调用使用http, 减少消耗; 数据协议可以转为protobuffer, 网关与业务层、业务与数据层之间交互均可使用protobuffer\n","source":"_posts/microservice/微服务改造-2-网关.md","raw":"---\ntitle: 微服务改造-2-网关\ndate: 2019-07-11 20:16:39\ncategories: 微服务改造\ntags:\n- 微服务\n- 网关\n---\n\n网关验证是粗粒度的鉴权,只是用来隔离外部的无效请求, 比如爬虫; 各服务之间会有细粒度的鉴权, 依靠ip白名单以及token鉴权\n混合云情况下, 要考虑子网和公网\n请求通过网关层之后, https协议可以转为http协议, 内部之间调用使用http, 减少消耗; 数据协议可以转为protobuffer, 网关与业务层、业务与数据层之间交互均可使用protobuffer\n","slug":"microservice/微服务改造-2-网关","published":1,"updated":"2020-10-27T08:08:15.942Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckio9dwfc004nk8neiifg6s8a","content":"<p>网关验证是粗粒度的鉴权,只是用来隔离外部的无效请求, 比如爬虫; 各服务之间会有细粒度的鉴权, 依靠ip白名单以及token鉴权<br>混合云情况下, 要考虑子网和公网<br>请求通过网关层之后, https协议可以转为http协议, 内部之间调用使用http, 减少消耗; 数据协议可以转为protobuffer, 网关与业务层、业务与数据层之间交互均可使用protobuffer</p>\n","site":{"data":{}},"excerpt":"","more":"<p>网关验证是粗粒度的鉴权,只是用来隔离外部的无效请求, 比如爬虫; 各服务之间会有细粒度的鉴权, 依靠ip白名单以及token鉴权<br>混合云情况下, 要考虑子网和公网<br>请求通过网关层之后, https协议可以转为http协议, 内部之间调用使用http, 减少消耗; 数据协议可以转为protobuffer, 网关与业务层、业务与数据层之间交互均可使用protobuffer</p>\n"},{"title":"微服务改造实践(1)-配置中心","date":"2019-07-08T13:49:43.000Z","_content":"#### 一、问题发现\n\n之前使用配置文件的形式进行管理，比如MySQL配置文件分为:\n\n* `db.properties`\n* `db.dev.properties`\n* `db.test.properties`\n* `db.prod.properties`\n\n在部署到对应环境的时候，比如到`test`环境，运维会执行类似`mv db.test.properties db.properties`的命令，将对应环境的文件覆盖到程序指定的文件`db.properties`。\n除此之外，还有很多配置文件都与运行环境相关联，**在不同的环境必须设置不同的值**。\n<!--more-->\n随着越来越多服务上线，陆续暴露了很多问题：\n\n1. 配置文件过多，过于分散，开发人员稍不留意就容易出错,并且运维人员很难审核排错\n2. 配置无法追溯，无法回滚\n3. 修改配置需要重启，希望能够在程序运行时动态调整部分配置\n4. 所有开发人员都能看到线上生产环境配置，安全性很差\n\n#### 二、找寻方案\n\n所以我们希望能有这样一个组件或者一套系统，能够实现如下功能：\n\n1. 集中管理配置\n2. 与程序分离，避免开发误操作影响系统\n3. 配置支持版本控制\n4. 配置能够动态生效\n5. 能有权限和审核机制\n6. UI管理界面\n\n那从2017年开始，陆续我们已经看到了不少开源配置中心的发布，所以开始调研了一下目前开源的一些配置中心。\n\n* `Consul`（生态在国内并不好）\n* `Disconf` （无UI，生态比Apollo差很多）\n* `Diamond` （停止维护）\n* `Spring Cloud Config` （配置重启才生效）\n* `Nacos` \n* `Ctrip Apollo`\n\n最终能够满足需求的只有`Apollo`和`Nacos`, 而`Apollo`已经很成熟，经历过太多生产环境的实践，所以最终选择了`Apollo`.","source":"_posts/microservice/微服务改造-1-配置中心.md","raw":"---\ntitle: 微服务改造实践(1)-配置中心\ndate: 2019-07-08 21:49:43\ncategories: 微服务改造\ntags:\n- 微服务\n- 配置中心\n---\n#### 一、问题发现\n\n之前使用配置文件的形式进行管理，比如MySQL配置文件分为:\n\n* `db.properties`\n* `db.dev.properties`\n* `db.test.properties`\n* `db.prod.properties`\n\n在部署到对应环境的时候，比如到`test`环境，运维会执行类似`mv db.test.properties db.properties`的命令，将对应环境的文件覆盖到程序指定的文件`db.properties`。\n除此之外，还有很多配置文件都与运行环境相关联，**在不同的环境必须设置不同的值**。\n<!--more-->\n随着越来越多服务上线，陆续暴露了很多问题：\n\n1. 配置文件过多，过于分散，开发人员稍不留意就容易出错,并且运维人员很难审核排错\n2. 配置无法追溯，无法回滚\n3. 修改配置需要重启，希望能够在程序运行时动态调整部分配置\n4. 所有开发人员都能看到线上生产环境配置，安全性很差\n\n#### 二、找寻方案\n\n所以我们希望能有这样一个组件或者一套系统，能够实现如下功能：\n\n1. 集中管理配置\n2. 与程序分离，避免开发误操作影响系统\n3. 配置支持版本控制\n4. 配置能够动态生效\n5. 能有权限和审核机制\n6. UI管理界面\n\n那从2017年开始，陆续我们已经看到了不少开源配置中心的发布，所以开始调研了一下目前开源的一些配置中心。\n\n* `Consul`（生态在国内并不好）\n* `Disconf` （无UI，生态比Apollo差很多）\n* `Diamond` （停止维护）\n* `Spring Cloud Config` （配置重启才生效）\n* `Nacos` \n* `Ctrip Apollo`\n\n最终能够满足需求的只有`Apollo`和`Nacos`, 而`Apollo`已经很成熟，经历过太多生产环境的实践，所以最终选择了`Apollo`.","slug":"microservice/微服务改造-1-配置中心","published":1,"updated":"2020-10-27T08:08:15.941Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckio9dwfe004qk8nez0p19hgz","content":"<h4 id=\"一、问题发现\"><a href=\"#一、问题发现\" class=\"headerlink\" title=\"一、问题发现\"></a>一、问题发现</h4><p>之前使用配置文件的形式进行管理，比如MySQL配置文件分为:</p>\n<ul>\n<li><code>db.properties</code></li>\n<li><code>db.dev.properties</code></li>\n<li><code>db.test.properties</code></li>\n<li><code>db.prod.properties</code></li>\n</ul>\n<p>在部署到对应环境的时候，比如到<code>test</code>环境，运维会执行类似<code>mv db.test.properties db.properties</code>的命令，将对应环境的文件覆盖到程序指定的文件<code>db.properties</code>。<br>除此之外，还有很多配置文件都与运行环境相关联，<strong>在不同的环境必须设置不同的值</strong>。</p>\n<a id=\"more\"></a>\n<p>随着越来越多服务上线，陆续暴露了很多问题：</p>\n<ol>\n<li>配置文件过多，过于分散，开发人员稍不留意就容易出错,并且运维人员很难审核排错</li>\n<li>配置无法追溯，无法回滚</li>\n<li>修改配置需要重启，希望能够在程序运行时动态调整部分配置</li>\n<li>所有开发人员都能看到线上生产环境配置，安全性很差</li>\n</ol>\n<h4 id=\"二、找寻方案\"><a href=\"#二、找寻方案\" class=\"headerlink\" title=\"二、找寻方案\"></a>二、找寻方案</h4><p>所以我们希望能有这样一个组件或者一套系统，能够实现如下功能：</p>\n<ol>\n<li>集中管理配置</li>\n<li>与程序分离，避免开发误操作影响系统</li>\n<li>配置支持版本控制</li>\n<li>配置能够动态生效</li>\n<li>能有权限和审核机制</li>\n<li>UI管理界面</li>\n</ol>\n<p>那从2017年开始，陆续我们已经看到了不少开源配置中心的发布，所以开始调研了一下目前开源的一些配置中心。</p>\n<ul>\n<li><code>Consul</code>（生态在国内并不好）</li>\n<li><code>Disconf</code> （无UI，生态比Apollo差很多）</li>\n<li><code>Diamond</code> （停止维护）</li>\n<li><code>Spring Cloud Config</code> （配置重启才生效）</li>\n<li><code>Nacos</code> </li>\n<li><code>Ctrip Apollo</code></li>\n</ul>\n<p>最终能够满足需求的只有<code>Apollo</code>和<code>Nacos</code>, 而<code>Apollo</code>已经很成熟，经历过太多生产环境的实践，所以最终选择了<code>Apollo</code>.</p>\n","site":{"data":{}},"excerpt":"<h4 id=\"一、问题发现\"><a href=\"#一、问题发现\" class=\"headerlink\" title=\"一、问题发现\"></a>一、问题发现</h4><p>之前使用配置文件的形式进行管理，比如MySQL配置文件分为:</p>\n<ul>\n<li><code>db.properties</code></li>\n<li><code>db.dev.properties</code></li>\n<li><code>db.test.properties</code></li>\n<li><code>db.prod.properties</code></li>\n</ul>\n<p>在部署到对应环境的时候，比如到<code>test</code>环境，运维会执行类似<code>mv db.test.properties db.properties</code>的命令，将对应环境的文件覆盖到程序指定的文件<code>db.properties</code>。<br>除此之外，还有很多配置文件都与运行环境相关联，<strong>在不同的环境必须设置不同的值</strong>。</p>","more":"<p>随着越来越多服务上线，陆续暴露了很多问题：</p>\n<ol>\n<li>配置文件过多，过于分散，开发人员稍不留意就容易出错,并且运维人员很难审核排错</li>\n<li>配置无法追溯，无法回滚</li>\n<li>修改配置需要重启，希望能够在程序运行时动态调整部分配置</li>\n<li>所有开发人员都能看到线上生产环境配置，安全性很差</li>\n</ol>\n<h4 id=\"二、找寻方案\"><a href=\"#二、找寻方案\" class=\"headerlink\" title=\"二、找寻方案\"></a>二、找寻方案</h4><p>所以我们希望能有这样一个组件或者一套系统，能够实现如下功能：</p>\n<ol>\n<li>集中管理配置</li>\n<li>与程序分离，避免开发误操作影响系统</li>\n<li>配置支持版本控制</li>\n<li>配置能够动态生效</li>\n<li>能有权限和审核机制</li>\n<li>UI管理界面</li>\n</ol>\n<p>那从2017年开始，陆续我们已经看到了不少开源配置中心的发布，所以开始调研了一下目前开源的一些配置中心。</p>\n<ul>\n<li><code>Consul</code>（生态在国内并不好）</li>\n<li><code>Disconf</code> （无UI，生态比Apollo差很多）</li>\n<li><code>Diamond</code> （停止维护）</li>\n<li><code>Spring Cloud Config</code> （配置重启才生效）</li>\n<li><code>Nacos</code> </li>\n<li><code>Ctrip Apollo</code></li>\n</ul>\n<p>最终能够满足需求的只有<code>Apollo</code>和<code>Nacos</code>, 而<code>Apollo</code>已经很成熟，经历过太多生产环境的实践，所以最终选择了<code>Apollo</code>.</p>"},{"title":"微服务改造-3 Kong路由配置实战及JWT校验","date":"2019-11-17T13:30:50.000Z","_content":"\n[toc]\n\n### 一、 背景\n\n(一)网关用处\n\n1. Open API: 将自身数据、能力作为开放平台对外开放. 这必然涉及到客户应用的接入、API权限的管理、调用次数管理等, 必然会有一个统一的入口进行管理\n2. 微服务网关: 负载均衡,缓存,路由,访问控制,服务代理,监控,日志等\n3. API服务管理平台: 由于不同系统间存在大量的API服务互相调用, 因此需要对系统间服务调用进行管理, 清晰的看到个系统调用关系, 对系统间调用进行监控等.\n<!--more-->\n(二)选型-Kong\n\nKong基于OpenResty(Nginx + lua), 具有高性能、配置简单、插件丰富、业务代码无入侵等特点,故使用了接口网关Kong.\n\n\n(三)JWT拦截\n\n基于等保与接口安全考虑, 要求所有服务私有API都要有安全校验.\n\nJWT是目前最为流行的token生成规则,基于JSON开发标准, 适用于身份验证, SSO,鉴权等方案中.\n\nKong支持配置JWT插件, 并支持在不同级别Global,Service,Route上配置, 动态生效, 配置灵活, 因此我们开始了在Kong上配置JWT的实战方案调研.\n\n### 二、需求与调研目的\n\n1. 公有API无需进行JWT拦截\n2. 私有API必须进行JWT拦截\n3. 服务间内网互相调用, 所有API都无需拦截\n4. 客户端使用公有API进行登录,同时获取到签发JWT, 访问私有API需携带token\n5. 对代码无影响或影响较少(通过拦截器配置, 不能影响到方法级别)\n\n目的：通过调研方案, 能够实现上述需求.\n\n### 三、调研方案分析\n\n#### (一) Project -> Service -> Route    不满足需求\n\n```mermaid\nProject->Kong.Service:一对一,Service.URL指向项目根路径\n#Note over Project实体,Kong.Service: Service.URL配置为项目根路径\nKong.Service->Kong.Route:一对一,Route配置paths为/serviceName\nNote right of Kong.Route: strip_path=true\n```\n\n<u>缺点: <b>代理了根路径,无法针对公有API和私有API分别配置</b></u>\n\n\n\n####(二) Project -> Service -> Multi Route (by paths)    不满足需求\n\n方案:  统计公有API和私有API, 并分别拆分出多条Route. 尝试使用`paths`进行区分.\n\n```sequence\nProject->Kong.Service:一对一,Service.URL指向项目根路径\n#Note over Project实体,Kong.Service: Service.URL配置为项目根路径\nKong.Service->Kong.Route1:Route配置paths为/serviceName/${path_to_auth}\nKong.Service->Kong.Route2:Route配置paths为/serviceName/${path_to_noauth}\nNote right of Kong.Route2: strip_path=true\n```\n\n<u>结论: **完全无法满足需求, 因为strip_path属性会将匹配的paths全部删除, 导致路由到项目的地址错误.**</u>\n\nEg:\n\n``` yaml\n#kong配置两条Route\n\nroute1: /weikefangtest/api/common         \t\t\t\t\t   #-不配置JWT插件\n\nroute2: /weikefangtest/api/v1, /weikefangtest/api/v2   #-配置JWT插件\n\n#----------------------------期望---------------------------------------------\n访问:     https://open.ibeiwai.com/weikefangtest/api/common/login\n期待路径: ${weikefang_domain}/api/common/login\n\n#--------------------- 结果1: 当Route.Strip_path=true ------------------------\n实际路径: ${weikefang_domain}/login\n\n\n#--------------------- 结果1: 当Route.Strip_path=false ------------------------\n实际路径: ${weikefang_domain}/weikefangtest/api/common/login\n```\n\n所以尝试寻找解决方案, 能够实现:\n\n**部分匹配路径 或者 在请求时能够切除或者替换部分路径**\n\n在官方文档、官方论坛、StackOverflow、QQ群多方查询下, 最终仍然无法实现上述需求.\n\n* kong的配置项`strip_path`支持正则表达式的`paths`, 但也只能全部切除路径. \n* 找到request-transformer-advanced企业版插件, 有replace uri的功能\n* 企业版没发现购买入口, 在kong官网申请企业版试用, 一周内未收到反馈\n\n#### (三) Project -> Multi Service -> Route (by service)   不满足需求\n\n``` sequence\nProject->Kong.Service1:Service.URL指向接口需要鉴权的根路径\nProject->Kong.Service2:URL指向不需要鉴权的根路径\n#Note over Project实体,Kong.Service: Service.URL配置为项目根路径\nKong.Service1->Kong.Route1:Route配置paths为/${path_to_auth}\nKong.Service2->Kong.Route2:Route配置paths为/${path_to_noauth}\nNote right of Kong.Route2: strip_path=false\n```\n\n结论: 当有多个项目时, 存在路径冲突. \n\nEg:\n\n```\n\n```\n\n#### (四)Project -> Service -> Multi Route (by headers) 满足需求\n\n#### (五) Kong Project->Service->根Route  + Spring Interceptor 满足需求\n\n###四、后端主动or前端主动\n\n方案1.后端存储最后一次token，后端判断toekn,合法超时，刷新token推给前端\n\n优点：前端改动小\n\n缺点：后端实现复杂，需要而外存储。\n\n存在问题：\n\n1.由于前端会存在并发请求，当并发请求收到多个jwt token时，由于前端无序，会导致前端的jwt token和后端存储的jwt token不一致，导致不匹配\n\n解决方案：\n\n端会存在并发请求。当token失效时，遇到并发情况时，就搞个分布式锁让并行变成串行。\n\n方案2.\n\n前端解码token。拿到过期时间，和当前时间进行判断。如果快过期，主动调用获取新token.\n\n缺点：前端每次请求需要解码判断\n\n优点：后端压力小，不需要存储","source":"_posts/microservice/微服务改造-3-Kong路由配置实战及JWT校验.md","raw":"---\ntitle: 微服务改造-3 Kong路由配置实战及JWT校验\ndate: 2019-11-17 21:30:50\ncategories: 微服务改造\ntags:\n- 微服务\n- 网关\n---\n\n[toc]\n\n### 一、 背景\n\n(一)网关用处\n\n1. Open API: 将自身数据、能力作为开放平台对外开放. 这必然涉及到客户应用的接入、API权限的管理、调用次数管理等, 必然会有一个统一的入口进行管理\n2. 微服务网关: 负载均衡,缓存,路由,访问控制,服务代理,监控,日志等\n3. API服务管理平台: 由于不同系统间存在大量的API服务互相调用, 因此需要对系统间服务调用进行管理, 清晰的看到个系统调用关系, 对系统间调用进行监控等.\n<!--more-->\n(二)选型-Kong\n\nKong基于OpenResty(Nginx + lua), 具有高性能、配置简单、插件丰富、业务代码无入侵等特点,故使用了接口网关Kong.\n\n\n(三)JWT拦截\n\n基于等保与接口安全考虑, 要求所有服务私有API都要有安全校验.\n\nJWT是目前最为流行的token生成规则,基于JSON开发标准, 适用于身份验证, SSO,鉴权等方案中.\n\nKong支持配置JWT插件, 并支持在不同级别Global,Service,Route上配置, 动态生效, 配置灵活, 因此我们开始了在Kong上配置JWT的实战方案调研.\n\n### 二、需求与调研目的\n\n1. 公有API无需进行JWT拦截\n2. 私有API必须进行JWT拦截\n3. 服务间内网互相调用, 所有API都无需拦截\n4. 客户端使用公有API进行登录,同时获取到签发JWT, 访问私有API需携带token\n5. 对代码无影响或影响较少(通过拦截器配置, 不能影响到方法级别)\n\n目的：通过调研方案, 能够实现上述需求.\n\n### 三、调研方案分析\n\n#### (一) Project -> Service -> Route    不满足需求\n\n```mermaid\nProject->Kong.Service:一对一,Service.URL指向项目根路径\n#Note over Project实体,Kong.Service: Service.URL配置为项目根路径\nKong.Service->Kong.Route:一对一,Route配置paths为/serviceName\nNote right of Kong.Route: strip_path=true\n```\n\n<u>缺点: <b>代理了根路径,无法针对公有API和私有API分别配置</b></u>\n\n\n\n####(二) Project -> Service -> Multi Route (by paths)    不满足需求\n\n方案:  统计公有API和私有API, 并分别拆分出多条Route. 尝试使用`paths`进行区分.\n\n```sequence\nProject->Kong.Service:一对一,Service.URL指向项目根路径\n#Note over Project实体,Kong.Service: Service.URL配置为项目根路径\nKong.Service->Kong.Route1:Route配置paths为/serviceName/${path_to_auth}\nKong.Service->Kong.Route2:Route配置paths为/serviceName/${path_to_noauth}\nNote right of Kong.Route2: strip_path=true\n```\n\n<u>结论: **完全无法满足需求, 因为strip_path属性会将匹配的paths全部删除, 导致路由到项目的地址错误.**</u>\n\nEg:\n\n``` yaml\n#kong配置两条Route\n\nroute1: /weikefangtest/api/common         \t\t\t\t\t   #-不配置JWT插件\n\nroute2: /weikefangtest/api/v1, /weikefangtest/api/v2   #-配置JWT插件\n\n#----------------------------期望---------------------------------------------\n访问:     https://open.ibeiwai.com/weikefangtest/api/common/login\n期待路径: ${weikefang_domain}/api/common/login\n\n#--------------------- 结果1: 当Route.Strip_path=true ------------------------\n实际路径: ${weikefang_domain}/login\n\n\n#--------------------- 结果1: 当Route.Strip_path=false ------------------------\n实际路径: ${weikefang_domain}/weikefangtest/api/common/login\n```\n\n所以尝试寻找解决方案, 能够实现:\n\n**部分匹配路径 或者 在请求时能够切除或者替换部分路径**\n\n在官方文档、官方论坛、StackOverflow、QQ群多方查询下, 最终仍然无法实现上述需求.\n\n* kong的配置项`strip_path`支持正则表达式的`paths`, 但也只能全部切除路径. \n* 找到request-transformer-advanced企业版插件, 有replace uri的功能\n* 企业版没发现购买入口, 在kong官网申请企业版试用, 一周内未收到反馈\n\n#### (三) Project -> Multi Service -> Route (by service)   不满足需求\n\n``` sequence\nProject->Kong.Service1:Service.URL指向接口需要鉴权的根路径\nProject->Kong.Service2:URL指向不需要鉴权的根路径\n#Note over Project实体,Kong.Service: Service.URL配置为项目根路径\nKong.Service1->Kong.Route1:Route配置paths为/${path_to_auth}\nKong.Service2->Kong.Route2:Route配置paths为/${path_to_noauth}\nNote right of Kong.Route2: strip_path=false\n```\n\n结论: 当有多个项目时, 存在路径冲突. \n\nEg:\n\n```\n\n```\n\n#### (四)Project -> Service -> Multi Route (by headers) 满足需求\n\n#### (五) Kong Project->Service->根Route  + Spring Interceptor 满足需求\n\n###四、后端主动or前端主动\n\n方案1.后端存储最后一次token，后端判断toekn,合法超时，刷新token推给前端\n\n优点：前端改动小\n\n缺点：后端实现复杂，需要而外存储。\n\n存在问题：\n\n1.由于前端会存在并发请求，当并发请求收到多个jwt token时，由于前端无序，会导致前端的jwt token和后端存储的jwt token不一致，导致不匹配\n\n解决方案：\n\n端会存在并发请求。当token失效时，遇到并发情况时，就搞个分布式锁让并行变成串行。\n\n方案2.\n\n前端解码token。拿到过期时间，和当前时间进行判断。如果快过期，主动调用获取新token.\n\n缺点：前端每次请求需要解码判断\n\n优点：后端压力小，不需要存储","slug":"microservice/微服务改造-3-Kong路由配置实战及JWT校验","published":1,"updated":"2020-10-27T08:08:15.942Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckio9dwfg004uk8nenye67j1x","content":"<p>[toc]</p>\n<h3 id=\"一、-背景\"><a href=\"#一、-背景\" class=\"headerlink\" title=\"一、 背景\"></a>一、 背景</h3><p>(一)网关用处</p>\n<ol>\n<li>Open API: 将自身数据、能力作为开放平台对外开放. 这必然涉及到客户应用的接入、API权限的管理、调用次数管理等, 必然会有一个统一的入口进行管理</li>\n<li>微服务网关: 负载均衡,缓存,路由,访问控制,服务代理,监控,日志等</li>\n<li>API服务管理平台: 由于不同系统间存在大量的API服务互相调用, 因此需要对系统间服务调用进行管理, 清晰的看到个系统调用关系, 对系统间调用进行监控等.<a id=\"more\"></a>\n(二)选型-Kong</li>\n</ol>\n<p>Kong基于OpenResty(Nginx + lua), 具有高性能、配置简单、插件丰富、业务代码无入侵等特点,故使用了接口网关Kong.</p>\n<p>(三)JWT拦截</p>\n<p>基于等保与接口安全考虑, 要求所有服务私有API都要有安全校验.</p>\n<p>JWT是目前最为流行的token生成规则,基于JSON开发标准, 适用于身份验证, SSO,鉴权等方案中.</p>\n<p>Kong支持配置JWT插件, 并支持在不同级别Global,Service,Route上配置, 动态生效, 配置灵活, 因此我们开始了在Kong上配置JWT的实战方案调研.</p>\n<h3 id=\"二、需求与调研目的\"><a href=\"#二、需求与调研目的\" class=\"headerlink\" title=\"二、需求与调研目的\"></a>二、需求与调研目的</h3><ol>\n<li>公有API无需进行JWT拦截</li>\n<li>私有API必须进行JWT拦截</li>\n<li>服务间内网互相调用, 所有API都无需拦截</li>\n<li>客户端使用公有API进行登录,同时获取到签发JWT, 访问私有API需携带token</li>\n<li>对代码无影响或影响较少(通过拦截器配置, 不能影响到方法级别)</li>\n</ol>\n<p>目的：通过调研方案, 能够实现上述需求.</p>\n<h3 id=\"三、调研方案分析\"><a href=\"#三、调研方案分析\" class=\"headerlink\" title=\"三、调研方案分析\"></a>三、调研方案分析</h3><h4 id=\"一-Project-gt-Service-gt-Route-不满足需求\"><a href=\"#一-Project-gt-Service-gt-Route-不满足需求\" class=\"headerlink\" title=\"(一) Project -&gt; Service -&gt; Route    不满足需求\"></a>(一) Project -&gt; Service -&gt; Route    不满足需求</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Project-&gt;Kong.Service:一对一,Service.URL指向项目根路径</span><br><span class=\"line\">#Note over Project实体,Kong.Service: Service.URL配置为项目根路径</span><br><span class=\"line\">Kong.Service-&gt;Kong.Route:一对一,Route配置paths为/serviceName</span><br><span class=\"line\">Note right of Kong.Route: strip_path=true</span><br></pre></td></tr></table></figure>\n\n<p><u>缺点: <b>代理了根路径,无法针对公有API和私有API分别配置</b></u></p>\n<p>####(二) Project -&gt; Service -&gt; Multi Route (by paths)    不满足需求</p>\n<p>方案:  统计公有API和私有API, 并分别拆分出多条Route. 尝试使用<code>paths</code>进行区分.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Project-&gt;Kong.Service:一对一,Service.URL指向项目根路径</span><br><span class=\"line\">#Note over Project实体,Kong.Service: Service.URL配置为项目根路径</span><br><span class=\"line\">Kong.Service-&gt;Kong.Route1:Route配置paths为/serviceName/$&#123;path_to_auth&#125;</span><br><span class=\"line\">Kong.Service-&gt;Kong.Route2:Route配置paths为/serviceName/$&#123;path_to_noauth&#125;</span><br><span class=\"line\">Note right of Kong.Route2: strip_path=true</span><br></pre></td></tr></table></figure>\n\n<p><u>结论: <strong>完全无法满足需求, 因为strip_path属性会将匹配的paths全部删除, 导致路由到项目的地址错误.</strong></u></p>\n<p>Eg:</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#kong配置两条Route</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">route1:</span> <span class=\"string\">/weikefangtest/api/common</span>         \t\t\t\t\t   <span class=\"comment\">#-不配置JWT插件</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">route2:</span> <span class=\"string\">/weikefangtest/api/v1,</span> <span class=\"string\">/weikefangtest/api/v2</span>   <span class=\"comment\">#-配置JWT插件</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#----------------------------期望---------------------------------------------</span></span><br><span class=\"line\"><span class=\"string\">访问:</span>     <span class=\"string\">https://open.ibeiwai.com/weikefangtest/api/common/login</span></span><br><span class=\"line\"><span class=\"string\">期待路径:</span> <span class=\"string\">$&#123;weikefang_domain&#125;/api/common/login</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#--------------------- 结果1: 当Route.Strip_path=true ------------------------</span></span><br><span class=\"line\"><span class=\"string\">实际路径:</span> <span class=\"string\">$&#123;weikefang_domain&#125;/login</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#--------------------- 结果1: 当Route.Strip_path=false ------------------------</span></span><br><span class=\"line\"><span class=\"string\">实际路径:</span> <span class=\"string\">$&#123;weikefang_domain&#125;/weikefangtest/api/common/login</span></span><br></pre></td></tr></table></figure>\n\n<p>所以尝试寻找解决方案, 能够实现:</p>\n<p><strong>部分匹配路径 或者 在请求时能够切除或者替换部分路径</strong></p>\n<p>在官方文档、官方论坛、StackOverflow、QQ群多方查询下, 最终仍然无法实现上述需求.</p>\n<ul>\n<li>kong的配置项<code>strip_path</code>支持正则表达式的<code>paths</code>, 但也只能全部切除路径. </li>\n<li>找到request-transformer-advanced企业版插件, 有replace uri的功能</li>\n<li>企业版没发现购买入口, 在kong官网申请企业版试用, 一周内未收到反馈</li>\n</ul>\n<h4 id=\"三-Project-gt-Multi-Service-gt-Route-by-service-不满足需求\"><a href=\"#三-Project-gt-Multi-Service-gt-Route-by-service-不满足需求\" class=\"headerlink\" title=\"(三) Project -&gt; Multi Service -&gt; Route (by service)   不满足需求\"></a>(三) Project -&gt; Multi Service -&gt; Route (by service)   不满足需求</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Project-&gt;Kong.Service1:Service.URL指向接口需要鉴权的根路径</span><br><span class=\"line\">Project-&gt;Kong.Service2:URL指向不需要鉴权的根路径</span><br><span class=\"line\">#Note over Project实体,Kong.Service: Service.URL配置为项目根路径</span><br><span class=\"line\">Kong.Service1-&gt;Kong.Route1:Route配置paths为/$&#123;path_to_auth&#125;</span><br><span class=\"line\">Kong.Service2-&gt;Kong.Route2:Route配置paths为/$&#123;path_to_noauth&#125;</span><br><span class=\"line\">Note right of Kong.Route2: strip_path=false</span><br></pre></td></tr></table></figure>\n\n<p>结论: 当有多个项目时, 存在路径冲突. </p>\n<p>Eg:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"四-Project-gt-Service-gt-Multi-Route-by-headers-满足需求\"><a href=\"#四-Project-gt-Service-gt-Multi-Route-by-headers-满足需求\" class=\"headerlink\" title=\"(四)Project -&gt; Service -&gt; Multi Route (by headers) 满足需求\"></a>(四)Project -&gt; Service -&gt; Multi Route (by headers) 满足需求</h4><h4 id=\"五-Kong-Project-gt-Service-gt-根Route-Spring-Interceptor-满足需求\"><a href=\"#五-Kong-Project-gt-Service-gt-根Route-Spring-Interceptor-满足需求\" class=\"headerlink\" title=\"(五) Kong Project-&gt;Service-&gt;根Route  + Spring Interceptor 满足需求\"></a>(五) Kong Project-&gt;Service-&gt;根Route  + Spring Interceptor 满足需求</h4><p>###四、后端主动or前端主动</p>\n<p>方案1.后端存储最后一次token，后端判断toekn,合法超时，刷新token推给前端</p>\n<p>优点：前端改动小</p>\n<p>缺点：后端实现复杂，需要而外存储。</p>\n<p>存在问题：</p>\n<p>1.由于前端会存在并发请求，当并发请求收到多个jwt token时，由于前端无序，会导致前端的jwt token和后端存储的jwt token不一致，导致不匹配</p>\n<p>解决方案：</p>\n<p>端会存在并发请求。当token失效时，遇到并发情况时，就搞个分布式锁让并行变成串行。</p>\n<p>方案2.</p>\n<p>前端解码token。拿到过期时间，和当前时间进行判断。如果快过期，主动调用获取新token.</p>\n<p>缺点：前端每次请求需要解码判断</p>\n<p>优点：后端压力小，不需要存储</p>\n","site":{"data":{}},"excerpt":"<p>[toc]</p>\n<h3 id=\"一、-背景\"><a href=\"#一、-背景\" class=\"headerlink\" title=\"一、 背景\"></a>一、 背景</h3><p>(一)网关用处</p>\n<ol>\n<li>Open API: 将自身数据、能力作为开放平台对外开放. 这必然涉及到客户应用的接入、API权限的管理、调用次数管理等, 必然会有一个统一的入口进行管理</li>\n<li>微服务网关: 负载均衡,缓存,路由,访问控制,服务代理,监控,日志等</li>\n<li>API服务管理平台: 由于不同系统间存在大量的API服务互相调用, 因此需要对系统间服务调用进行管理, 清晰的看到个系统调用关系, 对系统间调用进行监控等.","more":"(二)选型-Kong</li>\n</ol>\n<p>Kong基于OpenResty(Nginx + lua), 具有高性能、配置简单、插件丰富、业务代码无入侵等特点,故使用了接口网关Kong.</p>\n<p>(三)JWT拦截</p>\n<p>基于等保与接口安全考虑, 要求所有服务私有API都要有安全校验.</p>\n<p>JWT是目前最为流行的token生成规则,基于JSON开发标准, 适用于身份验证, SSO,鉴权等方案中.</p>\n<p>Kong支持配置JWT插件, 并支持在不同级别Global,Service,Route上配置, 动态生效, 配置灵活, 因此我们开始了在Kong上配置JWT的实战方案调研.</p>\n<h3 id=\"二、需求与调研目的\"><a href=\"#二、需求与调研目的\" class=\"headerlink\" title=\"二、需求与调研目的\"></a>二、需求与调研目的</h3><ol>\n<li>公有API无需进行JWT拦截</li>\n<li>私有API必须进行JWT拦截</li>\n<li>服务间内网互相调用, 所有API都无需拦截</li>\n<li>客户端使用公有API进行登录,同时获取到签发JWT, 访问私有API需携带token</li>\n<li>对代码无影响或影响较少(通过拦截器配置, 不能影响到方法级别)</li>\n</ol>\n<p>目的：通过调研方案, 能够实现上述需求.</p>\n<h3 id=\"三、调研方案分析\"><a href=\"#三、调研方案分析\" class=\"headerlink\" title=\"三、调研方案分析\"></a>三、调研方案分析</h3><h4 id=\"一-Project-gt-Service-gt-Route-不满足需求\"><a href=\"#一-Project-gt-Service-gt-Route-不满足需求\" class=\"headerlink\" title=\"(一) Project -&gt; Service -&gt; Route    不满足需求\"></a>(一) Project -&gt; Service -&gt; Route    不满足需求</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Project-&gt;Kong.Service:一对一,Service.URL指向项目根路径</span><br><span class=\"line\">#Note over Project实体,Kong.Service: Service.URL配置为项目根路径</span><br><span class=\"line\">Kong.Service-&gt;Kong.Route:一对一,Route配置paths为/serviceName</span><br><span class=\"line\">Note right of Kong.Route: strip_path=true</span><br></pre></td></tr></table></figure>\n\n<p><u>缺点: <b>代理了根路径,无法针对公有API和私有API分别配置</b></u></p>\n<p>####(二) Project -&gt; Service -&gt; Multi Route (by paths)    不满足需求</p>\n<p>方案:  统计公有API和私有API, 并分别拆分出多条Route. 尝试使用<code>paths</code>进行区分.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Project-&gt;Kong.Service:一对一,Service.URL指向项目根路径</span><br><span class=\"line\">#Note over Project实体,Kong.Service: Service.URL配置为项目根路径</span><br><span class=\"line\">Kong.Service-&gt;Kong.Route1:Route配置paths为/serviceName/$&#123;path_to_auth&#125;</span><br><span class=\"line\">Kong.Service-&gt;Kong.Route2:Route配置paths为/serviceName/$&#123;path_to_noauth&#125;</span><br><span class=\"line\">Note right of Kong.Route2: strip_path=true</span><br></pre></td></tr></table></figure>\n\n<p><u>结论: <strong>完全无法满足需求, 因为strip_path属性会将匹配的paths全部删除, 导致路由到项目的地址错误.</strong></u></p>\n<p>Eg:</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#kong配置两条Route</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">route1:</span> <span class=\"string\">/weikefangtest/api/common</span>         \t\t\t\t\t   <span class=\"comment\">#-不配置JWT插件</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">route2:</span> <span class=\"string\">/weikefangtest/api/v1,</span> <span class=\"string\">/weikefangtest/api/v2</span>   <span class=\"comment\">#-配置JWT插件</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#----------------------------期望---------------------------------------------</span></span><br><span class=\"line\"><span class=\"string\">访问:</span>     <span class=\"string\">https://open.ibeiwai.com/weikefangtest/api/common/login</span></span><br><span class=\"line\"><span class=\"string\">期待路径:</span> <span class=\"string\">$&#123;weikefang_domain&#125;/api/common/login</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#--------------------- 结果1: 当Route.Strip_path=true ------------------------</span></span><br><span class=\"line\"><span class=\"string\">实际路径:</span> <span class=\"string\">$&#123;weikefang_domain&#125;/login</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#--------------------- 结果1: 当Route.Strip_path=false ------------------------</span></span><br><span class=\"line\"><span class=\"string\">实际路径:</span> <span class=\"string\">$&#123;weikefang_domain&#125;/weikefangtest/api/common/login</span></span><br></pre></td></tr></table></figure>\n\n<p>所以尝试寻找解决方案, 能够实现:</p>\n<p><strong>部分匹配路径 或者 在请求时能够切除或者替换部分路径</strong></p>\n<p>在官方文档、官方论坛、StackOverflow、QQ群多方查询下, 最终仍然无法实现上述需求.</p>\n<ul>\n<li>kong的配置项<code>strip_path</code>支持正则表达式的<code>paths</code>, 但也只能全部切除路径. </li>\n<li>找到request-transformer-advanced企业版插件, 有replace uri的功能</li>\n<li>企业版没发现购买入口, 在kong官网申请企业版试用, 一周内未收到反馈</li>\n</ul>\n<h4 id=\"三-Project-gt-Multi-Service-gt-Route-by-service-不满足需求\"><a href=\"#三-Project-gt-Multi-Service-gt-Route-by-service-不满足需求\" class=\"headerlink\" title=\"(三) Project -&gt; Multi Service -&gt; Route (by service)   不满足需求\"></a>(三) Project -&gt; Multi Service -&gt; Route (by service)   不满足需求</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Project-&gt;Kong.Service1:Service.URL指向接口需要鉴权的根路径</span><br><span class=\"line\">Project-&gt;Kong.Service2:URL指向不需要鉴权的根路径</span><br><span class=\"line\">#Note over Project实体,Kong.Service: Service.URL配置为项目根路径</span><br><span class=\"line\">Kong.Service1-&gt;Kong.Route1:Route配置paths为/$&#123;path_to_auth&#125;</span><br><span class=\"line\">Kong.Service2-&gt;Kong.Route2:Route配置paths为/$&#123;path_to_noauth&#125;</span><br><span class=\"line\">Note right of Kong.Route2: strip_path=false</span><br></pre></td></tr></table></figure>\n\n<p>结论: 当有多个项目时, 存在路径冲突. </p>\n<p>Eg:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"四-Project-gt-Service-gt-Multi-Route-by-headers-满足需求\"><a href=\"#四-Project-gt-Service-gt-Multi-Route-by-headers-满足需求\" class=\"headerlink\" title=\"(四)Project -&gt; Service -&gt; Multi Route (by headers) 满足需求\"></a>(四)Project -&gt; Service -&gt; Multi Route (by headers) 满足需求</h4><h4 id=\"五-Kong-Project-gt-Service-gt-根Route-Spring-Interceptor-满足需求\"><a href=\"#五-Kong-Project-gt-Service-gt-根Route-Spring-Interceptor-满足需求\" class=\"headerlink\" title=\"(五) Kong Project-&gt;Service-&gt;根Route  + Spring Interceptor 满足需求\"></a>(五) Kong Project-&gt;Service-&gt;根Route  + Spring Interceptor 满足需求</h4><p>###四、后端主动or前端主动</p>\n<p>方案1.后端存储最后一次token，后端判断toekn,合法超时，刷新token推给前端</p>\n<p>优点：前端改动小</p>\n<p>缺点：后端实现复杂，需要而外存储。</p>\n<p>存在问题：</p>\n<p>1.由于前端会存在并发请求，当并发请求收到多个jwt token时，由于前端无序，会导致前端的jwt token和后端存储的jwt token不一致，导致不匹配</p>\n<p>解决方案：</p>\n<p>端会存在并发请求。当token失效时，遇到并发情况时，就搞个分布式锁让并行变成串行。</p>\n<p>方案2.</p>\n<p>前端解码token。拿到过期时间，和当前时间进行判断。如果快过期，主动调用获取新token.</p>\n<p>缺点：前端每次请求需要解码判断</p>\n<p>优点：后端压力小，不需要存储</p>"},{"title":"JVM常用知识点","date":"2020-01-05T04:03:37.000Z","_content":"#### 1. JVM运行时数据区\n\n这个图相信很多人都看过N多次了，自己再做一次加深下记忆\n![JVM Runtime](/images/jvm/JVMRuntime.png)\n\n其中方法区和堆是由所有线程共享的数据区，而我们绝大多数的JVM调优都是针对方法区和堆。\n其它都是线程隔离的数据区。\n想要理解JVM，有3个比较重要的概念需要了解清楚，分别是：\n\n* 类加载机制\n* 虚拟机栈\n* 堆\n<!--more-->\n#### 2. 类加载器\n\n##### 2.1 类加载机制\n\n虚拟机把描述类的数据从class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。\n\n##### 2.2 类的生命周期\n\n类从被加载到虚拟机内存中开始，到卸载出内存为止，整个生命周期包括：\n![类的生命周期](/images/jvm/ClassLoader.png)\n\n其中类的加载、验证、准备、初始化、卸载这5个阶段是按照顺序开始的，**解析**阶段则不一定，某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定。\n\n##### 2.3 类加载器\n\n绝大部分Java程序都会使用到以下三种系统提供的类加载器：\n\n* 启动类加载器(Bootstrap Classloader)： 加载${JAVA_HOME}/lib目录中的，并且虚拟机可识别的\n* 扩展类加载器(Extension Classloader): 加载${JAVA_HOME}/lib/ext目录中的扩展类\n* 应用程序类加载器(Application Classloader): 加载ClassPath上所指定的类库，可以理解为加载所有开发者自己写的类\n\n如果有必要，还可以加入自己定义的类加载器。\n\n##### 2.4 双亲委派模型(Parents Delegation Model)\n\n![双亲委派模型](/images/jvm/ParentsDelegationModel.png)\n\n1. 类加载器收到了加载类的请求，它首先不会自己加载这个类，而是把这个请求委派给父类加载器完成，每一个层次的类加载器都是如此。\n2. 一直向上委派，因此所有的加载请求都应该传送到顶层的启动类加载器中。\n3. 启动类加载器会检测当前类能否被加载，如果可以则加载；如果不可以则向下传递，反馈给子加载器，让其尝试自己进行加载。\n\n有了双亲委派模型，才保证了Java类型体系中最基础的行为。\n\n##### 2.5 OSGi\n\nOSGi中的类加载器并不符合传统的双亲委派的类加载器，但其对类加载器的使用是很值得学习的。\n\n#### 3. 虚拟机栈(VM Stack)\n\n了解虚拟机栈对于我们理解JVM中方法的运行有极大帮助，通过原理，我们可以了解线程中的方法调用链，知道为什么生产环境中不建议甚至禁止使用递归。\n![Stack Frame](/images/jvm/StackFrame.png)\n\n一个线程中的方法调用链可能会很长，很多方法同时处于执行状态。\n对于执行引擎来讲，在活动线程中，只有位于栈顶的栈帧才是有效的，称为当前栈帧(Current Stack Frame),与之相关联的方法称为当前方法(Current Method)。\n\n如果线程请求的栈深度大于虚拟机所允许的深度，将抛出`StackOverFlowError`异常；\n如果虚拟机栈可以动态扩展，若扩展时无法申请到足够的内存，就会抛出`OutOfMemoryError`异常。\n\n#### 4. 堆(Heap)\n\n堆的重要性是因为我们平时所需要的性能调优，GC等都发生在此内存区域。\n三种常见的JVM：HotSpot,JRockit,j9vm。而平时用的几乎都是HotSpot，我们来看看它的实现。\n\n##### 4.1 堆内存的划分\n\n由于现在GC收集器基本都采用分代收集算法，所以Java堆中可以细分为：\n\n* 新生代(Young Generation) : 99%的对象生命周期\n  * 伊甸区(Eden Space) : 创建对象\n  * 幸存者区(Survivor Space) : 对象活过GC就进入\n* 老年代(Old Generation)\n  * 养老区(Tenured Space) ： 幸存者区活过多次GC进入；大对象直接进入\n* <del>永久代(Perm Gen)</del>  元空间(MetaSpace,支持动态扩展，since Java8)\n\n![JVM heap structure](/images/jvm/JVM_Structure.png)\n\n##### 4.2 GC分类\n\n* Partial GC：并不收集整个GC堆的模式\n  * Young GC：只收集young gen的GC\n  * Old GC：只收集old gen的GC。只有CMS的concurrent collection是这个模式\n  * Mixed GC：收集整个young gen以及部分old gen的GC。只有G1有这个模式\n* Full GC：收集整个堆，包括young gen、old gen、perm gen（如果存在的话）等所有部分的模式。\n\n假如伊甸区和养老区都满了，就会发生`OutOfMemoryError`.\n\n##### 4.3 GC算法\n\n* 复制算法\n\n* 标记-清除 & 标记-整理算法\n\n* 分代收集算法\n\n没有什么新的思想，只是因为在实际场景中，并没有一种算法能够同时在所有场景下保证最优。\n所以针对每个内存区域，对象的存活率不同，可以对不同内存（新生代，老年代）采用最适当的手机算法。\n\n* 新生代 每次GC都会有大批对象死去，对象存活率低  选用复制算法\n* 老年代 对象存活率高 选用标记-清除，标记-整理算法\n\n##### 4.4 HeapDump\n\n加参数 -XX:+HeapDumpOnOutOfMemoryError 在发生OOM时生成堆快照\n","source":"_posts/java/JVM常用知识点.md","raw":"---\ntitle: JVM常用知识点\ndate: 2020-01-05 12:03:37\ncategories: Java基础\ntags:\n- JVM\n---\n#### 1. JVM运行时数据区\n\n这个图相信很多人都看过N多次了，自己再做一次加深下记忆\n![JVM Runtime](/images/jvm/JVMRuntime.png)\n\n其中方法区和堆是由所有线程共享的数据区，而我们绝大多数的JVM调优都是针对方法区和堆。\n其它都是线程隔离的数据区。\n想要理解JVM，有3个比较重要的概念需要了解清楚，分别是：\n\n* 类加载机制\n* 虚拟机栈\n* 堆\n<!--more-->\n#### 2. 类加载器\n\n##### 2.1 类加载机制\n\n虚拟机把描述类的数据从class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。\n\n##### 2.2 类的生命周期\n\n类从被加载到虚拟机内存中开始，到卸载出内存为止，整个生命周期包括：\n![类的生命周期](/images/jvm/ClassLoader.png)\n\n其中类的加载、验证、准备、初始化、卸载这5个阶段是按照顺序开始的，**解析**阶段则不一定，某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定。\n\n##### 2.3 类加载器\n\n绝大部分Java程序都会使用到以下三种系统提供的类加载器：\n\n* 启动类加载器(Bootstrap Classloader)： 加载${JAVA_HOME}/lib目录中的，并且虚拟机可识别的\n* 扩展类加载器(Extension Classloader): 加载${JAVA_HOME}/lib/ext目录中的扩展类\n* 应用程序类加载器(Application Classloader): 加载ClassPath上所指定的类库，可以理解为加载所有开发者自己写的类\n\n如果有必要，还可以加入自己定义的类加载器。\n\n##### 2.4 双亲委派模型(Parents Delegation Model)\n\n![双亲委派模型](/images/jvm/ParentsDelegationModel.png)\n\n1. 类加载器收到了加载类的请求，它首先不会自己加载这个类，而是把这个请求委派给父类加载器完成，每一个层次的类加载器都是如此。\n2. 一直向上委派，因此所有的加载请求都应该传送到顶层的启动类加载器中。\n3. 启动类加载器会检测当前类能否被加载，如果可以则加载；如果不可以则向下传递，反馈给子加载器，让其尝试自己进行加载。\n\n有了双亲委派模型，才保证了Java类型体系中最基础的行为。\n\n##### 2.5 OSGi\n\nOSGi中的类加载器并不符合传统的双亲委派的类加载器，但其对类加载器的使用是很值得学习的。\n\n#### 3. 虚拟机栈(VM Stack)\n\n了解虚拟机栈对于我们理解JVM中方法的运行有极大帮助，通过原理，我们可以了解线程中的方法调用链，知道为什么生产环境中不建议甚至禁止使用递归。\n![Stack Frame](/images/jvm/StackFrame.png)\n\n一个线程中的方法调用链可能会很长，很多方法同时处于执行状态。\n对于执行引擎来讲，在活动线程中，只有位于栈顶的栈帧才是有效的，称为当前栈帧(Current Stack Frame),与之相关联的方法称为当前方法(Current Method)。\n\n如果线程请求的栈深度大于虚拟机所允许的深度，将抛出`StackOverFlowError`异常；\n如果虚拟机栈可以动态扩展，若扩展时无法申请到足够的内存，就会抛出`OutOfMemoryError`异常。\n\n#### 4. 堆(Heap)\n\n堆的重要性是因为我们平时所需要的性能调优，GC等都发生在此内存区域。\n三种常见的JVM：HotSpot,JRockit,j9vm。而平时用的几乎都是HotSpot，我们来看看它的实现。\n\n##### 4.1 堆内存的划分\n\n由于现在GC收集器基本都采用分代收集算法，所以Java堆中可以细分为：\n\n* 新生代(Young Generation) : 99%的对象生命周期\n  * 伊甸区(Eden Space) : 创建对象\n  * 幸存者区(Survivor Space) : 对象活过GC就进入\n* 老年代(Old Generation)\n  * 养老区(Tenured Space) ： 幸存者区活过多次GC进入；大对象直接进入\n* <del>永久代(Perm Gen)</del>  元空间(MetaSpace,支持动态扩展，since Java8)\n\n![JVM heap structure](/images/jvm/JVM_Structure.png)\n\n##### 4.2 GC分类\n\n* Partial GC：并不收集整个GC堆的模式\n  * Young GC：只收集young gen的GC\n  * Old GC：只收集old gen的GC。只有CMS的concurrent collection是这个模式\n  * Mixed GC：收集整个young gen以及部分old gen的GC。只有G1有这个模式\n* Full GC：收集整个堆，包括young gen、old gen、perm gen（如果存在的话）等所有部分的模式。\n\n假如伊甸区和养老区都满了，就会发生`OutOfMemoryError`.\n\n##### 4.3 GC算法\n\n* 复制算法\n\n* 标记-清除 & 标记-整理算法\n\n* 分代收集算法\n\n没有什么新的思想，只是因为在实际场景中，并没有一种算法能够同时在所有场景下保证最优。\n所以针对每个内存区域，对象的存活率不同，可以对不同内存（新生代，老年代）采用最适当的手机算法。\n\n* 新生代 每次GC都会有大批对象死去，对象存活率低  选用复制算法\n* 老年代 对象存活率高 选用标记-清除，标记-整理算法\n\n##### 4.4 HeapDump\n\n加参数 -XX:+HeapDumpOnOutOfMemoryError 在发生OOM时生成堆快照\n","slug":"java/JVM常用知识点","published":1,"updated":"2020-10-27T08:08:15.940Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckio9dwfh004xk8nehj7753js","content":"<h4 id=\"1-JVM运行时数据区\"><a href=\"#1-JVM运行时数据区\" class=\"headerlink\" title=\"1. JVM运行时数据区\"></a>1. JVM运行时数据区</h4><p>这个图相信很多人都看过N多次了，自己再做一次加深下记忆<br><img src=\"/images/jvm/JVMRuntime.png\" alt=\"JVM Runtime\"></p>\n<p>其中方法区和堆是由所有线程共享的数据区，而我们绝大多数的JVM调优都是针对方法区和堆。<br>其它都是线程隔离的数据区。<br>想要理解JVM，有3个比较重要的概念需要了解清楚，分别是：</p>\n<ul>\n<li>类加载机制</li>\n<li>虚拟机栈</li>\n<li>堆<a id=\"more\"></a>\n<h4 id=\"2-类加载器\"><a href=\"#2-类加载器\" class=\"headerlink\" title=\"2. 类加载器\"></a>2. 类加载器</h4></li>\n</ul>\n<h5 id=\"2-1-类加载机制\"><a href=\"#2-1-类加载机制\" class=\"headerlink\" title=\"2.1 类加载机制\"></a>2.1 类加载机制</h5><p>虚拟机把描述类的数据从class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。</p>\n<h5 id=\"2-2-类的生命周期\"><a href=\"#2-2-类的生命周期\" class=\"headerlink\" title=\"2.2 类的生命周期\"></a>2.2 类的生命周期</h5><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，整个生命周期包括：<br><img src=\"/images/jvm/ClassLoader.png\" alt=\"类的生命周期\"></p>\n<p>其中类的加载、验证、准备、初始化、卸载这5个阶段是按照顺序开始的，<strong>解析</strong>阶段则不一定，某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定。</p>\n<h5 id=\"2-3-类加载器\"><a href=\"#2-3-类加载器\" class=\"headerlink\" title=\"2.3 类加载器\"></a>2.3 类加载器</h5><p>绝大部分Java程序都会使用到以下三种系统提供的类加载器：</p>\n<ul>\n<li>启动类加载器(Bootstrap Classloader)： 加载${JAVA_HOME}/lib目录中的，并且虚拟机可识别的</li>\n<li>扩展类加载器(Extension Classloader): 加载${JAVA_HOME}/lib/ext目录中的扩展类</li>\n<li>应用程序类加载器(Application Classloader): 加载ClassPath上所指定的类库，可以理解为加载所有开发者自己写的类</li>\n</ul>\n<p>如果有必要，还可以加入自己定义的类加载器。</p>\n<h5 id=\"2-4-双亲委派模型-Parents-Delegation-Model\"><a href=\"#2-4-双亲委派模型-Parents-Delegation-Model\" class=\"headerlink\" title=\"2.4 双亲委派模型(Parents Delegation Model)\"></a>2.4 双亲委派模型(Parents Delegation Model)</h5><p><img src=\"/images/jvm/ParentsDelegationModel.png\" alt=\"双亲委派模型\"></p>\n<ol>\n<li>类加载器收到了加载类的请求，它首先不会自己加载这个类，而是把这个请求委派给父类加载器完成，每一个层次的类加载器都是如此。</li>\n<li>一直向上委派，因此所有的加载请求都应该传送到顶层的启动类加载器中。</li>\n<li>启动类加载器会检测当前类能否被加载，如果可以则加载；如果不可以则向下传递，反馈给子加载器，让其尝试自己进行加载。</li>\n</ol>\n<p>有了双亲委派模型，才保证了Java类型体系中最基础的行为。</p>\n<h5 id=\"2-5-OSGi\"><a href=\"#2-5-OSGi\" class=\"headerlink\" title=\"2.5 OSGi\"></a>2.5 OSGi</h5><p>OSGi中的类加载器并不符合传统的双亲委派的类加载器，但其对类加载器的使用是很值得学习的。</p>\n<h4 id=\"3-虚拟机栈-VM-Stack\"><a href=\"#3-虚拟机栈-VM-Stack\" class=\"headerlink\" title=\"3. 虚拟机栈(VM Stack)\"></a>3. 虚拟机栈(VM Stack)</h4><p>了解虚拟机栈对于我们理解JVM中方法的运行有极大帮助，通过原理，我们可以了解线程中的方法调用链，知道为什么生产环境中不建议甚至禁止使用递归。<br><img src=\"/images/jvm/StackFrame.png\" alt=\"Stack Frame\"></p>\n<p>一个线程中的方法调用链可能会很长，很多方法同时处于执行状态。<br>对于执行引擎来讲，在活动线程中，只有位于栈顶的栈帧才是有效的，称为当前栈帧(Current Stack Frame),与之相关联的方法称为当前方法(Current Method)。</p>\n<p>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出<code>StackOverFlowError</code>异常；<br>如果虚拟机栈可以动态扩展，若扩展时无法申请到足够的内存，就会抛出<code>OutOfMemoryError</code>异常。</p>\n<h4 id=\"4-堆-Heap\"><a href=\"#4-堆-Heap\" class=\"headerlink\" title=\"4. 堆(Heap)\"></a>4. 堆(Heap)</h4><p>堆的重要性是因为我们平时所需要的性能调优，GC等都发生在此内存区域。<br>三种常见的JVM：HotSpot,JRockit,j9vm。而平时用的几乎都是HotSpot，我们来看看它的实现。</p>\n<h5 id=\"4-1-堆内存的划分\"><a href=\"#4-1-堆内存的划分\" class=\"headerlink\" title=\"4.1 堆内存的划分\"></a>4.1 堆内存的划分</h5><p>由于现在GC收集器基本都采用分代收集算法，所以Java堆中可以细分为：</p>\n<ul>\n<li>新生代(Young Generation) : 99%的对象生命周期<ul>\n<li>伊甸区(Eden Space) : 创建对象</li>\n<li>幸存者区(Survivor Space) : 对象活过GC就进入</li>\n</ul>\n</li>\n<li>老年代(Old Generation)<ul>\n<li>养老区(Tenured Space) ： 幸存者区活过多次GC进入；大对象直接进入</li>\n</ul>\n</li>\n<li><del>永久代(Perm Gen)</del>  元空间(MetaSpace,支持动态扩展，since Java8)</li>\n</ul>\n<p><img src=\"/images/jvm/JVM_Structure.png\" alt=\"JVM heap structure\"></p>\n<h5 id=\"4-2-GC分类\"><a href=\"#4-2-GC分类\" class=\"headerlink\" title=\"4.2 GC分类\"></a>4.2 GC分类</h5><ul>\n<li>Partial GC：并不收集整个GC堆的模式<ul>\n<li>Young GC：只收集young gen的GC</li>\n<li>Old GC：只收集old gen的GC。只有CMS的concurrent collection是这个模式</li>\n<li>Mixed GC：收集整个young gen以及部分old gen的GC。只有G1有这个模式</li>\n</ul>\n</li>\n<li>Full GC：收集整个堆，包括young gen、old gen、perm gen（如果存在的话）等所有部分的模式。</li>\n</ul>\n<p>假如伊甸区和养老区都满了，就会发生<code>OutOfMemoryError</code>.</p>\n<h5 id=\"4-3-GC算法\"><a href=\"#4-3-GC算法\" class=\"headerlink\" title=\"4.3 GC算法\"></a>4.3 GC算法</h5><ul>\n<li><p>复制算法</p>\n</li>\n<li><p>标记-清除 &amp; 标记-整理算法</p>\n</li>\n<li><p>分代收集算法</p>\n</li>\n</ul>\n<p>没有什么新的思想，只是因为在实际场景中，并没有一种算法能够同时在所有场景下保证最优。<br>所以针对每个内存区域，对象的存活率不同，可以对不同内存（新生代，老年代）采用最适当的手机算法。</p>\n<ul>\n<li>新生代 每次GC都会有大批对象死去，对象存活率低  选用复制算法</li>\n<li>老年代 对象存活率高 选用标记-清除，标记-整理算法</li>\n</ul>\n<h5 id=\"4-4-HeapDump\"><a href=\"#4-4-HeapDump\" class=\"headerlink\" title=\"4.4 HeapDump\"></a>4.4 HeapDump</h5><p>加参数 -XX:+HeapDumpOnOutOfMemoryError 在发生OOM时生成堆快照</p>\n","site":{"data":{}},"excerpt":"<h4 id=\"1-JVM运行时数据区\"><a href=\"#1-JVM运行时数据区\" class=\"headerlink\" title=\"1. JVM运行时数据区\"></a>1. JVM运行时数据区</h4><p>这个图相信很多人都看过N多次了，自己再做一次加深下记忆<br><img src=\"/images/jvm/JVMRuntime.png\" alt=\"JVM Runtime\"></p>\n<p>其中方法区和堆是由所有线程共享的数据区，而我们绝大多数的JVM调优都是针对方法区和堆。<br>其它都是线程隔离的数据区。<br>想要理解JVM，有3个比较重要的概念需要了解清楚，分别是：</p>\n<ul>\n<li>类加载机制</li>\n<li>虚拟机栈</li>\n<li>堆","more":"<h4 id=\"2-类加载器\"><a href=\"#2-类加载器\" class=\"headerlink\" title=\"2. 类加载器\"></a>2. 类加载器</h4></li>\n</ul>\n<h5 id=\"2-1-类加载机制\"><a href=\"#2-1-类加载机制\" class=\"headerlink\" title=\"2.1 类加载机制\"></a>2.1 类加载机制</h5><p>虚拟机把描述类的数据从class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。</p>\n<h5 id=\"2-2-类的生命周期\"><a href=\"#2-2-类的生命周期\" class=\"headerlink\" title=\"2.2 类的生命周期\"></a>2.2 类的生命周期</h5><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，整个生命周期包括：<br><img src=\"/images/jvm/ClassLoader.png\" alt=\"类的生命周期\"></p>\n<p>其中类的加载、验证、准备、初始化、卸载这5个阶段是按照顺序开始的，<strong>解析</strong>阶段则不一定，某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定。</p>\n<h5 id=\"2-3-类加载器\"><a href=\"#2-3-类加载器\" class=\"headerlink\" title=\"2.3 类加载器\"></a>2.3 类加载器</h5><p>绝大部分Java程序都会使用到以下三种系统提供的类加载器：</p>\n<ul>\n<li>启动类加载器(Bootstrap Classloader)： 加载${JAVA_HOME}/lib目录中的，并且虚拟机可识别的</li>\n<li>扩展类加载器(Extension Classloader): 加载${JAVA_HOME}/lib/ext目录中的扩展类</li>\n<li>应用程序类加载器(Application Classloader): 加载ClassPath上所指定的类库，可以理解为加载所有开发者自己写的类</li>\n</ul>\n<p>如果有必要，还可以加入自己定义的类加载器。</p>\n<h5 id=\"2-4-双亲委派模型-Parents-Delegation-Model\"><a href=\"#2-4-双亲委派模型-Parents-Delegation-Model\" class=\"headerlink\" title=\"2.4 双亲委派模型(Parents Delegation Model)\"></a>2.4 双亲委派模型(Parents Delegation Model)</h5><p><img src=\"/images/jvm/ParentsDelegationModel.png\" alt=\"双亲委派模型\"></p>\n<ol>\n<li>类加载器收到了加载类的请求，它首先不会自己加载这个类，而是把这个请求委派给父类加载器完成，每一个层次的类加载器都是如此。</li>\n<li>一直向上委派，因此所有的加载请求都应该传送到顶层的启动类加载器中。</li>\n<li>启动类加载器会检测当前类能否被加载，如果可以则加载；如果不可以则向下传递，反馈给子加载器，让其尝试自己进行加载。</li>\n</ol>\n<p>有了双亲委派模型，才保证了Java类型体系中最基础的行为。</p>\n<h5 id=\"2-5-OSGi\"><a href=\"#2-5-OSGi\" class=\"headerlink\" title=\"2.5 OSGi\"></a>2.5 OSGi</h5><p>OSGi中的类加载器并不符合传统的双亲委派的类加载器，但其对类加载器的使用是很值得学习的。</p>\n<h4 id=\"3-虚拟机栈-VM-Stack\"><a href=\"#3-虚拟机栈-VM-Stack\" class=\"headerlink\" title=\"3. 虚拟机栈(VM Stack)\"></a>3. 虚拟机栈(VM Stack)</h4><p>了解虚拟机栈对于我们理解JVM中方法的运行有极大帮助，通过原理，我们可以了解线程中的方法调用链，知道为什么生产环境中不建议甚至禁止使用递归。<br><img src=\"/images/jvm/StackFrame.png\" alt=\"Stack Frame\"></p>\n<p>一个线程中的方法调用链可能会很长，很多方法同时处于执行状态。<br>对于执行引擎来讲，在活动线程中，只有位于栈顶的栈帧才是有效的，称为当前栈帧(Current Stack Frame),与之相关联的方法称为当前方法(Current Method)。</p>\n<p>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出<code>StackOverFlowError</code>异常；<br>如果虚拟机栈可以动态扩展，若扩展时无法申请到足够的内存，就会抛出<code>OutOfMemoryError</code>异常。</p>\n<h4 id=\"4-堆-Heap\"><a href=\"#4-堆-Heap\" class=\"headerlink\" title=\"4. 堆(Heap)\"></a>4. 堆(Heap)</h4><p>堆的重要性是因为我们平时所需要的性能调优，GC等都发生在此内存区域。<br>三种常见的JVM：HotSpot,JRockit,j9vm。而平时用的几乎都是HotSpot，我们来看看它的实现。</p>\n<h5 id=\"4-1-堆内存的划分\"><a href=\"#4-1-堆内存的划分\" class=\"headerlink\" title=\"4.1 堆内存的划分\"></a>4.1 堆内存的划分</h5><p>由于现在GC收集器基本都采用分代收集算法，所以Java堆中可以细分为：</p>\n<ul>\n<li>新生代(Young Generation) : 99%的对象生命周期<ul>\n<li>伊甸区(Eden Space) : 创建对象</li>\n<li>幸存者区(Survivor Space) : 对象活过GC就进入</li>\n</ul>\n</li>\n<li>老年代(Old Generation)<ul>\n<li>养老区(Tenured Space) ： 幸存者区活过多次GC进入；大对象直接进入</li>\n</ul>\n</li>\n<li><del>永久代(Perm Gen)</del>  元空间(MetaSpace,支持动态扩展，since Java8)</li>\n</ul>\n<p><img src=\"/images/jvm/JVM_Structure.png\" alt=\"JVM heap structure\"></p>\n<h5 id=\"4-2-GC分类\"><a href=\"#4-2-GC分类\" class=\"headerlink\" title=\"4.2 GC分类\"></a>4.2 GC分类</h5><ul>\n<li>Partial GC：并不收集整个GC堆的模式<ul>\n<li>Young GC：只收集young gen的GC</li>\n<li>Old GC：只收集old gen的GC。只有CMS的concurrent collection是这个模式</li>\n<li>Mixed GC：收集整个young gen以及部分old gen的GC。只有G1有这个模式</li>\n</ul>\n</li>\n<li>Full GC：收集整个堆，包括young gen、old gen、perm gen（如果存在的话）等所有部分的模式。</li>\n</ul>\n<p>假如伊甸区和养老区都满了，就会发生<code>OutOfMemoryError</code>.</p>\n<h5 id=\"4-3-GC算法\"><a href=\"#4-3-GC算法\" class=\"headerlink\" title=\"4.3 GC算法\"></a>4.3 GC算法</h5><ul>\n<li><p>复制算法</p>\n</li>\n<li><p>标记-清除 &amp; 标记-整理算法</p>\n</li>\n<li><p>分代收集算法</p>\n</li>\n</ul>\n<p>没有什么新的思想，只是因为在实际场景中，并没有一种算法能够同时在所有场景下保证最优。<br>所以针对每个内存区域，对象的存活率不同，可以对不同内存（新生代，老年代）采用最适当的手机算法。</p>\n<ul>\n<li>新生代 每次GC都会有大批对象死去，对象存活率低  选用复制算法</li>\n<li>老年代 对象存活率高 选用标记-清除，标记-整理算法</li>\n</ul>\n<h5 id=\"4-4-HeapDump\"><a href=\"#4-4-HeapDump\" class=\"headerlink\" title=\"4.4 HeapDump\"></a>4.4 HeapDump</h5><p>加参数 -XX:+HeapDumpOnOutOfMemoryError 在发生OOM时生成堆快照</p>"}],"PostAsset":[],"PostCategory":[{"post_id":"ckio9dwcv0007k8nexoc1pw12","category_id":"ckio9dwcr0004k8nekikdk64e","_id":"ckio9dwd3000dk8nea7n89cy7"},{"post_id":"ckio9dwcl0002k8neclr42h7o","category_id":"ckio9dwcr0004k8nekikdk64e","_id":"ckio9dwd5000hk8nemwsno05e"},{"post_id":"ckio9dwcw0008k8neq3v861vp","category_id":"ckio9dwcr0004k8nekikdk64e","_id":"ckio9dwd8000kk8nexc5yxysc"},{"post_id":"ckio9dwd0000bk8ne9rah7rvo","category_id":"ckio9dwcr0004k8nekikdk64e","_id":"ckio9dwdb000ok8neooz3sjpy"},{"post_id":"ckio9dwcp0003k8nem7m68ud8","category_id":"ckio9dwcr0004k8nekikdk64e","_id":"ckio9dwdc000rk8nen6nip6do"},{"post_id":"ckio9dwd2000ck8neokk8lq6w","category_id":"ckio9dwcr0004k8nekikdk64e","_id":"ckio9dwde000vk8ne6i1ercbx"},{"post_id":"ckio9dwd5000gk8nejtyrvwpg","category_id":"ckio9dwcr0004k8nekikdk64e","_id":"ckio9dwdg000yk8nez1fddz1v"},{"post_id":"ckio9dwct0006k8ne6dk4mu55","category_id":"ckio9dwcr0004k8nekikdk64e","_id":"ckio9dwdi0012k8ne8rgxq1pd"},{"post_id":"ckio9dwd6000jk8nexq477swe","category_id":"ckio9dwcr0004k8nekikdk64e","_id":"ckio9dwdj0015k8nenu6qibwa"},{"post_id":"ckio9dwda000nk8neo1svote1","category_id":"ckio9dwcr0004k8nekikdk64e","_id":"ckio9dwdl0019k8ne04qpbdrq"},{"post_id":"ckio9dwdc000qk8nepxuhdssl","category_id":"ckio9dwcr0004k8nekikdk64e","_id":"ckio9dwdm001ck8nedhb94t8c"},{"post_id":"ckio9dwdd000uk8nend7cxsni","category_id":"ckio9dwcr0004k8nekikdk64e","_id":"ckio9dwdp001gk8nemknslmjn"},{"post_id":"ckio9dwdf000xk8ne5j7k7mvh","category_id":"ckio9dwcr0004k8nekikdk64e","_id":"ckio9dwdr001jk8nesvpqw2ed"},{"post_id":"ckio9dwdh0011k8neubpx14wq","category_id":"ckio9dwcr0004k8nekikdk64e","_id":"ckio9dwdt001nk8ne928szohv"},{"post_id":"ckio9dwdi0014k8nei26tugka","category_id":"ckio9dwcr0004k8nekikdk64e","_id":"ckio9dwdv001qk8nez15x7ddn"},{"post_id":"ckio9dwdk0018k8ne5zw3zfhk","category_id":"ckio9dwcr0004k8nekikdk64e","_id":"ckio9dwdw001uk8ne8zwd25o6"},{"post_id":"ckio9dwdm001bk8necbribfqu","category_id":"ckio9dwcr0004k8nekikdk64e","_id":"ckio9dwdy001xk8new5igamop"},{"post_id":"ckio9dwdo001fk8nebhmn7brz","category_id":"ckio9dwcr0004k8nekikdk64e","_id":"ckio9dwe00021k8nejfvdlk57"},{"post_id":"ckio9dwdq001ik8ned5musc3o","category_id":"ckio9dwcr0004k8nekikdk64e","_id":"ckio9dwe10024k8ne2wmhqc1b"},{"post_id":"ckio9dwds001mk8ne0ilej18t","category_id":"ckio9dwcr0004k8nekikdk64e","_id":"ckio9dwe40028k8nehzcrz0hb"},{"post_id":"ckio9dwdu001pk8ne02m8dqp8","category_id":"ckio9dwcr0004k8nekikdk64e","_id":"ckio9dwe6002bk8ne3ous7x3s"},{"post_id":"ckio9dwdw001tk8nemy5umwp0","category_id":"ckio9dwcr0004k8nekikdk64e","_id":"ckio9dwe7002ek8ne6bhgvjqp"},{"post_id":"ckio9dwdx001wk8nehzqb6a45","category_id":"ckio9dwcr0004k8nekikdk64e","_id":"ckio9dwe9002ik8nernzz1ukd"},{"post_id":"ckio9dwdz0020k8neuvg84tta","category_id":"ckio9dwcr0004k8nekikdk64e","_id":"ckio9dwea002lk8ne692nqb81"},{"post_id":"ckio9dwe00023k8nejrp4dxxl","category_id":"ckio9dwcr0004k8nekikdk64e","_id":"ckio9dwec002pk8nefvgcvbry"},{"post_id":"ckio9dwe30027k8nexkmrefuj","category_id":"ckio9dwcr0004k8nekikdk64e","_id":"ckio9dwee002sk8nefcb6p5p2"},{"post_id":"ckio9dwe5002ak8neba7a17ov","category_id":"ckio9dwcr0004k8nekikdk64e","_id":"ckio9dweg002wk8nercilosq7"},{"post_id":"ckio9dwe6002dk8neyoqbbi4f","category_id":"ckio9dwcr0004k8nekikdk64e","_id":"ckio9dwei002zk8nejl68odiv"},{"post_id":"ckio9dwe8002hk8neu8k50et5","category_id":"ckio9dwcr0004k8nekikdk64e","_id":"ckio9dwek0034k8ne86lh1q8h"},{"post_id":"ckio9dwea002kk8negbnm0prs","category_id":"ckio9dwcr0004k8nekikdk64e","_id":"ckio9dwel0037k8nelal57q82"},{"post_id":"ckio9dwec002ok8neab7a4oqw","category_id":"ckio9dwcr0004k8nekikdk64e","_id":"ckio9dwen003ck8neo417wqqp"},{"post_id":"ckio9dwed002rk8nec8vrqtu5","category_id":"ckio9dwcr0004k8nekikdk64e","_id":"ckio9dwep003fk8netakthmz3"},{"post_id":"ckio9dweg002yk8nef2lr37sh","category_id":"ckio9dwcr0004k8nekikdk64e","_id":"ckio9dwer003kk8nea39es4ex"},{"post_id":"ckio9dwef002vk8nex4z9347f","category_id":"ckio9dwej0031k8neai0ashr5","_id":"ckio9dwes003nk8ne0cjpnf4p"},{"post_id":"ckio9dwej0033k8nejxn78ih7","category_id":"ckio9dwej0031k8neai0ashr5","_id":"ckio9dweu003rk8neq4rlcaaz"},{"post_id":"ckio9dwel0036k8neuin665oc","category_id":"ckio9dwer003jk8nezo1c0l2o","_id":"ckio9dwez003zk8ne1qtdatsw"},{"post_id":"ckio9dweu003qk8nec7nhe0x2","category_id":"ckio9dwer003jk8nezo1c0l2o","_id":"ckio9dwf00042k8neu3bhiiy6"},{"post_id":"ckio9dweo003ek8neb7q6pme3","category_id":"ckio9dwer003jk8nezo1c0l2o","_id":"ckio9dwf40046k8nejn8zd6u0"},{"post_id":"ckio9dwez0041k8ne9opc0onp","category_id":"ckio9dwey003yk8nerfpo5iye","_id":"ckio9dwf7004dk8neq0rnhry6"},{"post_id":"ckio9dwes003mk8ne5jid51dg","category_id":"ckio9dwey003yk8nerfpo5iye","_id":"ckio9dwf8004hk8ne5jz21feq"},{"post_id":"ckio9dwf8004gk8nep3q14dq4","category_id":"ckio9dwey003yk8nerfpo5iye","_id":"ckio9dwff004rk8nednqfcg82"},{"post_id":"ckio9dwey003xk8ne0v5sd0r4","category_id":"ckio9dwey003yk8nerfpo5iye","_id":"ckio9dwfg004vk8ner5o252em"},{"post_id":"ckio9dwf9004kk8neln4t3s43","category_id":"ckio9dwey003yk8nerfpo5iye","_id":"ckio9dwfi004yk8nepoe4cy2y"},{"post_id":"ckio9dwfc004nk8neiifg6s8a","category_id":"ckio9dwff004sk8ney8iy7lww","_id":"ckio9dwfl0056k8ne6yaha61o"},{"post_id":"ckio9dwfe004qk8nez0p19hgz","category_id":"ckio9dwff004sk8ney8iy7lww","_id":"ckio9dwfo005bk8neqyxk22av"},{"post_id":"ckio9dwfg004uk8nenye67j1x","category_id":"ckio9dwff004sk8ney8iy7lww","_id":"ckio9dwfp005fk8nenlw7pwpa"},{"post_id":"ckio9dwfh004xk8nehj7753js","category_id":"ckio9dwfn005ak8nelw6z1gj9","_id":"ckio9dwfq005jk8neoeuemg24"},{"post_id":"ckio9dwev003uk8ne90nn7yzz","category_id":"ckio9dwey003yk8nerfpo5iye","_id":"ckio9nhxk007kk8neyitidt41"}],"PostTag":[{"post_id":"ckio9dwcl0002k8neclr42h7o","tag_id":"ckio9dwct0005k8ne8thzml2l","_id":"ckio9dwd6000ik8ne4w2k75s4"},{"post_id":"ckio9dwcl0002k8neclr42h7o","tag_id":"ckio9dwcy000ak8ne55uhoij5","_id":"ckio9dwd8000lk8neqetb0807"},{"post_id":"ckio9dwcp0003k8nem7m68ud8","tag_id":"ckio9dwct0005k8ne8thzml2l","_id":"ckio9dwdb000pk8ne2ofm0ev3"},{"post_id":"ckio9dwda000nk8neo1svote1","tag_id":"ckio9dwct0005k8ne8thzml2l","_id":"ckio9dwdd000tk8neari15o86"},{"post_id":"ckio9dwct0006k8ne6dk4mu55","tag_id":"ckio9dwct0005k8ne8thzml2l","_id":"ckio9dwdf000wk8ne7pjdl5xw"},{"post_id":"ckio9dwdc000qk8nepxuhdssl","tag_id":"ckio9dwct0005k8ne8thzml2l","_id":"ckio9dwdg0010k8ne21ok3y13"},{"post_id":"ckio9dwdd000uk8nend7cxsni","tag_id":"ckio9dwct0005k8ne8thzml2l","_id":"ckio9dwdi0013k8nelgqsu1mp"},{"post_id":"ckio9dwcv0007k8nexoc1pw12","tag_id":"ckio9dwct0005k8ne8thzml2l","_id":"ckio9dwdk0017k8netd2kot8p"},{"post_id":"ckio9dwcv0007k8nexoc1pw12","tag_id":"ckio9dwdd000sk8nens2lpyig","_id":"ckio9dwdl001ak8ne4qkznd4s"},{"post_id":"ckio9dwdf000xk8ne5j7k7mvh","tag_id":"ckio9dwct0005k8ne8thzml2l","_id":"ckio9dwdn001ek8new07shpha"},{"post_id":"ckio9dwcw0008k8neq3v861vp","tag_id":"ckio9dwct0005k8ne8thzml2l","_id":"ckio9dwdq001hk8nerk5z7z85"},{"post_id":"ckio9dwcw0008k8neq3v861vp","tag_id":"ckio9dwcy000ak8ne55uhoij5","_id":"ckio9dwds001lk8ne1k1ll5qo"},{"post_id":"ckio9dwd0000bk8ne9rah7rvo","tag_id":"ckio9dwct0005k8ne8thzml2l","_id":"ckio9dwdu001ok8nehjamched"},{"post_id":"ckio9dwd0000bk8ne9rah7rvo","tag_id":"ckio9dwdd000sk8nens2lpyig","_id":"ckio9dwdv001sk8nei7f4odj3"},{"post_id":"ckio9dwd2000ck8neokk8lq6w","tag_id":"ckio9dwct0005k8ne8thzml2l","_id":"ckio9dwdx001vk8ne28vr3nrz"},{"post_id":"ckio9dwd2000ck8neokk8lq6w","tag_id":"ckio9dwdd000sk8nens2lpyig","_id":"ckio9dwdz001zk8neipgujc1f"},{"post_id":"ckio9dwd5000gk8nejtyrvwpg","tag_id":"ckio9dwct0005k8ne8thzml2l","_id":"ckio9dwe00022k8nejxuy2f1l"},{"post_id":"ckio9dwd5000gk8nejtyrvwpg","tag_id":"ckio9dwdd000sk8nens2lpyig","_id":"ckio9dwe20025k8ney2582nx1"},{"post_id":"ckio9dwd6000jk8nexq477swe","tag_id":"ckio9dwct0005k8ne8thzml2l","_id":"ckio9dwe50029k8ne1ytejkag"},{"post_id":"ckio9dwd6000jk8nexq477swe","tag_id":"ckio9dwdd000sk8nens2lpyig","_id":"ckio9dwe6002ck8neipy4q60l"},{"post_id":"ckio9dwdz0020k8neuvg84tta","tag_id":"ckio9dwct0005k8ne8thzml2l","_id":"ckio9dwe8002gk8neobgn038f"},{"post_id":"ckio9dwdz0020k8neuvg84tta","tag_id":"ckio9dwdd000sk8nens2lpyig","_id":"ckio9dwea002jk8ne7dnbfrnb"},{"post_id":"ckio9dwdh0011k8neubpx14wq","tag_id":"ckio9dwct0005k8ne8thzml2l","_id":"ckio9dweb002nk8neituk4q1u"},{"post_id":"ckio9dwdh0011k8neubpx14wq","tag_id":"ckio9dwdd000sk8nens2lpyig","_id":"ckio9dwed002qk8nek55hk3bm"},{"post_id":"ckio9dwdh0011k8neubpx14wq","tag_id":"ckio9dwdy001yk8nei81p4gek","_id":"ckio9dwef002uk8ne5m5v8m4m"},{"post_id":"ckio9dwe30027k8nexkmrefuj","tag_id":"ckio9dwct0005k8ne8thzml2l","_id":"ckio9dweg002xk8ne5inaevhz"},{"post_id":"ckio9dwe30027k8nexkmrefuj","tag_id":"ckio9dwdd000sk8nens2lpyig","_id":"ckio9dwej0032k8nef7zu0qcf"},{"post_id":"ckio9dwdi0014k8nei26tugka","tag_id":"ckio9dwct0005k8ne8thzml2l","_id":"ckio9dwek0035k8neuonp5vfs"},{"post_id":"ckio9dwdi0014k8nei26tugka","tag_id":"ckio9dwe20026k8ne1ipttna0","_id":"ckio9dwem0039k8ne0zzxuufk"},{"post_id":"ckio9dwdk0018k8ne5zw3zfhk","tag_id":"ckio9dwct0005k8ne8thzml2l","_id":"ckio9dweo003dk8nedks4zx30"},{"post_id":"ckio9dwdk0018k8ne5zw3zfhk","tag_id":"ckio9dwe20026k8ne1ipttna0","_id":"ckio9dweq003hk8nejd6rc4gq"},{"post_id":"ckio9dwdm001bk8necbribfqu","tag_id":"ckio9dwct0005k8ne8thzml2l","_id":"ckio9dwer003lk8newb055skr"},{"post_id":"ckio9dwdm001bk8necbribfqu","tag_id":"ckio9dwe20026k8ne1ipttna0","_id":"ckio9dwet003pk8ne9go9qmjx"},{"post_id":"ckio9dwed002rk8nec8vrqtu5","tag_id":"ckio9dwct0005k8ne8thzml2l","_id":"ckio9dwev003tk8nezski6jwu"},{"post_id":"ckio9dwed002rk8nec8vrqtu5","tag_id":"ckio9dwcy000ak8ne55uhoij5","_id":"ckio9dwex003wk8neijxz6aiz"},{"post_id":"ckio9dwdo001fk8nebhmn7brz","tag_id":"ckio9dwct0005k8ne8thzml2l","_id":"ckio9dwez0040k8ne63n9wop3"},{"post_id":"ckio9dwdo001fk8nebhmn7brz","tag_id":"ckio9dwe20026k8ne1ipttna0","_id":"ckio9dwf00044k8nergsq7mi7"},{"post_id":"ckio9dwdq001ik8ned5musc3o","tag_id":"ckio9dwct0005k8ne8thzml2l","_id":"ckio9dwf40048k8nejv5yi3jr"},{"post_id":"ckio9dwdq001ik8ned5musc3o","tag_id":"ckio9dwe20026k8ne1ipttna0","_id":"ckio9dwf6004bk8neafg6v3kj"},{"post_id":"ckio9dwds001mk8ne0ilej18t","tag_id":"ckio9dwct0005k8ne8thzml2l","_id":"ckio9dwf7004fk8nekonf0ad5"},{"post_id":"ckio9dwds001mk8ne0ilej18t","tag_id":"ckio9dwem0038k8ne9nffm74b","_id":"ckio9dwf9004ik8nesf4qx5ef"},{"post_id":"ckio9dwdu001pk8ne02m8dqp8","tag_id":"ckio9dwct0005k8ne8thzml2l","_id":"ckio9dwfc004mk8ne36r6uojk"},{"post_id":"ckio9dwdu001pk8ne02m8dqp8","tag_id":"ckio9dwe20026k8ne1ipttna0","_id":"ckio9dwfd004ok8ne1z7wcnun"},{"post_id":"ckio9dwdw001tk8nemy5umwp0","tag_id":"ckio9dwct0005k8ne8thzml2l","_id":"ckio9dwff004tk8nec102a3h4"},{"post_id":"ckio9dwdw001tk8nemy5umwp0","tag_id":"ckio9dwe20026k8ne1ipttna0","_id":"ckio9dwfh004wk8nekc3ganbp"},{"post_id":"ckio9dwdx001wk8nehzqb6a45","tag_id":"ckio9dwct0005k8ne8thzml2l","_id":"ckio9dwfj0050k8nec4yl8jad"},{"post_id":"ckio9dwdx001wk8nehzqb6a45","tag_id":"ckio9dwdy001yk8nei81p4gek","_id":"ckio9dwfk0052k8nerlk8nkw9"},{"post_id":"ckio9dwe00023k8nejrp4dxxl","tag_id":"ckio9dwct0005k8ne8thzml2l","_id":"ckio9dwfl0054k8neezk6lyuw"},{"post_id":"ckio9dwe00023k8nejrp4dxxl","tag_id":"ckio9dwf00043k8nejfvkpbep","_id":"ckio9dwfm0057k8neixoffenv"},{"post_id":"ckio9dwe00023k8nejrp4dxxl","tag_id":"ckio9dwf5004ak8net1kme3et","_id":"ckio9dwfm0059k8ney59fu9du"},{"post_id":"ckio9dwe5002ak8neba7a17ov","tag_id":"ckio9dwct0005k8ne8thzml2l","_id":"ckio9dwfo005ck8nezqh3jnge"},{"post_id":"ckio9dwe5002ak8neba7a17ov","tag_id":"ckio9dwf00043k8nejfvkpbep","_id":"ckio9dwfp005ek8ne9t4io758"},{"post_id":"ckio9dwe5002ak8neba7a17ov","tag_id":"ckio9dwfe004pk8neyjd7cwmq","_id":"ckio9dwfp005gk8ne0c1te8ni"},{"post_id":"ckio9dwe6002dk8neyoqbbi4f","tag_id":"ckio9dwct0005k8ne8thzml2l","_id":"ckio9dwfq005ik8neso17jeda"},{"post_id":"ckio9dwe6002dk8neyoqbbi4f","tag_id":"ckio9dwf5004ak8net1kme3et","_id":"ckio9dwfr005kk8nebyhaw587"},{"post_id":"ckio9dwe6002dk8neyoqbbi4f","tag_id":"ckio9dwem0038k8ne9nffm74b","_id":"ckio9dwfr005mk8ne5x53n0f3"},{"post_id":"ckio9dwe8002hk8neu8k50et5","tag_id":"ckio9dwct0005k8ne8thzml2l","_id":"ckio9dwfr005nk8nepr18dxbm"},{"post_id":"ckio9dwe8002hk8neu8k50et5","tag_id":"ckio9dwfm0058k8neo3xxy2fo","_id":"ckio9dwfs005pk8neq31a7kk2"},{"post_id":"ckio9dwea002kk8negbnm0prs","tag_id":"ckio9dwct0005k8ne8thzml2l","_id":"ckio9dwfs005qk8ne36o7bhs6"},{"post_id":"ckio9dwea002kk8negbnm0prs","tag_id":"ckio9dwf00043k8nejfvkpbep","_id":"ckio9dwft005sk8ner1fhu2rd"},{"post_id":"ckio9dwec002ok8neab7a4oqw","tag_id":"ckio9dwct0005k8ne8thzml2l","_id":"ckio9dwfu005tk8ne28jottk8"},{"post_id":"ckio9dwec002ok8neab7a4oqw","tag_id":"ckio9dwf00043k8nejfvkpbep","_id":"ckio9dwfu005vk8nepbdyl9l9"},{"post_id":"ckio9dwef002vk8nex4z9347f","tag_id":"ckio9dwfr005lk8nel61oj8xk","_id":"ckio9dwfv005wk8ne7ee1mxho"},{"post_id":"ckio9dweg002yk8nef2lr37sh","tag_id":"ckio9dwct0005k8ne8thzml2l","_id":"ckio9dwfv005xk8nen6fvmw0h"},{"post_id":"ckio9dweg002yk8nef2lr37sh","tag_id":"ckio9dwf00043k8nejfvkpbep","_id":"ckio9dwfv005zk8nelr6ayi0o"},{"post_id":"ckio9dwej0033k8nejxn78ih7","tag_id":"ckio9dwfr005lk8nel61oj8xk","_id":"ckio9dwfw0060k8news3ay3jx"},{"post_id":"ckio9dwej0033k8nejxn78ih7","tag_id":"ckio9dwfu005uk8neqqd7slsq","_id":"ckio9dwfw0062k8neif6osqx5"},{"post_id":"ckio9dwel0036k8neuin665oc","tag_id":"ckio9dwfv005yk8nen0qvfman","_id":"ckio9dwfx0064k8nedschj3qk"},{"post_id":"ckio9dwel0036k8neuin665oc","tag_id":"ckio9dwfw0061k8nelf1il6qo","_id":"ckio9dwfx0065k8neefrb8xpa"},{"post_id":"ckio9dwem003ak8nezpkrakbu","tag_id":"ckio9dwfw0063k8nedtyutjwi","_id":"ckio9dwfy0068k8neh6gvk0eg"},{"post_id":"ckio9dwem003ak8nezpkrakbu","tag_id":"ckio9dwfx0066k8nex8egodl7","_id":"ckio9dwfy0069k8nethw0rs4j"},{"post_id":"ckio9dweo003ek8neb7q6pme3","tag_id":"ckio9dwfv005yk8nen0qvfman","_id":"ckio9dwg0006ck8nead8lztt5"},{"post_id":"ckio9dweo003ek8neb7q6pme3","tag_id":"ckio9dwfz006ak8nesv65fu2o","_id":"ckio9dwg0006dk8nennlfgnlx"},{"post_id":"ckio9dweq003ik8ne8116f6kz","tag_id":"ckio9dwfw0063k8nedtyutjwi","_id":"ckio9dwg1006gk8nekkfskkds"},{"post_id":"ckio9dweq003ik8ne8116f6kz","tag_id":"ckio9dwg0006ek8neou6b8l7v","_id":"ckio9dwg1006hk8nefx6o7emp"},{"post_id":"ckio9dwes003mk8ne5jid51dg","tag_id":"ckio9dwg0006fk8nexweer01h","_id":"ckio9dwg2006jk8nex4iwhnvt"},{"post_id":"ckio9dweu003qk8nec7nhe0x2","tag_id":"ckio9dwfv005yk8nen0qvfman","_id":"ckio9dwg3006mk8ne3knkcol6"},{"post_id":"ckio9dweu003qk8nec7nhe0x2","tag_id":"ckio9dwg2006kk8neffg40rbj","_id":"ckio9dwg3006nk8negmjl3v7e"},{"post_id":"ckio9dwey003xk8ne0v5sd0r4","tag_id":"ckio9dwg0006fk8nexweer01h","_id":"ckio9dwg5006sk8nexnec1t3e"},{"post_id":"ckio9dwey003xk8ne0v5sd0r4","tag_id":"ckio9dwg4006qk8nesceea3s3","_id":"ckio9dwg5006tk8nef27kg8ek"},{"post_id":"ckio9dwez0041k8ne9opc0onp","tag_id":"ckio9dwg0006fk8nexweer01h","_id":"ckio9dwg5006vk8nefe49xjgj"},{"post_id":"ckio9dwf10045k8newdidqq80","tag_id":"ckio9dwg5006uk8ne3ekzm992","_id":"ckio9dwg7006yk8nek24qli63"},{"post_id":"ckio9dwf10045k8newdidqq80","tag_id":"ckio9dwfv005yk8nen0qvfman","_id":"ckio9dwg7006zk8netuypttdc"},{"post_id":"ckio9dwf8004gk8nep3q14dq4","tag_id":"ckio9dwg0006fk8nexweer01h","_id":"ckio9dwg80071k8newvv92zr4"},{"post_id":"ckio9dwf9004kk8neln4t3s43","tag_id":"ckio9dwg0006fk8nexweer01h","_id":"ckio9dwg90074k8neugq828bb"},{"post_id":"ckio9dwf9004kk8neln4t3s43","tag_id":"ckio9dwg80072k8neqg71b19e","_id":"ckio9dwg90075k8neua15ozay"},{"post_id":"ckio9dwfc004nk8neiifg6s8a","tag_id":"ckio9dwg80073k8netpeapadm","_id":"ckio9dwga0078k8ne8vnvqdjh"},{"post_id":"ckio9dwfc004nk8neiifg6s8a","tag_id":"ckio9dwg90076k8nerm2chbar","_id":"ckio9dwgb0079k8nehwhmc5z4"},{"post_id":"ckio9dwfe004qk8nez0p19hgz","tag_id":"ckio9dwg80073k8netpeapadm","_id":"ckio9dwgc007ck8ne4cc8g9wz"},{"post_id":"ckio9dwfe004qk8nez0p19hgz","tag_id":"ckio9dwgb007ak8ne7mu201ul","_id":"ckio9dwgc007dk8newra8u8he"},{"post_id":"ckio9dwfg004uk8nenye67j1x","tag_id":"ckio9dwg80073k8netpeapadm","_id":"ckio9dwge007gk8nevdhc22sy"},{"post_id":"ckio9dwfg004uk8nenye67j1x","tag_id":"ckio9dwg90076k8nerm2chbar","_id":"ckio9dwge007hk8neuuduu4yb"},{"post_id":"ckio9dwfh004xk8nehj7753js","tag_id":"ckio9dwgd007fk8neqougwdkx","_id":"ckio9dwgf007ik8neftr5hc91"},{"post_id":"ckio9dwev003uk8ne90nn7yzz","tag_id":"ckio9dwg0006fk8nexweer01h","_id":"ckio9nhxj007jk8neul2ih0b5"}],"Tag":[{"name":"数据结构与算法","_id":"ckio9dwct0005k8ne8thzml2l"},{"name":"数组","_id":"ckio9dwcy000ak8ne55uhoij5"},{"name":"链表","_id":"ckio9dwdd000sk8nens2lpyig"},{"name":"双指针","_id":"ckio9dwdy001yk8nei81p4gek"},{"name":"二叉树","_id":"ckio9dwe20026k8ne1ipttna0"},{"name":"动态规划","_id":"ckio9dwem0038k8ne9nffm74b"},{"name":"栈","_id":"ckio9dwf00043k8nejfvkpbep"},{"name":"递归","_id":"ckio9dwf5004ak8net1kme3et"},{"name":"汉诺塔","_id":"ckio9dwfe004pk8neyjd7cwmq"},{"name":"队列","_id":"ckio9dwfm0058k8neo3xxy2fo"},{"name":"设计模式","_id":"ckio9dwfr005lk8nel61oj8xk"},{"name":"软件设计原则","_id":"ckio9dwfu005uk8neqqd7slsq"},{"name":"笔记","_id":"ckio9dwfv005yk8nen0qvfman"},{"name":"事务","_id":"ckio9dwfw0061k8nelf1il6qo"},{"name":"数据仓库","_id":"ckio9dwfw0063k8nedtyutjwi"},{"name":"数仓分层","_id":"ckio9dwfx0066k8nex8egodl7"},{"name":"HDFS","_id":"ckio9dwfz006ak8nesv65fu2o"},{"name":"数据采集","_id":"ckio9dwg0006ek8neou6b8l7v"},{"name":"Flink","_id":"ckio9dwg0006fk8nexweer01h"},{"name":"Flume","_id":"ckio9dwg2006kk8neffg40rbj"},{"name":"窗口函数","_id":"ckio9dwg4006qk8nesceea3s3"},{"name":"DDIA","_id":"ckio9dwg5006uk8ne3ekzm992"},{"name":"踩坑","_id":"ckio9dwg80072k8neqg71b19e"},{"name":"微服务","_id":"ckio9dwg80073k8netpeapadm"},{"name":"网关","_id":"ckio9dwg90076k8nerm2chbar"},{"name":"配置中心","_id":"ckio9dwgb007ak8ne7mu201ul"},{"name":"JVM","_id":"ckio9dwgd007fk8neqougwdkx"}]}}